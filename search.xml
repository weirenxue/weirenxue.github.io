<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Apache] 修改 HTTP 標頭中的 Server 欄位</title>
    <url>/2021/06/17/apache_http_server/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>伺服器資訊包含類型 (IIS、Apache 或 Nginx) 與版本是一個很重要的資訊，當駭客想針對一個網頁應用程式下手時，必定先蒐集這些情報，下一步再看有沒有尚未修復的漏洞可以利用。</p>
<p>因此，若不想使這些資訊這麼透明，我們可以採取一些手段。這篇文章以 Apache 2 為例子隱藏伺服器資訊，不同類型的伺服器的概念都是一樣的。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 20.04 LTS</li>
</ul>
<h2 id="文章結構"><a href="#文章結構" class="headerlink" title="文章結構"></a>文章結構</h2><p>此篇文章分為兩個段落</p>
<ol>
<li>第一個段落說明如何從 HTTP 回應標頭 (HTTP Response Header) 來蒐集伺服器資訊，讓讀者心裡有個底為什麼接下來要這樣改。</li>
<li>第二個段落動手修改 HTTP 回應頭欄位中的 Server 欄位，這裡會採取兩個方式<ul>
<li>使 Server 欄位只剩下 <code>Apache</code>，版本與作業系統資訊不會顯示。</li>
<li>將 Server 欄位改為自己想要的輸出顯示，可以連 <code>Apache</code> 都不顯示。</li>
</ul>
</li>
</ol>
<h2 id="蒐集伺服器資訊"><a href="#蒐集伺服器資訊" class="headerlink" title="蒐集伺服器資訊"></a>蒐集伺服器資訊</h2><h3 id="前置環境與作業"><a href="#前置環境與作業" class="headerlink" title="前置環境與作業"></a>前置環境與作業</h3><p>伺服器 IP 為 localhost，並在當前目錄下創建檔案 <code>message</code>，內容如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HEAD / HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>16 進位形式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000: 4845 4144 202f 2048 5454 502f 312e 310d  HEAD / HTTP/1.1.</span><br><span class="line">00000010: 0a48 6f73 743a 206c 6f63 616c 686f 7374  .Host: localhost</span><br><span class="line">00000020: 0d0a 0d0a                                ....</span><br></pre></td></tr></table></figure>
<p>這裡特別附上該檔案的 16 進位形式，注意每一行後都有 <code>\r\n</code>，也就是 <code>0x0d0a</code>，最後一個空白行 <code>\r\n</code> 可別忘了！因為 linux 的換行只有 <code>\n</code>，如何加上 <code>\r</code> 可以參考：<a href="/2021/06/17/echo_ubuntu_r/">[Echo] 在 Ubuntu 產生包含 \r 換行字元的檔案</a>。</p>
<h3 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h3><p>NetCat 是一把網路瑞士刀，用它來進行網路相關操作是最好用且方便的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ nc localhost 80 &lt; message</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 03 Sep 2020 01:37:03 GMT</span><br><span class="line">Server: Apache/2.4.41 (Ubuntu)</span><br><span class="line">Last-Modified: Thu, 03 Sep 2020 01:24:28 GMT</span><br><span class="line">ETag: <span class="string">&quot;2aa6-5ae5e9d0acf52&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 10918</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<h3 id="資訊洩漏"><a href="#資訊洩漏" class="headerlink" title="資訊洩漏"></a>資訊洩漏</h3><p>從輸出結果可以準確知道使用的伺服器與運行版本資訊，甚至是作業系統的資訊，這些資訊都是當服務被發現有漏洞時，對我們不利的點！</p>
<p>因此，要如何隱藏這個資訊是我們該學的，雖然不能說隱藏起來就萬無一失，只是攻擊方在沒有這些情報下會比較難鎖定，若能拖延到補丁出現，受到攻擊的機率就被降低了！</p>
<h2 id="修改標頭的-Server-欄位"><a href="#修改標頭的-Server-欄位" class="headerlink" title="修改標頭的 Server 欄位"></a>修改標頭的 Server 欄位</h2><p>修改的方法有兩種，各有利弊，這篇文章兩種方法都會記錄，但實際上需要哪一種還是要看個人</p>
<ol>
<li>修改 <code>conf</code> 檔：用 <code>apt-get</code> 安裝的 <code>Apache</code> 只能用這個方法。優點是快速，缺點是最少還是會留下 <code>Apache</code> 的字眼，讓使用者知道伺服器是 Apache。</li>
<li>修改原始碼再自行編譯：優點是可以完全改為自己想顯示的文字，缺點是因為要自行編譯，導致若要更新 Apache，還要再重新下載新的原始碼，重複一樣的步驟，無法像 <code>apt-get</code> 安裝的套件那樣直接更新。</li>
</ol>
<h3 id="修改-conf-檔"><a href="#修改-conf-檔" class="headerlink" title="修改 conf 檔"></a>修改 conf 檔</h3><p>這裡使用的 Apache 版本為 2.4.41，不同版本所要修改的 <code>conf</code> 檔與其所在位置可能不同。</p>
<p>修改 <code>security.conf</code>，其位置在 <code>/etc/apache2/conf-available/security.conf</code>，將內容中 <code>ServerTokens</code> 所對應的值改為 <code>Prod</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ServerTokens</span></span><br><span class="line"><span class="comment"># This directive configures what you return as the Server HTTP response</span></span><br><span class="line"><span class="comment"># Header. The default is &#x27;Full&#x27; which sends information about the OS-Type</span></span><br><span class="line"><span class="comment"># and compiled in modules.</span></span><br><span class="line"><span class="comment"># Set to one of:  Full | OS | Minimal | Minor | Major | Prod</span></span><br><span class="line"><span class="comment"># where Full conveys the most information, and Prod the least.</span></span><br><span class="line"><span class="comment">#ServerTokens Minimal</span></span><br><span class="line">ServerTokens Prod</span><br><span class="line"><span class="comment">#ServerTokens Full</span></span><br></pre></td></tr></table></figure>
<p>重啟 Apache 服務，並且再做一次資訊蒐集，可以發現版本與 OS 的資訊已被隱蔽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo /etc/init.d/apache2 restart</span><br><span class="line">user@pc:~$ nc localhost 80 &lt; message</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 03 Sep 2020 07:50:50 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Thu, 03 Sep 2020 07:25:19 GMT</span><br><span class="line">ETag: <span class="string">&quot;2aa6-5ae63a79037be&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 10918</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<p>這個方法最多只能只能遮蔽到這個程度，知道伺服器是 Apache，但版本與 OS 無法從此處得知。</p>
<h3 id="修改原始碼自行編譯"><a href="#修改原始碼自行編譯" class="headerlink" title="修改原始碼自行編譯"></a>修改原始碼自行編譯</h3><p><a href="https://httpd.apache.org/docs/2.4/install.html">Apache 編譯步驟</a> 官網都有教學，但我們需要修改原始碼，所以還是會細講一下步驟。</p>
<h4 id="下載原始碼"><a href="#下載原始碼" class="headerlink" title="下載原始碼"></a>下載原始碼</h4><p>先到 <a href="https://httpd.apache.org/">Apache 官網</a> 下載想要的版本 (選 tar.gz)，解壓縮後進到資料。其中的 <code>httpd-NN</code> 就是下載的版本啦！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ gzip -d httpd-NN.tar.gz <span class="comment"># 解 gz</span></span><br><span class="line">user@pc:~$ tar xvf httpd-NN.tar    <span class="comment"># 解 tar</span></span><br><span class="line">user@pc:~$ <span class="built_in">cd</span> httpd-NN             <span class="comment"># 進到目錄下</span></span><br></pre></td></tr></table></figure>
<h4 id="修改原始碼"><a href="#修改原始碼" class="headerlink" title="修改原始碼"></a>修改原始碼</h4><p>開啟 <code>httpd-NN/include/ap_release.h</code> 找到 <code>#define AP_SERVER_BASEPRODUCT &quot;Apache&quot;</code>，將 <code>Apache</code> 改為想要顯示在 Server 欄位的文字，僅需修改此處就可以往下個步驟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AP_SERVER_BASEPRODUCT <span class="string">&quot;Server field masked!&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="編譯原始碼"><a href="#編譯原始碼" class="headerlink" title="編譯原始碼"></a>編譯原始碼</h4><p>產出 <code>Makefile</code>，在這步驟可能會遇到相依套件沒裝的問題 <code>apr</code>、<code>apr-util</code> 與 <code>prec</code>，所以先安裝相關套件，網路上很多都教下載這些套件的原碼再 compile，但我認為若可以使用 <code>apt-get install</code> 就盡量使用它，因為之後可以用 <code>apt-get update/upgrade</code> 來更新套件！管理上省事許多</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~/Downloads/httpd-2.4.46 $ sudo apt-get install gcc libapr1 libapr1-dev libaprutil1 libaprutil1-dev libpcre3 libpcre3-dev</span><br><span class="line">user@pc:~/Downloads/httpd-2.4.46 $ ./configure      </span><br></pre></td></tr></table></figure>
<p>若有看官網教學會看到 <code>./configure --prefix=PREFIX</code>，其中 <code>PREFIX</code> 是想安裝 Apache 的地方，不指定的話，就是安裝在預設路徑 <code>/usr/local/apache2</code>，若沒特殊需求就安裝在預設路徑即可。</p>
<p><code>configure</code> 執行成功後目錄下應該會有 <code>Makefile</code>，現在就可以來編譯然後安裝啦。安裝完預設是關閉服務的，記得開啟嘿！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~/Downloads/httpd-2.4.46 $ make                                           <span class="comment"># 編譯</span></span><br><span class="line">user@pc:~/Downloads/httpd-2.4.46 $ sudo make install                              <span class="comment"># 安裝</span></span><br><span class="line">user@pc:~/Downloads/httpd-2.4.46 $ sudo /usr/local/apache2/bin/apachectl -k start <span class="comment"># 開啟服務</span></span><br></pre></td></tr></table></figure>
<p>開啟服務後，檢查 Server 欄位是否被修改了，可以看到的確是剛修改的內容 <code>Server field masked!</code>，但是版本與 OS 的資訊還在，要改的東西還沒完，請繼續下一步修改！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ nc localhost 80 &lt; message</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 03 Sep 2020 09:29:14 GMT</span><br><span class="line">Server: Server field masked!/2.4.46 (Unix)</span><br><span class="line">Last-Modified: Mon, 11 Jun 2007 18:53:14 GMT</span><br><span class="line">ETag: <span class="string">&quot;2d-432a5e4a73a80&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 45</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
<h4 id="修改設定檔"><a href="#修改設定檔" class="headerlink" title="修改設定檔"></a>修改設定檔</h4><p>跟第一個修改方法很類似，要去修改一個 <code>conf</code> 檔，這裡為 <code>/usr/local/apache2/conf/extra/httpd-default.conf</code>，將內容中 <code>ServerTokens</code> 所對應的值改為 <code>Prod</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ServerTokens</span></span><br><span class="line"><span class="comment"># This directive configures what you return as the Server HTTP response</span></span><br><span class="line"><span class="comment"># Header. The default is &#x27;Full&#x27; which sends information about the OS-Type</span></span><br><span class="line"><span class="comment"># and compiled in modules.</span></span><br><span class="line"><span class="comment"># Set to one of:  Full | OS | Minor | Minimal | Major | Prod</span></span><br><span class="line"><span class="comment"># where Full conveys the most information, and Prod the least.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ServerTokens Prod</span><br></pre></td></tr></table></figure>
<p>還沒結束喔！還要修改一個 conf 檔，這裡為 <code>/usr/local/apache2/conf/httpd.conf</code>，將內容中 <code>#Include conf/extra/httpd-default.conf</code> 前的井字號拿掉, 確保上一步的 <code>httpd-default.conf</code> 設定會被載入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Various default settings</span></span><br><span class="line">Include conf/extra/httpd-default.conf</span><br></pre></td></tr></table></figure>
<p>重啟服務，檢查 Server 欄位，可以看到的只剩下剛修改的內容 <code>Server field masked!</code> 完全無法從 Server 欄位得知這是什麼伺服器，更狠一點，也可以改為 <code>Microsoft-IIS/10.0</code> 來混淆視聽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo /usr/local/apache2/bin/apachectl -k restart <span class="comment"># 重啟服務</span></span><br><span class="line">user@pc:~$ nc localhost 80 &lt; message</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 03 Sep 2020 09:49:28 GMT</span><br><span class="line">Server: Server field masked!</span><br><span class="line">Last-Modified: Mon, 11 Jun 2007 18:53:14 GMT</span><br><span class="line">ETag: <span class="string">&quot;2d-432a5e4a73a80&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 45</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ubuntu</tag>
        <tag>20.04</tag>
        <tag>http</tag>
        <tag>server</tag>
        <tag>header</tag>
        <tag>web</tag>
        <tag>modification</tag>
        <tag>netcat</tag>
        <tag>nc</tag>
      </tags>
  </entry>
  <entry>
    <title>[C++] (FARPROC&amp;) 的含意</title>
    <url>/2021/06/11/cfarproc/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在加密與解密一書中看到這樣的寫法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC addr; </span><br><span class="line">(FARPROC&amp;) addr = GetProcAddress(...省略...)</span><br></pre></td></tr></table></figure>
<p>平常只會看到像是 <code>(int)</code>、<code>(int*)</code> 之類的轉型，第一次看到轉型是帶著 <code>&amp;</code> 符號的，引發我的好奇心，藉此研究一番。</p>
<h2 id="探討"><a href="#探討" class="headerlink" title="探討"></a>探討</h2><p>要探討這問題，就要先知道一般再宣告的時候，<code>&amp;</code> 運算元到底發揮甚麼功用，所以先用最簡單的整數(<code>int</code>)宣告來測試，內容分為以下三種：</p>
<ol>
<li><p><code>int a = b;   //這應該大家都知道，就是把b的值給a</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a = b;</span><br><span class="line"><span class="comment">//結果：a = 2; b = 2; &amp;a = 006FF8C0; &amp;b = 006FF8CC;</span></span><br><span class="line"><span class="comment">//結論：值一樣但記憶體位址不一樣</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int *a = &amp;b; //程度好一些的應該知道，這是把b的記憶體位址存到a裡面</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *a = &amp;b;</span><br><span class="line"><span class="comment">//結果：a = 006FF8B4; b = 3; &amp;a = 006FF8A8; &amp;b = 006FF8B4;</span></span><br><span class="line"><span class="comment">//結論：a存著b的位址，但兩個記憶體位址還是不一樣</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int &amp;a = b;  //但這個呢？讓我們繼續看下去</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;a = b;</span><br><span class="line"><span class="comment">//結果：a = 4; b = 4; &amp;a = 006FF89C; &amp;b = 006FF89C;</span></span><br><span class="line"><span class="comment">//結論：a的位址跟b一樣，所以a跟b一模一樣了！</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以這些實驗可以得到結論：在宣告的時候 ，<code>int&amp;</code> 會把「等號左邊(<code>a</code>)的變數地址」改變成「等號右邊(<code>b</code>)變數的地址」，因此 <code>a</code> 與 <code>b</code> 兩個是一樣的東西（也就是記憶體位址一樣）！</p>
<p>回到最一開始的問題：<code>(FARPROC&amp;) addr</code> 到底是甚麼呢？我還是用程式做一下實驗，先以書上的程式碼為第一個實驗，用 <code>(FARPROC&amp;)</code> 去接 <code>GetProcAddress</code> 的值，看會如何；再用 <code>addr</code> 直接去接，又會如何。以下是實驗結果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC addr;</span><br><span class="line">(FARPROC&amp;) addr = GetProcAddress(...);</span><br><span class="line"><span class="comment">//結果：addr = 74307E60; &amp;addr = 012FFA94; GetProcAddress(...) = 74307E60;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC addr;</span><br><span class="line">addr = GetProcAddress(...);</span><br><span class="line"><span class="comment">//結果：addr = 74307E60; &amp;addr = 012FFA88; GetProcAddress(...) = 74307E60;</span></span><br></pre></td></tr></table></figure>
<p>可以發現其實沒有像是我們在最原本例子 <code>int &amp;a=b;</code> 看到的把 <code>addr</code> 位址變為 <code>GetProcAddress</code> 的位址，反而是addr的值變化了，變為 <code>GetProcAddress</code> 回傳的地址，也就是說 <code>(FARPROC&amp;)</code> 在這個實驗中看起來是沒有作用到的。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p><code>(FARPROC&amp;) addr = GetProcAddress(...)</code> 等同於 <code>addr = GetProcAddress(...)</code>，只是不知道書上為何多此一舉。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>FARPROC</tag>
        <tag>cpp</tag>
        <tag>加密與解密</tag>
      </tags>
  </entry>
  <entry>
    <title>[C#] 使用 ASP.NET Core 3.1 建立一個初學範例</title>
    <url>/2021/06/15/cs_asp_net_core_3_1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>.Net Core 是一個未來趨勢，主打能夠跨平台運作，不用將自己的應用程式分為多種版本 (Windows, Linux, MacOS 等) 去維護，這對開發來說是一大福音！</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>Visual Studio Enterprise 2019 (16.7.2)</li>
<li>.Net Core 3.1</li>
</ul>
<h2 id="創建專案"><a href="#創建專案" class="headerlink" title="創建專案"></a>創建專案</h2><p>必需使用 Visual Studio 2019 以上版本才可以用 .NET Core 3.1 (<a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">參考資訊</a>)，也因為 2.1 版在 2021/08/21 就會結束支援，所以建議使用較新的 Core (3.1)。</p>
<p>開啟「Visual Studio 2019」→「Create a new project」→ 選「ASP.NET Core Web Application」→ Project name 為「CorePractice」→ 選「Web Application」(請注意上方要為 .NET Core 與 ASP.NET Core 3.1，且右方的 HTTPS 不要勾) →「Create」</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/C-%E4%BD%BF%E7%94%A8-ASP-NET-Core-3-1-%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B%E5%88%9D%E5%AD%B8%E7%AF%84%E4%BE%8B%2Fcreate_project.png?alt=media&amp;token=fc23ffc7-0664-4325-bd3f-9d052cf073d7" alt="創建專案步驟"><span class="image-caption">創建專案步驟</span></p>
<h2 id="編寫程式"><a href="#編寫程式" class="headerlink" title="編寫程式"></a>編寫程式</h2><p>目錄結構如下，目前只會用到 <code>Index.cshtml</code> 與 <code>Index.cshtml.cs</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">│  appsettings.Development.json</span><br><span class="line">│  appsettings.json</span><br><span class="line">│  CorePractice.csproj</span><br><span class="line">│  Program.cs</span><br><span class="line">│  Startup.cs</span><br><span class="line">├─bin</span><br><span class="line">├─obj</span><br><span class="line">├─Pages</span><br><span class="line">│  │  Error.cshtml</span><br><span class="line">│  │  Error.cshtml.cs</span><br><span class="line">│  │  Index.cshtml</span><br><span class="line">│  │  Index.cshtml.cs</span><br><span class="line">│  │  Privacy.cshtml</span><br><span class="line">│  │  Privacy.cshtml.cs</span><br><span class="line">│  │  _ViewImports.cshtml</span><br><span class="line">│  │  _ViewStart.cshtml</span><br><span class="line">│  │</span><br><span class="line">│  └─Shared</span><br><span class="line">├─Properties</span><br><span class="line">└─wwwroot</span><br></pre></td></tr></table></figure>
<p>修改 <code>Index.cshtml.cs</code> 內 <code>OnGet</code> 函式的內容，透過 <code>ViewData</code> 將資料傳給 View</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.RazorPages;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CorePractice.Pages</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IndexModel</span> : <span class="title">PageModel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;IndexModel&gt; _logger;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexModel</span>(<span class="params">ILogger&lt;IndexModel&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnGet</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] names = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Alfreda Stephenson&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Swanson Swanson&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Walker Pace&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Katina Le&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Lesley Calderon&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Ruth Merrill&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Cristina Buchanan&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Gallegos May&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;Macdonald Lucas&quot;</span>&#125;;</span><br><span class="line">            <span class="built_in">int</span> num = <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">int</span>[] age = <span class="keyword">new</span> <span class="built_in">int</span>[num];</span><br><span class="line">            <span class="built_in">string</span>[] name = <span class="keyword">new</span> <span class="built_in">string</span>[num];</span><br><span class="line">            <span class="built_in">int</span>[] family = <span class="keyword">new</span> <span class="built_in">int</span>[num];</span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                age[i] = rnd.Next(<span class="number">50</span>);</span><br><span class="line">                name[i] = names[rnd.Next(names.Length)];</span><br><span class="line">                family[i] = rnd.Next(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ViewData[<span class="string">&quot;age&quot;</span>] = age;</span><br><span class="line">            ViewData[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">            ViewData[<span class="string">&quot;family&quot;</span>] = family;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>Index.cshtml</code> 修改如下，透過 <code>ViewData</code> 將 Controller 的資料取出，在 View 中渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@page</span><br><span class="line">@model IndexModel</span><br><span class="line">@&#123;</span><br><span class="line">    ViewData[&quot;Title&quot;] = &quot;Home page&quot;;</span><br><span class="line"></span><br><span class="line">    int[] age = ViewData[&quot;age&quot;] as int[];</span><br><span class="line">    string[] name = ViewData[&quot;name&quot;] as string[];</span><br><span class="line">    int[] family = ViewData[&quot;family&quot;] as int[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;display-4&quot;</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learn about <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://docs.microsoft.com/aspnet/core&quot;</span>&gt;</span>building Web apps with ASP.NET Core<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">&quot;border-style: solid; margin-left: auto; margin-right: auto;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>歲數<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>家庭人數<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    @for (var i = 0; i &lt; name.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>@name[i]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>@age[i]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>@family[i]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">table</span> <span class="selector-tag">td</span>, <span class="selector-tag">table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>編譯與建置 (F5) 後一個簡單的 ASP.NET Core 應用程式就此完成</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/C-%E4%BD%BF%E7%94%A8-ASP-NET-Core-3-1-%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B%E5%88%9D%E5%AD%B8%E7%AF%84%E4%BE%8B%2Fproject_demo.png?alt=media&amp;token=7e1625c1-5d92-4acd-84b5-8de508a799f0" alt="完成頁面"><span class="image-caption">完成頁面</span></p>
<p>參考原始碼：<a href="https://github.com/weirenxue/core-practice">GitHub</a></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>asp</tag>
        <tag>.net</tag>
        <tag>core</tag>
        <tag>3.1</tag>
        <tag>visual studio</tag>
        <tag>razor</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>[C#] 在 Linux 架設 ASP.NET Core 應用程式</title>
    <url>/2021/10/20/cs_linux_asp_net_core/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ASP.Net Core 是微軟生態系未來的趨勢，主要優勢是可以跨平台開發，使用一組程式碼便能在各平台上運作。這篇文章的情境是：在 Windows 上開發 ASP.Net Core 應用程式，且發布至 CentOS 上運行，並使用 Nginx 作為 Reverse Proxy。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>實體機 (Host) 作業系統：Windows 10</li>
<li>虛擬機 (Guest) 作業系統：CentOS 7.9</li>
<li>虛擬機軟體：VMware Workstation Player 16.2.0</li>
<li>ASP.NET Core 3.1</li>
</ul>
<h2 id="添加-sudoer-權限"><a href="#添加-sudoer-權限" class="headerlink" title="添加 sudoer 權限"></a>添加 sudoer 權限</h2><p>安裝好作業系統後，先將要用來平常作業用的使用者帳號加入 <code>sudoers file</code>，使其可用 <code>sudo</code> 指令。</p>
<div class="note default">
            <p>參考文獻：<a href="/2021/06/17/user_linux_sudo/">[User] Linux 新增使用者並賦予其使用 sudo 的權限</a></p>
          </div>
<h2 id="安裝-ASP-Net-Core-執行環境"><a href="#安裝-ASP-Net-Core-執行環境" class="headerlink" title="安裝 ASP.Net Core 執行環境"></a>安裝 ASP.Net Core 執行環境</h2><p><code>dotnet</code> 套件有兩種套件分別為 SDK 與 Runtime，若要在 CentOS 中 <strong>開發</strong> .NET Core，需要安裝的是 SDK；若只是要 <strong>運行</strong> 編譯好的 .NET Core 應用，則是安裝 Runtime。筆者是在 Windows 中編譯好再拿到 CentOS 上運行，因此只需要安裝 Runtime</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm</span><br><span class="line">[wrxue@localhost ~]$ sudo yum install -y aspnetcore-runtime-3.1 <span class="comment"># 依照自己的目標版本更改，2.1、3.1、5.0 等等</span></span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="https://docs.microsoft.com/en-us/dotnet/core/install/linux-centos#centos-7-">Install the .NET SDK or the .NET Runtime on CentOS</a></p>
          </div>
<h2 id="安裝-Nginx"><a href="#安裝-Nginx" class="headerlink" title="安裝 Nginx"></a>安裝 Nginx</h2><p>安裝 Nginx 並啟用服務</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo yum install -y epel-release</span><br><span class="line">[wrxue@localhost ~]$ sudo yum install -y nginx</span><br><span class="line">[wrxue@localhost ~]$ sudo systemctl start nginx</span><br><span class="line">[wrxue@localhost ~]$ sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="/2021/06/18/nginx_centos_nginx/">[Nginx] CentOS 安裝網頁伺服器 Nginx</a></p>
          </div>
<h2 id="設定防火牆"><a href="#設定防火牆" class="headerlink" title="設定防火牆"></a>設定防火牆</h2><p>將 <code>http</code> 服務與 <code>5000 Port</code> 加入防火牆 (<code>firewalld</code>) 規則，允許外部連入 (Inbound)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo firewall-cmd --permanent --zone=public --add-port=5000/tcp <span class="comment"># ASP.NET Core 應用程式預設的 Port</span></span><br><span class="line">[wrxue@localhost ~]$ sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">[wrxue@localhost ~]$ sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="/2021/06/18/firewall_centos_port/">[Firewall] CentOS 開啟指定的 Port 或服務</a></p>
          </div>
<h2 id="關閉-SELinux"><a href="#關閉-SELinux" class="headerlink" title="關閉 SELinux"></a>關閉 SELinux</h2><p>架設伺服器時先暫時關閉 SELinux 會較容易確認問題所在，待一切設定就緒之後，再開啟 SELinux 並研究如何添加規則即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/1&#x27;</span> /etc/selinux/config</span><br><span class="line">[wrxue@localhost ~]$ sudo reboot   <span class="comment"># 重開機</span></span><br><span class="line"></span><br><span class="line">[wrxue@localhost ~]$ sudo sestatus <span class="comment"># 查看 SELinux 的狀態，需為 disabled</span></span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="https://www.brilliantcode.net/145/centos-7-check-selinux-status-enabled-or-not/">CentOS 7 開啟/關閉SELinux</a></p>
          </div>
<h2 id="Publish-ASP-NET-Core-APP"><a href="#Publish-ASP-NET-Core-APP" class="headerlink" title="Publish ASP.NET Core APP"></a>Publish ASP.NET Core APP</h2><p>在 ASP.NET Core 應用程式的目錄下，執行下方指令，並等待一段時間直到 Publish 成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dotnet publish -c Release</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="/2021/06/15/cs_asp_net_core/">[C#] 發布 ASP.NET Core 應用程式</a></p>
          </div>
<h2 id="移動-Publish-資料夾"><a href="#移動-Publish-資料夾" class="headerlink" title="移動 Publish 資料夾"></a>移動 Publish 資料夾</h2><p>筆者是使用 VMware 上的 CentOS，因此需要先掛載共用資料夾，才能將 Windows 的檔案傳到 Server 上，讀者可以依實際情況來判定是否可以忽略這一步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ <span class="built_in">mkdir</span> shares</span><br><span class="line">[wrxue@localhost ~]$ sudo /usr/bin/vmhgfs-fuse .host:/Shared ~/shares -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="/2021/06/19/share_vmware_centos/">[Share] VMware 裡的 CentOS 使用共享資料夾</a></p>
          </div>
<p>再將 Publish 出來的資料夾 <strong>整個</strong> 搬到 <code>/var/www/</code> 目錄下，並使用 <code>dotnet</code> 指令啟動 ASP.NET Core 應用程式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo <span class="built_in">mkdir</span> -p /var/www/appName</span><br><span class="line">[wrxue@localhost ~]$ sudo <span class="built_in">cp</span> -R ./shares/publish/* /var/www/appName/</span><br><span class="line">[wrxue@localhost ~]$ <span class="built_in">cd</span> /var/www/appName/</span><br><span class="line">[wrxue@localhost appName]$ dotnet appName.dll</span><br></pre></td></tr></table></figure>
<ul>
<li><code>appName</code>：為應用程式名稱，請依實際情況做變更。</li>
</ul>
<div class="note success">
            <p>到目前為止，已經可以在伺服器 <strong>本身</strong> 的瀏覽器瀏覽 <a href="http://localhost:5000">http://localhost:5000</a> 囉。</p>
          </div>
<h2 id="設定-Nginx-為反向代理"><a href="#設定-Nginx-為反向代理" class="headerlink" title="設定 Nginx 為反向代理"></a>設定 Nginx 為反向代理</h2><p>讓原本的終端機 (Terminal) 繼續運行 ASP.NET Core 的應用程式，<strong>另外開啟</strong> 一個 Terminal 來操作以下動作，新增檔案 <code>/etc/nginx/conf.d/appName.conf</code> 且內容如下，完成後重啟 Nginx</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen        80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass         http://127.0.0.1:5000;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header   Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header   Connection keep-alive;</span><br><span class="line">        proxy_set_header   Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_cache_bypass <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header   X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header   X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：<a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-3.1#configure-nginx">Host ASP.NET Core on Linux with Nginx</a></p>
          </div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@localhost ~]$ sudo systemctl restart nginx <span class="comment"># 重啟 nginx</span></span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>到目前為止，已經可以在 <strong>外部主機</strong> 的瀏覽器透過 <code>http://{server_ip}</code> 瀏覽 ASP.NET Core 應用程式囉。</p>
          </div>
<h2 id="允許外部直接連線-5000-Port"><a href="#允許外部直接連線-5000-Port" class="headerlink" title="允許外部直接連線 5000 Port"></a>允許外部直接連線 5000 Port</h2><p>目前外部主機無法直接以 5000 Port 與 ASP.NET Core 應用程式連線，參考 <a href="/2021/06/15/cs_asp_net_core/#測試">[C#] 發布 ASP.NET Core 應用程式</a>，可以看到 <code>kestrel</code> 只監聽 <code>http://localhost:5000</code>，所以只能接受 <code>localhost</code> 來的 <code>request</code>，而反向代理可以做到這件事則是因為透過 <code>proxy_pass http://127.0.0.1:5000;</code> 組態指令，將外來的 <code>request</code> 轉傳遞給本地端 (即 <code>localhost</code>) 5000 Port 的網頁應用程式，因此對 ASP.NET Core 應用程式來說，連線流量是來自於 <code>localhost</code> 而不是外部。</p>
<p>若想要讓本機以外的都能直接透過 5000 Port 與應用程式連線，就需要修改 <code>Program.cs</code> 的程式碼如下</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">    Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            webBuilder.UseUrls(<span class="string">&quot;http://*:5000&quot;</span>).UseStartup&lt;Startup&gt;(); <span class="comment">// 使用 UseUrls</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>參考文獻：</p><ol><li><a href="https://github.com/weirenxue/core-practice/commit/8c4561c16c1117f38810ee5c382adea2b93d2d0a">GitHub：改為不只有本機 (localhost) 可以連線</a></li><li><a href="https://weblog.west-wind.com/posts/2016/sep/28/external-network-access-to-kestrel-and-iis-express-in-aspnet-core">External Network Access to Kestrel and IIS Express in ASP.NET Core</a></li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-3.1#server-urls">ASP.NET Core Web Host#Server URLs</a></li></ol>
          </div>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>asp</tag>
        <tag>.net</tag>
        <tag>core</tag>
        <tag>cs</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>[C#] 在高 DPI 的螢幕上，有些應用程式內的字會模糊的原因以及解決方法！</title>
    <url>/2021/06/11/cs_dpi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>開啟 Visual Studio <code>C#</code> 的 Windows Form 應用程式來設計，一定曾經注意到雖然在 VS 裡面設計 Form 時，預覽的字是清晰的，結果 Compiler 之後跑出來的字是模糊的！以下圖幫各位回憶一下。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E5%9C%A8%E9%AB%98DPI%E7%9A%84%E8%9E%A2%E5%B9%95%E4%B8%8A%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E5%85%A7%E7%9A%84%E5%AD%97%E6%9C%83%E6%A8%A1%E7%B3%8A%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fblur_text_in_cs.png?alt=media&amp;token=08356925-327f-4387-a8ed-5f9815aeab62" alt="在 C# 視窗程式中模糊的字"><span class="image-caption">在 C# 視窗程式中模糊的字</span></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>這最主要原因是 DPI 太高的關係，但你可能會想說 DPI 高的話解析度就高呀，為什麼會 DPI 越高越模糊！先來聊聊一些單位的定義。</p>
<h3 id="單位定義"><a href="#單位定義" class="headerlink" title="單位定義"></a>單位定義</h3><ul>
<li><code>DPI</code>：是 dots per inch 的縮寫，即每英吋內的點數量，也叫做螢幕密度，通常一個點 dot 就是一個像素 pixel，所以越大 DPI 的螢幕，可以使用更多像素來顯示一張圖，因此能顯示的更精緻。</li>
<li><code>pt</code>：文字大小的單位是 pt(point)，定義為 72 pt 為一英吋(<em>inch</em>)，但這是對於全型字來說，例如漢字(下圖)；如果是英文半型字，就要看各自的寬度了。<script type="math/tex; mode=display">72\ pt=1\ inch</script>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E5%9C%A8%E9%AB%98DPI%E7%9A%84%E8%9E%A2%E5%B9%95%E4%B8%8A%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E5%85%A7%E7%9A%84%E5%AD%97%E6%9C%83%E6%A8%A1%E7%B3%8A%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fpt_unit.png?alt=media&amp;token=c0f0fcf9-b8dd-45d1-a3d2-4ebf44ca0aac" alt="pt 與英吋的關係"><span class="image-caption">pt 與英吋的關係</span></li>
</ul>
<h3 id="原因說明"><a href="#原因說明" class="headerlink" title="原因說明"></a>原因說明</h3><p>現在就來回答問題吧！為什麼在高 DPI 的螢幕會顯示出這麼模糊的文字呢？魔鬼就藏在單位轉換裡面。</p>
<p>程式有分為 <strong>DPI 感知</strong>與<strong>非 DPI 感知</strong>的應用程式，端看當初程式中是否有加入此功能，在早期的作業系統下螢幕還沒這麼高級，大多為 96 DPI，導致許多程式就沒考慮到現在的高 DPI 螢幕例如現在的 120、144、192 等，因此大部分舊應用程式都為非感知 DPI 的類型。</p>
<p>到後來 Microsoft 發展出 <strong>DPI Virtualization</strong>，此技術運作模式大概是這樣的，當應用程式沒有先聲明它能支援多少 DPI 時，Windows 會先將它放進沙盒裡，在這裡面沙盒內是先將應用程式渲染成 96 DPI 解析度下的畫面，然後看實際上的解析度多少再進行<strong>縮放</strong>，也因為如此，非感知 DPI 的應用程式在高 DPI 的螢幕下會出現模糊的情況。</p>
<p>現在先來進行單位換算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Environment</th>
<th>Convert</th>
</tr>
</thead>
<tbody>
<tr>
<td>96  DPI</td>
<td>1.33 dots = 1 pt</td>
</tr>
<tr>
<td>120 DPI</td>
<td>1.67 dots = 1 pt</td>
</tr>
<tr>
<td>144 DPI</td>
<td>2 dots = 1 pt</td>
</tr>
<tr>
<td>192 DPI</td>
<td>2.67 dots = 1 pt</td>
</tr>
</tbody>
</table>
</div>
<p>從上面表格來解讀，假設現在要顯示一個字，其大小為 1 pt，在各種解析度的螢幕上需要使用來顯示點數，例如 96 DPI 需要用 1.33 dots，其兩倍解析度的 192 DPI 就需要其兩倍的點數 2.67 dots 來表示。</p>
<p>可以看得出來吧？當一張圖的解析度為 96 DPI，你需要放大兩倍才能在 192 DPI 的螢幕上顯示出一樣大小的畫面，但是圖片本身解析度是不會變高的！所以如果將其放大(點陣圖放大)的話必定會模糊。用講的很難想像，讓我用圖來說明。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E5%9C%A8%E9%AB%98DPI%E7%9A%84%E8%9E%A2%E5%B9%95%E4%B8%8A%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E5%85%A7%E7%9A%84%E5%AD%97%E6%9C%83%E6%A8%A1%E7%B3%8A%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fhigh_dpi_screen_blur_reson.png?alt=media&amp;token=aaa313cc-1a96-4923-bfc9-0573af79ef5d" alt="高解析度螢幕顯示文字會模糊的原因示意圖"><span class="image-caption">高解析度螢幕顯示文字會模糊的原因示意圖</span></p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>到這裡已經知道為何高 DPI 的螢幕會影響到字體的顯示了，接下來就要說說如何讓 <code>C#</code> 設計出來的視窗字體不會模糊，先上程式碼再解釋</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">[<span class="meta">STAThread</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Environment.OSVersion.Version.Major &gt;= <span class="number">6</span>)</span><br><span class="line">        SetProcessDPIAware();</span><br><span class="line">    Application.EnableVisualStyles();</span><br><span class="line">    Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">    Application.Run(<span class="keyword">new</span> Form1());</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">System.Runtime.InteropServices.DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">SetProcessDPIAware</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>原理很簡單，在 <code>Main()</code> 的附近加上 4、5、10、11 行，使程式為 DPI 感知即大功告成，結果如下</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E5%9C%A8%E9%AB%98DPI%E7%9A%84%E8%9E%A2%E5%B9%95%E4%B8%8A%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E5%85%A7%E7%9A%84%E5%AD%97%E6%9C%83%E6%A8%A1%E7%B3%8A%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fplain_text_in_cs.png?alt=media&amp;token=7467c99e-411a-426d-abb2-d0d67cc15af8" alt="DPI 感知程式顯示出清晰文字"><span class="image-caption">DPI 感知程式顯示出清晰文字</span></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><p><a href="https://www.telerik.com/blogs/winforms-scaling-at-large-dpi-settings-is-it-even-possible-">WinForms Scaling at Large DPI Settings–Is It Even Possible?</a></p>
</li>
<li><p><a href="https://kknews.cc/zh-tw/digital/x56n4g.html">Windows微信DPI適配</a></p>
</li>
<li><p><a href="http://crsouza.com/2015/04/13/how-to-fix-blurry-windows-forms-windows-in-high-dpi-settings/">How to fix blurry Windows Forms Windows in high-dpi settings</a></p>
</li>
<li><p><a href="https://docs.microsoft.com/zh-tw/windows/win32/api/winnt/ns-winnt-osversioninfoa">OSVERSIONINFOA structure</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>dpi</tag>
        <tag>pt</tag>
        <tag>blurry</tag>
        <tag>windows forms</tag>
      </tags>
  </entry>
  <entry>
    <title>[C#] 發布 ASP.NET Core 應用程式</title>
    <url>/2021/06/15/cs_asp_net_core/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接續 <a href="https://weirenxue.github.io/2021/06/15/cs_asp_net_core_3_1/">[C#] 使用 ASP.NET Core 3.1 建立一個初學範例</a> 已經創建好一個 ASP.NET Core 的專案，這篇要來教如何發布 (Publish)，Publish 才能將其部屬到其他平台上運作。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>Visual Studio Enterprise 2019 (16.7.2)</li>
<li>.Net Core 3.1</li>
</ul>
<h2 id="發布"><a href="#發布" class="headerlink" title="發布"></a>發布</h2><p>開啟 cmd 進到專案的目錄裡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;<span class="built_in">cd</span> C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice</span><br></pre></td></tr></table></figure>
<p>使用 <a href="https://docs.microsoft.com/zh-tw/dotnet/core/tools/dotnet-build">Release 組建組態</a>，並以指令執行 publish，訊息中的最後一行為該專案 Publish 的位置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice&gt;dotnet publish -c Release</span><br><span class="line">Microsoft (R) Build Engine version 16.7.0+b89cb5fde <span class="keyword">for</span> .NET</span><br><span class="line">Copyright (C) Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  All projects are up-to-date <span class="keyword">for</span> restore.</span><br><span class="line">  CorePractice -&gt; C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice\CorePractice\bin\Release\netcoreapp3.1\CorePractice.dll</span><br><span class="line">  CorePractice -&gt; C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice\CorePractice\bin\Release\netcoreapp3.1\CorePractice.Views.dll</span><br><span class="line">  CorePractice -&gt; C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice\CorePractice\bin\Release\netcoreapp3.1\publish\</span><br></pre></td></tr></table></figure>
<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>啟動 Publish 位置內的應用程式，此時應用程式在 <code>http://localhost:5000</code> 運行監聽囉，開啟瀏灠器輸入網址即可連線到網頁應用程式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice\CorePractice\bin\Release\netcoreapp3.1\publish&gt;dotnet CorePractice.dll <span class="comment"># 這裡是 dll，不是 exe</span></span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Now listening on: http://localhost:5000</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Now listening on: https://localhost:5001</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Application started. Press Ctrl+C to shut down.</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Hosting environment: Production</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]</span><br><span class="line">      Content root path: C:\Users\wrxue\<span class="built_in">source</span>\repos\CorePractice\CorePractice\bin\Release\netcoreapp3.1\publish</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>csharp</tag>
        <tag>asp</tag>
        <tag>.net</tag>
        <tag>core</tag>
        <tag>3.1</tag>
        <tag>visual studio</tag>
        <tag>2019</tag>
        <tag>publish</tag>
      </tags>
  </entry>
  <entry>
    <title>[CharSet] CentOS 修改 MariaDB／MySQL 預設字符集</title>
    <url>/2021/06/19/charset_centos_mariadb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 是瑞典人開發的，所以預設字符集是 latin1，與其每次要創建資料庫都要指定字符集，不如直接更改預設的字符集。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
<li>MariaDB 10.3.17</li>
</ul>
<h2 id="確認預設字符集"><a href="#確認預設字符集" class="headerlink" title="確認預設字符集"></a>確認預設字符集</h2><p>登入 MariaDB</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mysql -u user -p</span><br></pre></td></tr></table></figure>
<p>查看預設字符集，<code>Server characterset</code>、<code>Db characterset</code>、<code>Client characterset</code> 與 <code>Conn. characterset</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; \s</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 15.1 Distrib 10.3.17-MariaDB, <span class="keyword">for</span> Linux (x86_64) using readline 5.1</span><br><span class="line"></span><br><span class="line">Connection <span class="built_in">id</span>:          8</span><br><span class="line">Current database:</span><br><span class="line">Current user:           user@localhost</span><br><span class="line">SSL:                    Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:          stdout</span><br><span class="line">Using outfile:          <span class="string">&#x27;&#x27;</span></span><br><span class="line">Using delimiter:        ;</span><br><span class="line">Server:                 MariaDB</span><br><span class="line">Server version:         10.3.17-MariaDB MariaDB Server</span><br><span class="line">Protocol version:       10</span><br><span class="line">Connection:             Localhost via UNIX socket</span><br><span class="line">Server characterset:    latin1</span><br><span class="line">Db     characterset:    latin1</span><br><span class="line">Client characterset:    utf8</span><br><span class="line">Conn.  characterset:    utf8</span><br><span class="line">UNIX socket:            /var/lib/mysql/mysql.sock</span><br><span class="line">Uptime:                 8 sec</span><br></pre></td></tr></table></figure>
<h2 id="更改-cnf-設定"><a href="#更改-cnf-設定" class="headerlink" title="更改 cnf 設定"></a>更改 cnf 設定</h2><p>為了不影響到原先就在的 cnf 檔，在 <code>/etc/my.cnf.d/</code> 目錄下新增一個 cnf 檔 (檔名任意)，內容如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4        <span class="comment">## 修改 Client characterset 與 Conn. characterset</span></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8mb4         <span class="comment">## 修改 Server characterset 與 Db characterset</span></span><br><span class="line">collation-server=utf8mb4_unicode_ci  <span class="comment">## 會修改預設的校驗比對方法</span></span><br></pre></td></tr></table></figure>
<h2 id="載入設定"><a href="#載入設定" class="headerlink" title="載入設定"></a>載入設定</h2><p>重啟 MariaDB，確認字符集已更改為所設定的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl restart mariadb</span><br><span class="line">[user@localhost ~]$ mysql -u user -p</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">MariaDB [(none)]&gt; \s</span><br><span class="line">--------------</span><br><span class="line">mysql  Ver 15.1 Distrib 10.3.17-MariaDB, <span class="keyword">for</span> Linux (x86_64) using readline 5.1</span><br><span class="line"></span><br><span class="line">Connection <span class="built_in">id</span>:          9</span><br><span class="line">Current database:</span><br><span class="line">Current user:           user@localhost</span><br><span class="line">SSL:                    Not <span class="keyword">in</span> use</span><br><span class="line">Current pager:          stdout</span><br><span class="line">Using outfile:          <span class="string">&#x27;&#x27;</span></span><br><span class="line">Using delimiter:        ;</span><br><span class="line">Server:                 MariaDB</span><br><span class="line">Server version:         10.3.17-MariaDB MariaDB Server</span><br><span class="line">Protocol version:       10</span><br><span class="line">Connection:             Localhost via UNIX socket</span><br><span class="line">Server characterset:    utf8mb4</span><br><span class="line">Db     characterset:    utf8mb4</span><br><span class="line">Client characterset:    utf8mb4</span><br><span class="line">Conn.  characterset:    utf8mb4</span><br><span class="line">UNIX socket:            /var/lib/mysql/mysql.sock</span><br><span class="line">Uptime:                 3 min 39 sec</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>characterset</tag>
        <tag>client</tag>
        <tag>mariadb</tag>
        <tag>mysql</tag>
        <tag>8.2</tag>
        <tag>default</tag>
        <tag>collation</tag>
        <tag>utf8</tag>
        <tag>utf8mb4</tag>
      </tags>
  </entry>
  <entry>
    <title>[DLL] 使用 VS 2017 寫包含 DllMain 的 dll</title>
    <url>/2021/06/15/dll_vs_2017_dllmain_dll/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章紀錄如何在 VS 2017 寫一個 dll，其包含 <code>DllMain</code> 與一個 <code>dllexport</code> 函數。若要知道如何在其它的 C++ 專案中調用在 dll 中的函數，請參考 <a href="/2021/06/15/dll_cpp_dll/">[DLL] 在 C++ 中調用 dll 的函式</a>。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>Visual Studio 2017</li>
</ul>
<h2 id="創建專案"><a href="#創建專案" class="headerlink" title="創建專案"></a>創建專案</h2><h3 id="確認環境"><a href="#確認環境" class="headerlink" title="確認環境"></a>確認環境</h3><p>開啟 <code>Visual Studio Installer</code>，確認 <code>Desktop development with C++</code> 已安裝，才可進行下面的步驟</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E4%BD%BF%E7%94%A8-VS-2017-%E5%AF%AB%E5%8C%85%E5%90%AB-DllMain-%E7%9A%84-dll%2Fdesktop_development_with_cpp.png?alt=media&amp;token=086089aa-89c2-406b-9b88-64bd9f4023bc" alt="確認環境"><span class="image-caption">確認環境</span></p>
<h3 id="新增專案"><a href="#新增專案" class="headerlink" title="新增專案"></a>新增專案</h3><p>開啟 VS 2017，新開一個專案 <code>File → New → Project</code> 或組合鍵 <code>Ctrl + Shift + N</code>，點擊 <code>Visual C++</code> 之下的 <code>Windows Desktop</code>，選擇 <code>Windows Desktop Wizard</code>，在 <code>Name</code> 輸入好專案名稱後，按 <code>OK</code> 進到下個步驟</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E4%BD%BF%E7%94%A8-VS-2017-%E5%AF%AB%E5%8C%85%E5%90%AB-DllMain-%E7%9A%84-dll%2Fnew_project.png?alt=media&amp;token=7c6566f7-e51f-4c83-9e38-ee14a3ff1840" alt="新建專案"><span class="image-caption">新建專案</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E4%BD%BF%E7%94%A8-VS-2017-%E5%AF%AB%E5%8C%85%E5%90%AB-DllMain-%E7%9A%84-dll%2Fchoose_project_type.png?alt=media&amp;token=48ce3ba4-4228-45a4-b9de-188e160dd485" alt="選擇專案類型"><span class="image-caption">選擇專案類型</span></p>
<p>Application type 選 <code>Dynamic Link Library(.dll)</code>，Addtional options 都不用勾！按下 <code>OK</code> 就會建立好一個專案，預設會自動開啟專案中的 <code>dllmain.cpp</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E4%BD%BF%E7%94%A8-VS-2017-%E5%AF%AB%E5%8C%85%E5%90%AB-DllMain-%E7%9A%84-dll%2Fchoose_dll.png?alt=media&amp;token=be30c3e7-94b4-4cc9-a1bd-5457d068658a" alt="選擇 dll"><span class="image-caption">選擇 dll</span></p>
<h2 id="編寫程式"><a href="#編寫程式" class="headerlink" title="編寫程式"></a>編寫程式</h2><p>將下面的程式碼貼到 <code>dllmain.cpp</code> 中，(參考原始碼：<a href="https://github.com/weirenxue/dll-dllmain-and-function">GitHub</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : Defines the entry point for the DLL application.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLLMAIN_API __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">DLLMAIN_API <span class="type">void</span> <span class="title">helloWorldFun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxW</span>(<span class="number">0</span>, <span class="string">L&quot;此函式呼叫成功&quot;</span>, <span class="string">L&quot;helloWorldFun&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;程序建立時被呼叫&quot;</span>, <span class="string">L&quot;DllMain&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;執行緒建立時被呼叫&quot;</span>, <span class="string">L&quot;DllMain&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;執行緒退出時被呼叫&quot;</span>, <span class="string">L&quot;DllMain&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="number">0</span>, <span class="string">L&quot;程序退出時被呼叫&quot;</span>, <span class="string">L&quot;DllMain&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>點擊功能選單 <code>Build → Build Solution</code>，可在 Output 視窗看到下方提示，會在專案下的 Debug 目錄產出 dll 檔案，檔名與專案名稱相同</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E4%BD%BF%E7%94%A8-VS-2017-%E5%AF%AB%E5%8C%85%E5%90%AB-DllMain-%E7%9A%84-dll%2Fbuild_solution.png?alt=media&amp;token=55a6777b-cd77-45d8-a01d-7e168eb4f5e8" alt="Build Solution"><span class="image-caption">Build Solution</span></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">1&gt;</span><span class="language-bash">------ Build started: Project: Project1, Configuration: Debug Win32 ------</span></span><br><span class="line"><span class="meta prompt_">1&gt;</span><span class="language-bash">dllmain.cpp</span></span><br><span class="line"><span class="meta prompt_">1&gt; </span><span class="language-bash">  Creating library C:\Users\wrxue\<span class="built_in">source</span>\repos\Project1\Debug\Project1.lib and object C:\Users\wrxue\<span class="built_in">source</span>\repos\Project1\Debug\Project1.exp</span></span><br><span class="line"><span class="meta prompt_">1&gt;</span><span class="language-bash">Project1.vcxproj -&gt;  C:\Users\wrxue\<span class="built_in">source</span>\repos\Project1\Debug\Project1.dll</span> </span><br><span class="line">========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========</span><br></pre></td></tr></table></figure>
<p>此時的 <code>Project1.dll</code> 就是包含 <code>DllMain</code> 與一個匯出函式 <code>helloWorldFun</code> 的 dll 檔案囉！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>visual studio</tag>
        <tag>dll</tag>
        <tag>2017</tag>
        <tag>dllmain</tag>
      </tags>
  </entry>
  <entry>
    <title>[DLL] 在 C++ 中調用 dll 的函式</title>
    <url>/2021/06/15/dll_cpp_dll/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此篇文章紀錄如何在 <code>C++</code> 中，使用 <code>LoadLibraryA</code>/<code>LoadLibraryW</code> 調用 dll。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>Visual Studio 2017</li>
</ul>
<h2 id="準備一個-DLL"><a href="#準備一個-DLL" class="headerlink" title="準備一個 DLL"></a>準備一個 DLL</h2><p>先自己寫一個 dll，詳細步驟說明請參考：<a href="/2021/06/15/dll_vs_2017_dllmain_dll/">[DLL] 使用 VS 2017 寫包含 DllMain 的 dll</a>。</p>
<h2 id="創建專案"><a href="#創建專案" class="headerlink" title="創建專案"></a>創建專案</h2><p>開啟 VS 2017，新開一個專案 <code>File → New → Project</code> 或組合鍵 <code>Ctrl + Shift + N</code>，點擊 <code>Visual C++</code> 之下的 <code>Windows Desktop</code>，選擇 <code>Windows Desktop Wizard</code>，在 <code>Name</code> 輸入好專案名稱後，按 <code>OK</code> 進到下個步驟</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E5%9C%A8-C-%E4%B8%AD%E8%AA%BF%E7%94%A8-dll-%E7%9A%84%E5%87%BD%E5%BC%8F%2Fcreate_project.png?alt=media&amp;token=fbe282e9-5cb1-4090-a01e-817bc244411e" alt="新建專案"><span class="image-caption">新建專案</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E5%9C%A8-C-%E4%B8%AD%E8%AA%BF%E7%94%A8-dll-%E7%9A%84%E5%87%BD%E5%BC%8F%2Fchoose_project_type.png?alt=media&amp;token=c4a871cc-40d8-49d3-ac26-2857fb355c1d" alt="選擇專案類型"><span class="image-caption">選擇專案類型</span></p>
<p>Application type 選 <code>Console Application(.exe)</code>，Addtional options 都不用勾！按下 <code>OK</code> 就會建立好一個專案，預設會自動開啟專案中的 <code>&#123;project_name&#125;.cpp</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/DLL-%E5%9C%A8-C-%E4%B8%AD%E8%AA%BF%E7%94%A8-dll-%E7%9A%84%E5%87%BD%E5%BC%8F%2Fchoose_exe.png?alt=media&amp;token=a3933b05-a276-4d7a-a0a0-7129bb6912a5" alt="選擇 dll"><span class="image-caption">選擇 dll</span></p>
<h2 id="編寫程式"><a href="#編寫程式" class="headerlink" title="編寫程式"></a>編寫程式</h2><p>將下面的程式碼貼到 <code>&#123;project_name&#125;.cpp</code> 中，(參考原始碼：<a href="https://github.com/weirenxue/dll-load-in-cpp">GitHub</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*voidFun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;dllMainAndFun.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    voidFun pHelloWorldFun = (<span class="built_in">void</span>(*)())<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;helloWorldFun&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pHelloWorldFun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將要匯入的 dll 放到 Debug 目錄下，否則 <code>LoadLibraryA</code> 需要給 dll 的絕對路徑，因為 Debug 模式編譯出來的執行檔都存在此處。</p>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>按下 F5，開始 Debug 模式，看到彈出視窗 (<code>MessageBoxA</code>/<code>MessageBoxW</code>)，就代表載入成功了！顯示順序應為</p>
<ol>
<li>程序建立時被呼叫</li>
<li>此函式呼叫成功</li>
<li>程序退出時被呼叫</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>dll</tag>
        <tag>invoke</tag>
        <tag>loadlibrarya</tag>
        <tag>loadlibraryw</tag>
      </tags>
  </entry>
  <entry>
    <title>[EFI] 顯示 Windows 的 EFI 系統分割磁碟</title>
    <url>/2021/06/16/efi_windows_efi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>與開機有關的文件通常會存放於 EFI 系統分割磁碟，且為了不讓一般使用者誤觸造成設定錯誤進而導致系統崩潰，通常會將磁碟隱藏起來，只讓真的有需要設定且知道如何進入的使用者自行更改設定。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
</ul>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>這裡有兩種方法能夠採用</p>
<h3 id="diskpart"><a href="#diskpart" class="headerlink" title="diskpart"></a>diskpart</h3><p>以系統管理員身分開啟 cmd (打開命令提示字元)，並在命令提示字元視窗內輸入下方指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;diskpart</span><br></pre></td></tr></table></figure>
<p>執行後會跳出驗證視窗，按下「是」之後會跳出一個與 cmd 視窗很像的視窗，但其實是 diskpart.exe，接下來的動作都在此視窗中執行。</p>
<p>先列出磁碟清單，利用大小的資訊判斷想要的 EFI 系統磁碟分割區在哪個磁碟裡面，在這情況下我的 C 槽所在磁碟的大小為 238 GB，因此 EFI 系統磁碟分割區在磁碟 1，再用 <code>select</code> 指令選擇該磁碟</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISKPART&gt;list disk</span><br><span class="line"></span><br><span class="line">  磁碟 <span class="comment">###  狀態           大小     可用     Dyn  Gpt</span></span><br><span class="line">  --------  -------------  -------  -------  ---  ---</span><br><span class="line">  磁碟 0    連線              931 GB      0 B        *</span><br><span class="line">  磁碟 1    連線              238 GB      0 B        *</span><br><span class="line"></span><br><span class="line">DISKPART&gt;select disk 1</span><br><span class="line"></span><br><span class="line">磁碟 1 是所選擇的磁碟。</span><br></pre></td></tr></table></figure>
<p>顯示磁碟分割清單，選擇系統磁碟分割區 (類型為系統的那個磁碟分割區)，同樣是使用 <code>select</code> 選擇該磁碟分割區</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISKPART&gt;list partition</span><br><span class="line"></span><br><span class="line">  磁碟分割  <span class="comment">###  類型              大小     位移</span></span><br><span class="line">  -------------  ----------------  -------  -------</span><br><span class="line">  磁碟分割  1    系統                 260 MB  1024 KB</span><br><span class="line">  磁碟分割  2    保留                  16 MB   261 MB</span><br><span class="line">  磁碟分割  3    主要                 237 GB   277 MB</span><br><span class="line">  磁碟分割  4    復原                 850 MB   237 GB</span><br><span class="line"></span><br><span class="line">DISKPART&gt;select partition 1</span><br><span class="line"></span><br><span class="line">磁碟分割 1 是所選擇的磁碟分割。</span><br></pre></td></tr></table></figure>
<p>使用 <code>assign</code> 暫時地命名分割區(這裡把它命名為 <code>p</code> 槽)，至此已經把系統磁碟叫出來了，在檔案總管 (File Explorer) 或透過 cmd (以系統管理員身分執行) 都能存取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISKPART&gt;assign letter=p</span><br><span class="line"></span><br><span class="line">DiskPart 成功地指派了磁碟機代號或掛接點。</span><br></pre></td></tr></table></figure>
<p>會說它是暫時命名的是因為關機時，系統會自動註銷這個名稱，若重新啟動後還有使用需求，需要再操做一遍它才會再次出現，若要手動註銷的話則用 <code>remove</code> 指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISKPART&gt;remove letter=p</span><br><span class="line"></span><br><span class="line">DiskPart 成功地移除了磁碟機代號或掛接點。</span><br></pre></td></tr></table></figure>
<h3 id="mountvol"><a href="#mountvol" class="headerlink" title="mountvol"></a>mountvol</h3><p>以系統管理員身分開啟 cmd (打開命令提示字元)，並在命令提示字元視窗內輸入下方指令，將 EFI 系統分割區暫時命名為 <code>p</code> 槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;mountvol p: /s</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/s</code>：Mount the EFI System Partition on the given drive.</li>
</ul>
<p>以這個方式指派的磁碟分割區只能在 cmd 存取 (<code>p:\</code>)，檔案總管 (File Explorer) 是看不到的。與 diskpart 相同，關機時會註銷名稱，若要手動註銷 <code>p</code> 槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;mountvol p: /d</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/d</code>：Removes the volume mount point from the specified directory.</li>
</ul>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>efi</tag>
        <tag>windows</tag>
        <tag>diskpart</tag>
        <tag>mountvol</tag>
        <tag>partition</tag>
        <tag>disk</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>[Echo] 在 Ubuntu 產生包含 \r 換行字元的檔案</title>
    <url>/2021/06/17/echo_ubuntu_r/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 與 Linux 使用上有一個很顯著的差異，就是兩種系統的換行字元不一樣，在 Windows 上的換行字元為 CRLF <code>\r\n</code>，而 Linux 的換行字元只有 LF <code>\n</code>。然而總會有在 Ubuntu 需要產生一個換行為 CRLF 的檔案的需求，因此紀錄一下如何使用簡單的指令 <code>echo</code> 來解決這個問題。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 20.04</li>
</ul>
<h2 id="檔案內容敘述"><a href="#檔案內容敘述" class="headerlink" title="檔案內容敘述"></a>檔案內容敘述</h2><p>假設現在我想製作一個 HTTP 標頭檔，因 HTTP 標頭格式的換行必須為 CRLF，若直接開啟文件並使用文字編輯器來編輯，換行一定只有 LF，因此需藉由指令的力量來完成這件事，希望的檔案內容如下，注意最後一行空白是必要的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HEAD / HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看文字不清楚，轉為 16 進位形式來看清楚，每個換行皆為 CLRF，最後有一個單獨的 CLRF，才會讓檔案內容看起來有一個空白行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000: 4845 4144 202f 2048 5454 502f 312e 310d  HEAD / HTTP/1.1.</span><br><span class="line">00000010: 0a48 6f73 743a 206c 6f63 616c 686f 7374  .Host: localhost</span><br><span class="line">00000020: 0d0a 0d0a                                ....</span><br></pre></td></tr></table></figure>
<h2 id="產製檔案"><a href="#產製檔案" class="headerlink" title="產製檔案"></a>產製檔案</h2><p>使用基本指令 <code>echo</code> 就能解決我們的困擾囉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;HEAD / HTTP/1.1\r\nHost: localhost\r\n\r\n&quot;</span> &gt; message</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-n</code>：不要輸出最後的換行 (<code>echo</code> 指令自己預設最後會輸出換行 LF)。</li>
<li><code>-e</code>：會直譯跳脫字元，讓我們可以輸入 <code>\r</code>、<code>\n</code> 等跳脫字元。</li>
</ul>
<p>查看該檔案 16 進位形式確認完成！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ xxd message</span><br><span class="line">00000000: 4845 4144 202f 2048 5454 502f 312e 310d  HEAD / HTTP/1.1.</span><br><span class="line">00000010: 0a48 6f73 743a 206c 6f63 616c 686f 7374  .Host: localhost</span><br><span class="line">00000020: 0d0a 0d0a                                ....</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>20.04</tag>
        <tag>netcat</tag>
        <tag>linux</tag>
        <tag>CR</tag>
        <tag>carriage</tag>
        <tag>return</tag>
        <tag>echo</tag>
        <tag>file</tag>
        <tag>cat</tag>
      </tags>
  </entry>
  <entry>
    <title>[Git] git remote add origin 中 origin 的意思解析</title>
    <url>/2021/06/13/git_git_remote_add_origin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Git</code> 真的是對程式開發者的一個大福音，在知道 <code>Git</code> 之前常常在實驗室用桌電開發，回宿舍前上傳雲端或隨身碟，然後回到宿再抓下來繼續開發，久了之後檔案多了，非常難管理，也很難找到之前到底修改了哪裡。使用 <code>Git</code> 之後，光是管理程式碼的部份就省很多時間。</p>
<p>其中一個很常下的指令是 <code>git remote add origin</code>，它很基本以至於很少有文章介紹它的意思，因此在自己的好奇心之下，驅使自己理解這個指令的含意。</p>
<h2 id="origin-意思解析"><a href="#origin-意思解析" class="headerlink" title="origin 意思解析"></a>origin 意思解析</h2><p>當想要從 Local 端 <code>push</code> 資料上 <code>Git</code> 管理網 (例如 GitHub、GitLab ，統稱為 <code>remote</code> 端) 時，會先在網頁上先建一個 Repository，然後跟著網頁的指示做。以下以個人的 <a href="https://github.com/weirenxue">GitHub</a> 為例，創建一個 Repository 名稱為 zcu111-EMIO，且「不」打勾 &quot;Initialize this repository with a README&quot;，創建好之後 GitHub 會提示以下訊息讓我們能順利上傳程式碼</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">…or push an existing repository from the command line</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/weirenxue/zcu111-EMIO.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>依照它的提示執行這些指令後，就能把在地端的程式碼 <code>push</code> 上去，這時再用 <code>git remote -v</code> 來看看 <code>remote</code> 資料</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ git remote -v</span><br><span class="line">origin https://github.com/weirenxue/zcu111-EMIO.git (fetch)</span><br><span class="line">origin https://github.com/weirenxue/zcu111-EMIO.git (push)</span><br></pre></td></tr></table></figure>
<p>可以發現 <code>origin</code> 就只是那 <code>remote git</code> 的代名詞！為了讓使用者不必每次對 <code>remote</code> 操作都要打一長串網址。</p>
<h2 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h2><p>理解意思之後，就能自己做變化！我們可以把 <code>origin</code> 改為別的名稱</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ git remote rename origin origin-github  <span class="comment"># 改名</span></span><br><span class="line"></span><br><span class="line">user@pc:~$ git remote -v</span><br><span class="line">origin-github https://github.com/weirenxue/zcu111-EMIO.git (fetch)</span><br><span class="line">origin-github https://github.com/weirenxue/zcu111-EMIO.git (push)</span><br></pre></td></tr></table></figure>
<p>更甚者，如果有兩個 <code>Git</code> 管理網要 <code>push</code> 的話 (例如：公司專用/個人習慣用)，可以再加入一個 <code>remote</code>！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ git remote add origin-company http://192.168.0.123/fake/zcu111-EMIO.git</span><br><span class="line"></span><br><span class="line">user@pc:~$ git remote -v</span><br><span class="line">origin-github https://github.com/weirenxue/zcu111-EMIO.git (fetch)</span><br><span class="line">origin-github https://github.com/weirenxue/zcu111-EMIO.git (push)</span><br><span class="line">origin-company http://192.168.0.123/fake/zcu111-EMIO.git (fetch)</span><br><span class="line">origin-company http://192.168.0.123/fake/zcu111-EMIO.git (push)</span><br></pre></td></tr></table></figure>
<p><code>push</code> 的方法都沒變，只是將原本是 origin 的地方改為對應的代名詞</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ git push origin-github master  <span class="comment"># 到 GitHub</span></span><br><span class="line"></span><br><span class="line">user@pc:~$ git push origin-company master <span class="comment"># 到公司</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>remote</tag>
        <tag>origin</tag>
        <tag>push</tag>
        <tag>upstream</tag>
      </tags>
  </entry>
  <entry>
    <title>[Electron.js] window.require is not a function 的原因及解決方法</title>
    <url>/2021/08/05/electron_window_require/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用前端框架 (React/Vue/Angular 等) 搭配 Electron 開發桌面應用程式時，最容易在呼叫 Node 套件時遇到問題，此時若查詢相關文獻，會發現大多數人提供一種方法，也就是將 <code>require</code> 改為 <code>window.require</code> 來引用套件。卻伴隨 <code>TypeError: window.require is not a function</code> 錯誤訊息出現，且通常不會提到此問題的解法。因此這裡記錄下個人對於該問題的想法與解決方法，供未來的自己或同好參考。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>node 14.16.1</li>
<li>electron 13.1.8</li>
<li>react 17.0.2</li>
</ul>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>前端框架預設是以瀏覽器 (Browser) 來執行的，我們可以用其作為桌面應用程式的 UI 開發工具，因此若在前端框架中使用 Browser 預設不支援的套件，就會出現如下的錯誤訊息，告訴我們某些被使用的套件不被 Browser 所支援</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span>: <span class="title class_">Workbook</span>.<span class="property">fromFileAsync</span> is not supported <span class="keyword">in</span> the browser</span><br></pre></td></tr></table></figure>
<p>其對應的原始碼為</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">XlsxPopulate</span> = <span class="built_in">require</span>(<span class="string">&#x27;xlsx-populate&#x27;</span>);</span><br><span class="line"><span class="title class_">XlsxPopulate</span>.<span class="title function_">fromFileAsync</span>(...).<span class="title function_">then</span>(...);</span><br></pre></td></tr></table></figure>
<p>將上方錯誤訊息拿去餵 Google，大部分的解決方案是將 <code>require</code> 修改為 <code>window.require</code>，若真的照著做，很大的機率會噴出另一種錯誤訊息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">TypeError: window.require is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>Electron 將應用程式的運作切割為兩種 Process，分別為 Main Process 與 Render Process，兩個 Process 的環境是隔離開來的，且前端框架都是運作在 Render Process 中。若想在前端中引用 Node 的套件 (該套件預設只允許運作在 Main Process)，必須先在 <code>preload.js</code> 明確定義要讓 Render Process 能使用甚麼樣的套件，這樣才能於前端框架中使用。</p>
<p>我們可以將 <code>preload.js</code> 想像是 Main Process 釋放出來的 API，供 Render Process 呼叫使用。通常會以 <code>window</code> 物件來作為介面，例如想在前端使用 <code>remote</code> 模組，就需要先在 <code>preload.js</code> 引入該模組並存放在 <code>window.remote</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preload.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">remote</span> = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>).<span class="property">remote</span>; <span class="comment">// 開放 remote 接口給 Render Process</span></span><br></pre></td></tr></table></figure>
<p>若前端需要使用 <code>remote</code> 模組內的模組，例如 <code>dialog</code>，在前端就可以這樣指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; dialog &#125; = <span class="variable language_">window</span>.<span class="property">remote</span>;</span><br></pre></td></tr></table></figure>
<p>但這樣還是不夠的，Electron 對於安全性設定非常嚴格，我們需要在 <code>main.js</code> 中建立 <code>BrowserWindow</code> 時，加上 <code>enableRemoteModule</code> 與 <code>contextIsolation</code> 兩個安全性選項</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">icon</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;icon.png&#x27;</span>),</span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">        <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;preload.js&#x27;</span>),</span><br><span class="line">        <span class="attr">enableRemoteModule</span>: <span class="literal">true</span>,   <span class="comment">// 允許在 Render Process 使用 Remote Module</span></span><br><span class="line">        <span class="attr">contextIsolation</span>: <span class="literal">false</span>,    <span class="comment">// 讓在 preload.js 的定義可以傳遞到 Render Process (React)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>理解根本原因後，可以推理出 <code>window.require</code> 應該是已經在 <code>preload.js</code> 中先定義好的介面，但我們 <code>preload.js</code> 中沒有相關定義，所以才會噴出錯誤訊息 (<code>TypeError: window.require is not a function</code>)。解決方法就是只需要在 <code>preload.js</code> 加上下方程式即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preload.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">require</span> = <span class="built_in">require</span>;</span><br></pre></td></tr></table></figure>
<p>這裡我們沒有使用到 <code>remote</code> 模組，因此只需確認 <code>contextIsolation</code> 設為 <code>false</code>，重新運行 Electron 就能在 Render Process 中使用 <code>window.require</code> 了！</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>個人非常不建議直接將 Main Process 的 <code>require</code> 開放給 Render Process 使用，這是非常危險的事情。取而代之的是，先明確知道會使用到甚麼套件，再針對該套件來做介面開放，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preload.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">process_browser</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">remote</span> = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>).<span class="property">remote</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">xlsxPopulate</span> = <span class="built_in">require</span>(<span class="string">&#x27;xlsx-populate&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">node_rdp</span> = <span class="built_in">require</span>(<span class="string">&#x27;node-rdp&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">open</span> = <span class="built_in">require</span>(<span class="string">&#x27;open&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">clipboard</span> = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>).<span class="property">clipboard</span>;</span><br></pre></td></tr></table></figure>
<!-- markdownlint-disable MD034 -->
<a class="btn" href="https://github.com/weirenxue/ap-displayer/blob/v2.0-alpha.0/preload.js" title="preload.js">
            <i class="fab fa-github fa-lg"></i>weirenxue/ap-displayer
          </a>
<!-- markdownlint-restore MD034 -->
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>node</tag>
        <tag>window</tag>
        <tag>require</tag>
        <tag>js</tag>
        <tag>process</tag>
        <tag>main</tag>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title>[Firewall] CentOS 開啟指定的 Port 或服務</title>
    <url>/2021/06/18/firewall_centos_port/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 CentOS 中有多種防火牆 (iptables、firewalld 等)，其中 iptables 是為黑名單規則 (原則允許、例外禁止)，而 firewalld 為白名單規則 (原則禁止、例外允許)。</p>
<p>為了要讓服務能正常運作、防止惡意連線，且讓外部可以通過網路服務來使用，這些是必定要學習如何設定的。然而相較於 iptables，firewalld 較人性化，因此選擇使用它來做 CentOS 的防火牆設定。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
</ul>
<h2 id="確認網路環境"><a href="#確認網路環境" class="headerlink" title="確認網路環境"></a>確認網路環境</h2><p>開啟 Terminal，確定自己所對外服務的 IP 運作在哪個網卡上，此例為 <code>ens33</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip address</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:08:ef:40 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.35.134/24 brd 192.168.35.255 scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft 1107sec preferred_lft 1107sec</span><br><span class="line">    inet6 fe80::5dee:a1e6:5618:5b6c/64 scope <span class="built_in">link</span> noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>確定自己網卡 <code>ens33</code> 所在的防火牆區域 (zone)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --get-zone-of-interface=ens33</span></span><br><span class="line">public</span><br></pre></td></tr></table></figure>
<h2 id="修改防火牆設定"><a href="#修改防火牆設定" class="headerlink" title="修改防火牆設定"></a>修改防火牆設定</h2><p>在網卡所在區域加上想要的服務 (http) 或 Port (5001/tcp)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --zone=public --add-port=5001/tcp</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --permanent --zone=public --add-service=http</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>--permanent</code>：是將設定寫入 <code>/etc/firewalld/zones/public.xml</code>，系統重新啟動後會載入該檔案的設定，因此防火牆設定效果不會消失。可以查看 <code>/etc/firewalld/zones/public.xml</code> 內容</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/firewalld/zones/public.xml</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">&lt;short&gt;Public&lt;/short&gt;</span><br><span class="line">&lt;description&gt;For use <span class="keyword">in</span> public areas. You <span class="keyword">do</span> not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;</span><br><span class="line">&lt;service name=<span class="string">&quot;ssh&quot;</span>/&gt;</span><br><span class="line">&lt;service name=<span class="string">&quot;dhcpv6-client&quot;</span>/&gt;</span><br><span class="line">&lt;service name=<span class="string">&quot;cockpit&quot;</span>/&gt;</span><br><span class="line">&lt;service name=<span class="string">&quot;http&quot;</span>/&gt;</span><br><span class="line">&lt;port port=<span class="string">&quot;5001&quot;</span> protocol=<span class="string">&quot;tcp&quot;</span>/&gt;</span><br><span class="line">&lt;/zone&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 <code>--reload</code> 將設定重新載入配置，並查看所設定的規則是否已經有效，這時在瀏覽器輸入 <code>localhost</code>，就可以瀏覽掛在 80 Port 的網站了！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --zone=public --list-ports</span></span><br><span class="line">5001/tcp</span><br><span class="line">[root@localhost ~]<span class="comment"># firewall-cmd --zone=public --list-services </span></span><br><span class="line">cockpit dhcpv6-client http ssh</span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://kknews.cc/zh-tw/code/y38kggb.html">CentOS 7/8 預裝的新型防火牆firewalld配置詳解，你會用嗎</a></p>
</li>
<li><p><a href="https://firewalld.org/documentation/configuration/runtime-versus-permanent.html">Runtime versus Permanent</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>8.2</tag>
        <tag>firewall</tag>
        <tag>firewalld</tag>
        <tag>port</tag>
        <tag>service</tag>
        <tag>iptables</tag>
        <tag>zone</tag>
      </tags>
  </entry>
  <entry>
    <title>[EJS] 單獨使用 EJS 渲染前端畫面</title>
    <url>/2021/06/15/ejs_ejs/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>網路上有許多 <code>EJS</code> 使用範例，通常是以 <code>Node.js</code> 與 <code>Express</code> 搭配的教學，而這裡紀錄如何單獨使用 <code>EJS</code> 來渲染前端畫面。</p>
<h2 id="使用步驟"><a href="#使用步驟" class="headerlink" title="使用步驟"></a>使用步驟</h2><p>建立一個目錄用來放置相關檔案，並下載 <a href="https://github.com/mde/ejs/releases/tag/v3.0.2">EJS</a> 內的 <code>ejs.min.js</code> 放至此目錄中。再新增 <code>index.html</code> 且程式碼如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./ejs.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> html = ejs.<span class="title function_">render</span>(<span class="string">&#x27;fieldA:&lt;%= fieldA %&gt;&lt;br /&gt;fieldB:&lt;%= fieldB %&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                &#123;fieldA : <span class="string">&#x27;Hello world!&#x27;</span>, fieldB : <span class="string">&#x27;Hellow Taiwan!&#x27;</span>&#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;divContent&#x27;</span>).<span class="property">innerHTML</span> = html;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;divContent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此時的目錄檔案結構為</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── ejs.min.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure>
<p>直接雙擊 <code>index.html</code>，用瀏灠器就可以看到結果囉！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fieldA:Hello world!</span><br><span class="line">fieldB:Hellow Taiwan!</span><br></pre></td></tr></table></figure>
<p>參考原始碼：<a href="https://github.com/weirenxue/ejs-first-step">GitHub</a></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>render</tag>
        <tag>ejs</tag>
        <tag>front end</tag>
        <tag>alone</tag>
      </tags>
  </entry>
  <entry>
    <title>[GitHub] Please use a personal access token instead.</title>
    <url>/2021/08/17/github_pat/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 2020 年 7 月的時候 GitHub 就開始聲明將棄用 password authentication 機制，改為採用 token-based authentication 機制。這項機制終於在 2021 年的 8 月 13 強制實施，這裡紀錄如何使用 Personal Access Token (PAT) 讓我們可以與 GitHub 連線。</p>
<h2 id="產生-PAT"><a href="#產生-PAT" class="headerlink" title="產生 PAT"></a>產生 PAT</h2><p>登入 GitHub 後點擊右上角自己的頭像，進入 Settings 中的 Developer settings</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/GitHub-Please-use-a-personal-access-token-instead%2Fsettings.png?alt=media&amp;token=5856452d-4bd5-4eef-af4e-df8df7d8ab91" alt="Developer settings"><span class="image-caption">Developer settings</span></p>
<p>透過 <code>Personal access tokens → Generate new token</code> 到建立 PAT 的頁面，其中有三個資訊需要填寫，分別為</p>
<ul>
<li><code>Note</code>：可以視為 PAT 的名稱，目的性越清楚越好，避免一段時間回來看的時候不知其用途。</li>
<li><code>Expiration</code>：指定 PAT 有效期限，依自己需求設定時間長度。以 Token 來說，一個月到三個月是可接受的範圍，不建議設定為永久。</li>
<li><code>Select scopes</code>：指定 PAT 擁有的權限，每個權限說明可以參考 <a href="https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps">Scopes for OAuth Apps</a>。</li>
</ul>
<p>填寫好之後點擊 <code>Generate token</code> 按鈕產生 PAT</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/GitHub-Please-use-a-personal-access-token-instead%2Fcreate_pat.png?alt=media&amp;token=30df4446-49b4-4a3f-8618-fc71f8e65b08" alt="建立 PAT"><span class="image-caption">建立 PAT</span></p>
<p>產生的 PAT 會直接顯示在頁面上，需要馬上記下來，否則離開頁面後就無法找回，只能重新產生</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/GitHub-Please-use-a-personal-access-token-instead%2Fpat.png?alt=media&amp;token=200bc4e5-480f-4133-872b-aba5557a5eab" alt="PAT"><span class="image-caption">PAT</span></p>
<h2 id="透過-Git-Cli-設置-PAT"><a href="#透過-Git-Cli-設置-PAT" class="headerlink" title="透過 Git Cli 設置 PAT"></a>透過 Git Cli 設置 PAT</h2><p>直接對 GitHub 使用 push/pull/fetch 等指令，觸發輸入帳密</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git remote add origin https://github.com/&#123;username&#125;/&#123;repository&#125;</span><br><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span> : <span class="comment"># 輸入你的 GitHub username</span></span><br><span class="line">Password <span class="keyword">for</span> <span class="string">&#x27;https://github.com&#x27;</span> : <span class="comment"># 輸入剛建立好的 PAT，而不是 GitHub 的密碼</span></span><br><span class="line"><span class="variable">$</span> git config <span class="literal">--global</span> credential.helper cache <span class="comment"># 讓 Git 幫忙記住帳號密碼資訊，</span></span><br><span class="line">                                            <span class="comment"># 不需要每次操作都輸入一次帳密</span></span><br></pre></td></tr></table></figure>
<p>如果直接操作沒有出現帳密輸入提示，反而出現以下訊息</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">remote: Support <span class="keyword">for</span> password authentication was removed on August <span class="number">13</span>, <span class="number">2021</span>. Please use a personal access token instead.</span><br><span class="line">remote: Please see https://github.blog/<span class="number">2020</span><span class="literal">-12-15-token-authentication-requirements-for-git-operations</span>/ <span class="keyword">for</span> more information.</span><br><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/&#123;username&#125;/&#123;repository&#125;&#x27;</span>: The requested URL returned error: <span class="number">403</span></span><br></pre></td></tr></table></figure>
<p>表示帳號密碼已經存在於快取之中，我們需要先使用以下指令移除已存在的帳號密碼，再重新操作一次上面的指令</p>
<!-- markdownlint-disable MD014 -->
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git config <span class="literal">--global</span> <span class="literal">--unset</span> credential.helper</span><br><span class="line"><span class="variable">$</span> git config <span class="literal">--system</span> <span class="literal">--unset</span> credential.helper</span><br></pre></td></tr></table></figure>
<!-- markdownlint-enable MD014-->
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>github</tag>
        <tag>pat</tag>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title>[Golang] WebSocket Stream Benchmark 效能評估</title>
    <url>/2022/05/08/websocket_stream_benchmark/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果 WebSocket 伺服器頻繁向客戶端發送訊息，是否會影響客戶端的請求？是否應該使用多個 WebSocket 連接來分開數據流量？所以我用 Golang 來做這個場景的基準測試。最後，讓我來和大家分享一下這個結果。</p>
<h2 id="Benchmark-目標"><a href="#Benchmark-目標" class="headerlink" title="Benchmark 目標"></a>Benchmark 目標</h2><p>當伺服器通過 WebSocket 連線以高頻率向客戶端發送數據時，如果客戶端通過同一 WebSocket 連線向伺服器發送低頻率信息，需要多長時間才能收到回覆？</p>
<h2 id="原始碼與使用方法"><a href="#原始碼與使用方法" class="headerlink" title="原始碼與使用方法"></a>原始碼與使用方法</h2><!-- markdownlint-disable MD034 -->
<ul>
<li>原始碼： <a class="btn" href="https://github.com/weirenxue/websocket-stream-benchmarck" title="websocket-stream-benchmarck">
            <i class="fab fa-github fa-lg"></i>websocket-stream-benchmarck
          </a></li>
<li><p>使用方法：<br>  Clone 此專案並編譯</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/weirenxue/websocket-stream-benchmarck.git <span class="comment"># clone</span></span><br><span class="line"></span><br><span class="line">make <span class="comment"># build</span></span><br></pre></td></tr></table></figure>
<p>  將會在 <code>./bin</code>文件夾中找到兩個可執行文件 <code>client</code> 和 <code>server</code>。首先運行 <code>./bin/server</code>，然後打開另一個終端窗口，運行 <code>./bin/client</code>，等待 <code>client</code> 完成執行並輸出結果。</p>
<p>  你可能想改變 <code>config.toml</code> 中的配置，看看不同情況下的測試結果。</p>
</li>
</ul>
<!-- markdownlint-restore MD034 -->
<h2 id="config-toml-的參數說明"><a href="#config-toml-的參數說明" class="headerlink" title="config.toml 的參數說明"></a>config.toml 的參數說明</h2><ul>
<li><code>server</code><ul>
<li><code>host</code>：WebSocket 伺服器主機。</li>
<li><code>port</code>：WebSocket 伺服器端口。</li>
<li><code>dummy_message_size</code>：每個假訊息的大小。</li>
<li><code>dummy_message_duration</code>：發送每個假訊息的時間間隔。</li>
</ul>
</li>
<li><code>client</code><ul>
<li><code>request_duration</code>：發送每個請求的時間間隔。</li>
<li><code>total_request</code>：應該發送的請求的數量。</li>
</ul>
</li>
</ul>
<h2 id="設計概念"><a href="#設計概念" class="headerlink" title="設計概念"></a>設計概念</h2><ul>
<li>Server：一旦客戶端連接到伺服器，伺服器就會每隔 <code>dummy_message_duration</code> 向客戶端發送一條大小為 <code>dummy_message_size</code> 的訊息。伺服器會監聽客戶端是否發送訊息，如果是，它將接收並直接回覆原始訊息。</li>
<li>Client：客戶端生成一個 <code>uuid</code> 作為發送給伺服器的請求，而伺服器必須發回同樣的訊息。基於 <code>uuid</code> 的唯一性，我們可以知道一個請求從被發送到被回覆所需的時間，最後將每個請求所需的時間除以請求的數量以取得平均來回時間。</li>
</ul>
<p><strong>最後，每個案例測試五次，選擇最差的案例並記錄在實驗結果中。</strong></p>
<h2 id="測試環境與結果"><a href="#測試環境與結果" class="headerlink" title="測試環境與結果"></a>測試環境與結果</h2><ul>
<li>OS：macOS 12.2.1</li>
<li>CPU：i7 2.7GHz 4 Cores</li>
<li>RAM：16 GB LPDDR3</li>
</ul>
<!-- markdownlint-disable MD033 -->
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">dummy config→<br>request config↓</th>
<th style="text-align:left">dummy_message_size=&quot;10KB&quot;<br>dummy_message_duration=&quot;1h&quot;<br>(no dummy message due to long duration)</th>
<th style="text-align:left">dummy_message_size=&quot;10KB&quot;<br>dummy_message_duration=&quot;500us&quot;</th>
<th style="text-align:left">dummy_message_size=&quot;1MB&quot;<br>dummy_message_duration=&quot;500us&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">total_request=1000<br>request_duration=&quot;1ms&quot;</td>
<td style="text-align:left">total duration: 160.714504ms<br>average duration: <strong>160.714µs</strong><br>total received dummy message: 0B</td>
<td style="text-align:left">total duration: 83.472281ms<br>average duration: <strong>83.472µs</strong><br>total received dummy message: 19710KB<br></td>
<td style="text-align:left">total duration: 5.364239748s<br>average duration: <strong>5.364239ms</strong><br>total received dummy message: 787MB<br></td>
</tr>
<tr>
<td style="text-align:left">request_duration=&quot;10ms&quot;<br>total_request=1000</td>
<td style="text-align:left">total duration: 300.998294ms<br>average duration: <strong>300.998µs</strong><br>total received dummy message: 0B<br></td>
<td style="text-align:left">total duration: 110.638204ms<br>average duration: <strong>110.638µs</strong><br>total received dummy message: 154350KB<br></td>
<td style="text-align:left">total duration: 5.675233495s<br>average duration: <strong>5.675233ms</strong><br>total received dummy message: 7520MB<br></td>
</tr>
</tbody>
</table>
</div>
<!-- markdownlint-restore MD033 -->
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我們也許會擔心若所有資料流量都在同一個 WebSocket 連線上，頻寬會被分走，導致有些 Client 端的指令無法被及時處理。但根據這個專案的結果顯示，我們可以放心的讓所有資料流量都在一個 WebSocket 連線上傳遞。這是好事，因為多個連線會造成伺服器一定的負擔。</p>
<p>除此之外，可以從商用產品來看 WebSocket 連線數問題。例如，在 <a href="https://firebase.google.com/pricing#realtime-database">Firebase 的 Realtime Database 服務的官方定價</a>中，有一項是限制同時使用的連線數，因此若在一個瀏覽器視窗上有多個連線數，將會造成金額上的負擔。當然，Firebase SDK 很貼心，讓所有的請求都是在同一個 WebSocket 上進行，以確保一個瀏覽器視窗只有一個 WebSocket 連線。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>websocket</tag>
        <tag>connection</tag>
        <tag>split</tag>
        <tag>share</tag>
        <tag>bandwidth</tag>
        <tag>data</tag>
        <tag>traffic</tag>
        <tag>stream</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>[Git] git-cli 使用樹狀圖展示 Commit Log</title>
    <url>/2021/06/13/git_terminal_git_log/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>習慣使用 cli 操作 Git 後，不會想裝 Git 的 GUI 擴充，但還是覺得若能以樹狀圖來看 Commit Log 會很方便。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>同樣是使用 <code>git log</code> 指令，但需加上一些參數達到這個效果</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">user@pc:~$ git log --oneline --graph --all</span><br><span class="line">* baf420b (HEAD -&gt; feat-fill-up) Text to speech</span><br><span class="line">* a06c9c8 Display the fuel prompt</span><br><span class="line">| * 5d04f92 (origin-github/feat, feat) renew API</span><br><span class="line">|/  </span><br><span class="line">* 19b0257 Rename the variables&#x27; name</span><br><span class="line">* 41992f1 renew API(communicates with golang API)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--oneline</code>：只顯示 log 標題，若不限定為只有標題，將會顯得雜亂。</li>
<li><code>--graph</code>：以樹狀圖顯示 log。</li>
<li><code>--all</code>：全部的 log，包含所有分支。</li>
</ul>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tree</tag>
        <tag>log</tag>
        <tag>commit</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title>[Git] 設定不同路徑或單一 Repo 擁有各自的作者資訊</title>
    <url>/2022/01/22/git_author/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 起手式中很重要的一件事就是設定作者資訊，因為不同的專案想要顯示的作者資訊可能會想要不同。例如：自己的專案當然就是以個人的 E-Mail 作為作者資訊，但公司的專案可能就會需要以公司的 E-Mail 來顯示。這裡記錄如何設定預設作者資訊、特定路徑預設的作者資訊、單一 Repo 作者資訊。</p>
<h2 id="預設作者資訊設定"><a href="#預設作者資訊設定" class="headerlink" title="預設作者資訊設定"></a>預設作者資訊設定</h2><p>預設的作者資訊會儲存在家目錄中的 <code>.gitconfig</code> (即 <code>~/.gitconfig</code>)，因此修改預設作者資訊的方法有兩個，一個是透過 Git 指令修改該檔案，一個則是直接修改檔案本身。這裡演示的是如何透過指令修改，修改檔案的部分只需要將 <code>~/.gitconfig</code> 修改如同指令產生的結果即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Wei-Ren Xue&quot;</span>           <span class="comment"># 修改預設的作者名稱</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;weirenxue@gmail.com&quot;</span>  <span class="comment"># 修改預設的作者 E-Mail</span></span><br><span class="line">$ <span class="built_in">cat</span> ~/.gitconfig                                      <span class="comment"># 查看 ~/.gitconfig</span></span><br><span class="line"><span class="comment"># This is Git&#x27;s per-user configuration file.</span></span><br><span class="line">[user]</span><br><span class="line">    name = Wei-Ren Xue</span><br><span class="line">    email = weirenxue@gmail.com</span><br></pre></td></tr></table></figure>
<p>這樣的情況下，在任何 Repo 中預設的作者資訊已被設定完成，所以 Commit 的作者資訊都會被壓成 <code>Wei-Ren Xue &lt;weirenxue@gmail.com&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">% git <span class="built_in">log</span></span><br><span class="line">commit e41ae7ce8730d54e90f2115b325c4cea6c56bf2e (HEAD -&gt; master)</span><br><span class="line">Author: Wei-Ren Xue &lt;weirenxue@gmail.com&gt;</span><br><span class="line">Date:   Sat Jan 22 13:33:02 2022 +0800</span><br><span class="line"></span><br><span class="line">    init</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>可以透過 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt---show-origin">--show-origin</a> 知道我們的作者資訊從何而來</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:/Users/wrxue/.gitconfig    Wei-Ren Xue</span><br><span class="line">$ git config --show-origin user.email</span><br><span class="line">file:/Users/wrxue/.gitconfig    weirenxue@gmail.com</span><br></pre></td></tr></table></figure>
          </div>
<h2 id="特定路徑預設的作者資訊設定"><a href="#特定路徑預設的作者資訊設定" class="headerlink" title="特定路徑預設的作者資訊設定"></a>特定路徑預設的作者資訊設定</h2><p>這時候就會想到：會不會每次要 Commit 到公司專案時，就要使用一次 <code>git config --global</code> 重設資訊，要 Commit 自己的專案時又要再執行一次指令，這樣超麻煩！</p>
<p>幸好，Git 提供 <a href="https://git-scm.com/docs/git-config#_conditional_includes">Conditional includes</a> 讓我們可以在指定的情況使用指定的 <code>.gitconfig</code>。現在假設公司的專案都會放在 <code>~/company</code> 目錄底下，並且在該目錄底下創建一個 <code>.gitconfig</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/company/.gitconfig</span></span><br><span class="line">[user]</span><br><span class="line">    name = Wei-Ren Xue</span><br><span class="line">    email = weirenxue@company.com</span><br></pre></td></tr></table></figure>
<p>在 <code>~/.gitconfig</code> 檔案中<strong>加入</strong>下方內容，意思是只要在路徑為 <code>~/company</code> 底下的 Repo 預設都會使用 <code>path</code> 指定的設定檔 (此為 <code>~/company/.gitconfig</code>)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[includeIf <span class="string">&quot;gitdir:~/company/**&quot;</span>]</span><br><span class="line">    path = ~/company/.gitconfig</span><br></pre></td></tr></table></figure>
<p>同樣地，可以透過 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt---show-origin">--show-origin</a> 知道我們的作者資訊從何而來。當然，執行指令之前，需要先進入 <code>~/company</code> 目錄下的 Repo 才能看得出來差異哦！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:/Users/wrxue/company/.gitconfig    Wei-Ren Xue</span><br><span class="line">$ git config --show-origin user.email</span><br><span class="line">file:/Users/wrxue/company/.gitconfig    weirenxue@company.com</span><br><span class="line">(venv) wrxue@m testgit % </span><br></pre></td></tr></table></figure>
<h2 id="單一-Repo-作者資訊設定"><a href="#單一-Repo-作者資訊設定" class="headerlink" title="單一 Repo 作者資訊設定"></a>單一 Repo 作者資訊設定</h2><p>預設作者資訊設定、特定路徑預設的作者資訊設定這兩種設定方式都理解後，設定單一 Repo 作者資訊的原理也是同樣的，每個 Repo 中都有屬於自己的設定檔案，即為 Repo 底下的 <code>.git/config</code>。相同地，可以使用指令或直接更新檔案內容的方式達到設定作者資訊的修改。記住：需要先到 Repo 目錄中再執行指令</p>
<!-- markdownlint-disable MD014 -->
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config user.name <span class="string">&quot;Wei-Ren Xue&quot;</span></span><br><span class="line">$ git config user.email <span class="string">&quot;weirenxue@one-repo.com&quot;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/config</span><br><span class="line">[user]</span><br><span class="line">    name = Wei-Ren Xue</span><br><span class="line">    email = weirenxue@one-repo.com</span><br><span class="line"></span><br><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:.git/config    Wei-Ren Xue</span><br><span class="line">$ git config --show-origin user.email</span><br><span class="line">file:.git/config    weirenxue@one-repo.com</span><br></pre></td></tr></table></figure>
<!-- markdownlint-restore MD014 -->
<p>有沒有覺得很眼熟？沒錯，就是比預設作者資訊設定少 <code>--global</code> 而已！</p>
<h2 id="修正-Commit-後的-Author-資訊"><a href="#修正-Commit-後的-Author-資訊" class="headerlink" title="修正 Commit 後的 Author 資訊"></a>修正 Commit 後的 Author 資訊</h2><p>Commit 後發現不小心使用錯誤的作者資訊怎麼辦？有一個補救的辦法，使用下方指令便能修正，但這個補救方式僅限於最新的 Commit 適用。所以建議在 Commit 之前還是多多使用 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt---show-origin">--show-origin</a> 來確認當前的作者資訊是什麼吧！</p>
<!-- markdownlint-disable MD014 -->
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git commit --amend --reset-author</span><br></pre></td></tr></table></figure>
<!-- markdownlint-restore MD014 -->
<h2 id="設定檔載入的優先順序"><a href="#設定檔載入的優先順序" class="headerlink" title="設定檔載入的優先順序"></a>設定檔載入的優先順序</h2><p>可以用一個比較容易的方式記憶，就是影響的範圍越小，順序越前面。</p>
<p>因此 Git 會先載入 <code>.git/config</code> 查看有沒有需要的資訊，若無才再找看看有沒有設定 <code>~/your/path/.gitconfig</code>，都沒有的話最後才是使用 <code>~/.gitconfig</code> 內的資訊。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-%E5%88%9D%E6%AC%A1%E8%A8%AD%E5%AE%9A-Git">開始 - 初次設定 Git</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
        <tag>user</tag>
        <tag>name</tag>
        <tag>email</tag>
        <tag>path</tag>
        <tag>gitconfig</tag>
        <tag>author</tag>
      </tags>
  </entry>
  <entry>
    <title>[Hyper-V] 讓 Windows 的硬碟可以超過 16 TB</title>
    <url>/2021/06/15/hyper_v_windows_16_tb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 檔案系統預設的 Cluster Size 為 4KB，進一步導致分割區最多只能到 16 TB，當要延伸磁區且總容量會超過 16 TB 時，就會出現「磁碟區無法延伸 因為叢集數目將超過檔案系統支援的最大叢集數目」的提示視窗。</p>
<p>若想要讓 C 槽可到 16 TB 以上的容量，需要在安裝 Windows 時就先設定 (若沒設定但又需要延伸大容量硬碟的話，就重灌吧 QQ)！這篇文章便是紀錄如何設定 C 槽預設能使用更大容量的硬碟！</p>
<h2 id="查看所需-Cluster-Size"><a href="#查看所需-Cluster-Size" class="headerlink" title="查看所需 Cluster Size"></a>查看所需 Cluster Size</h2><p>請先參考 <a href="https://support.microsoft.com/zh-tw/topic/%E9%A0%90%E8%A8%AD-ntfs-fat-%E5%92%8C-exfat-%E7%9A%84%E5%8F%A2%E9%9B%86%E5%A4%A7%E5%B0%8F-9772e6f1-e31a-00d7-e18f-73169155af95">預設 NTFS、 FAT，和 exFAT 的叢集大小。</a> 中的表格，找出自己需要的 Cluster Size ，例如我是需要將 OS 灌在 Hyper-V 之中，目前 (2021/01/29) 官方所建議的最大容量為 64 TB ，因此查表得知對應的 Cluster Size 應為 16 KB！記住這個資訊下面步驟會用到。</p>
<h2 id="修改預設-Cluster-Size"><a href="#修改預設-Cluster-Size" class="headerlink" title="修改預設 Cluster Size"></a>修改預設 Cluster Size</h2><p>參考影片設定步驟，會用到的指令及順序如下，其中的 <code>16K</code> 請改為上一步所查找出來的結果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISKPART</span><br><span class="line">LIST DISK</span><br><span class="line">SELECT DISK 0</span><br><span class="line">LIST PARTITION</span><br><span class="line">SELECT PARTITION 4</span><br><span class="line">FORMAT QUICK UNIT=16K</span><br><span class="line">EXIT </span><br><span class="line">SETUP</span><br></pre></td></tr></table></figure>
<!-- markdownlint-disable MD033 -->
<iframe width="560" height="315" src="https://www.youtube.com/embed/KmW_b57L2Ao" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<!-- markdownlint-restore MD033 -->
<p>按照影片步驟做完後，該 VM 的 C 槽的 Cluster Size 就為 16 KB 囉！讓 C 槽可延伸最多到 64 TB 的容量！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>16 tb</tag>
        <tag>hyperv</tag>
        <tag>drive</tag>
        <tag>cluster</tag>
        <tag>size</tag>
      </tags>
  </entry>
  <entry>
    <title>[IIS] 隱藏 Server, X-Powered-By, X-AspNet-Version 標頭</title>
    <url>/2021/06/15/iis_server_x_powered_by_x_aspnet_version/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>暴露太多關於伺服器的資訊，會增加資通安全的風險，倘若伺服器使用的版本不幸出現嚴重漏洞，馬上就會成為駭客的目標，因此學會如何藏匿伺服器的相關資訊是非常重要的。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>IIS 10.0</li>
</ul>
<h2 id="隱匿資訊"><a href="#隱匿資訊" class="headerlink" title="隱匿資訊"></a>隱匿資訊</h2><h3 id="隱藏-Server-欄位"><a href="#隱藏-Server-欄位" class="headerlink" title="隱藏 Server 欄位"></a>隱藏 Server 欄位</h3><p>在 <code>Web.config</code> 內的 <code>system.webServer</code> 節點下，加入 <code>security</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">requestFiltering</span> <span class="attr">removeServerHeader</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="隱藏-X-Powered-By-欄位"><a href="#隱藏-X-Powered-By-欄位" class="headerlink" title="隱藏 X-Powered-By 欄位"></a>隱藏 X-Powered-By 欄位</h3><p>在 <code>Web.config</code> 內的 <code>system.webServer</code> 節點下，加入 <code>httpProtocol</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpProtocol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">customHeaders</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">remove</span> <span class="attr">name</span>=<span class="string">&quot;X-Powered-By&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">customHeaders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">httpProtocol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="隱藏-X-AspNet-Version-欄位"><a href="#隱藏-X-AspNet-Version-欄位" class="headerlink" title="隱藏 X-AspNet-Version 欄位"></a>隱藏 X-AspNet-Version 欄位</h3><p>在 <code>Web.config</code> 內的 <code>system.web</code> 節點下，加入 <code>httpRuntime</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system.web</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpRuntime</span> <span class="attr">targetFramework</span>=<span class="string">&quot;4.6.1&quot;</span> <span class="attr">enableVersionHeader</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system.web</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>header</tag>
        <tag>windows</tag>
        <tag>iis</tag>
        <tag>x powered by</tag>
        <tag>x aspnet version</tag>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>[IME] 在 Ubuntu 安裝嘸蝦米等輸入法</title>
    <url>/2021/06/17/ime_ubuntu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ubuntu 預設中的輸入法為 IBus 框架，除 IBus 外還有很多如 gcin、fcitx 等不同的輸入法框架，若想要使用如嘸 (ㄈㄨˇ) 蝦米等輸入法的話就需要使用有支援的框架，這篇文章主要紀錄如何安裝嘸蝦米輸入法與酷音輸入法。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="安裝輸入法"><a href="#安裝輸入法" class="headerlink" title="安裝輸入法"></a>安裝輸入法</h2><p>我是選擇使用 fcitx (Free Chinese Input Tool for X) 框架新增輸入法。</p>
<p>首先先安裝該框架，在安裝需要的輸入法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install fcitx                 <span class="comment"># fcitx 框架安裝</span></span><br><span class="line">user@pc:~$ sudo apt-get install fcitx-table-boshiamy  <span class="comment"># 嘸蝦米碼表</span></span><br><span class="line">user@pc:~$ sudo apt-get install fcitx-chewing         <span class="comment"># 酷音</span></span><br></pre></td></tr></table></figure>
<h2 id="系統設定"><a href="#系統設定" class="headerlink" title="系統設定"></a>系統設定</h2><p>在 Languague Support 做設定，將輸入法系統改為 fcitx，重新開機後在畫面右上方可以看到 fcitx 框架的圖示，若原本是用 IBus，IBus 圖示依舊會存在 (參考：<a href="/2021/06/17/ime_ibus/">[IME] 有其他輸入法框架後移除 IBus 圖示</a>)。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/IME-%E5%9C%A8-Ubuntu-%E5%AE%89%E8%A3%9D%E5%98%B8%E8%9D%A6%E7%B1%B3%E7%AD%89%E8%BC%B8%E5%85%A5%E6%B3%95%2Fchange_ime.png?alt=media&amp;token=9bc6f6db-41b9-417e-ab0f-fb1bc249c097" alt="設定輸入法系統"><span class="image-caption">設定輸入法系統</span></p>
<p>點擊 fcitx 圖示 -&gt; Configure，若有看到嘸蝦米 (Boshiamy) 等自己安裝的輸入法，就代表安裝完成，可以開始使用了。若沒有看到，可點擊左下角的「＋」按鈕，在搜尋框內輸入 Chewing 來新增。若很確定有安裝輸入法但找不到的話，試著把「Only Show Current Language」取消勾選，就會有了</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/IME-%E5%9C%A8-Ubuntu-%E5%AE%89%E8%A3%9D%E5%98%B8%E8%9D%A6%E7%B1%B3%E7%AD%89%E8%BC%B8%E5%85%A5%E6%B3%95%2Fadd_ime.png?alt=media&amp;token=14b764f6-c8e6-44cc-927a-e9dbb3d27152" alt="fcitx 介面"><span class="image-caption">fcitx 介面</span></p>
<h2 id="貼心小提醒"><a href="#貼心小提醒" class="headerlink" title="貼心小提醒"></a>貼心小提醒</h2><p>嘸蝦米的預設通常是簡體中文，若要換成繁體中文的話可按組合鍵「Ctrl + Shift + F」做切換。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>ibus</tag>
        <tag>gcin</tag>
        <tag>fcitx</tag>
        <tag>boshiamy</tag>
        <tag>chewing</tag>
        <tag>ime</tag>
        <tag>18.04</tag>
      </tags>
  </entry>
  <entry>
    <title>[IME] 有其他輸入法框架後移除 IBus 圖示</title>
    <url>/2021/06/17/ime_ibus/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ubuntu 在安裝完非預設的輸入法框架之後，在畫面右上角會看到新的輸入法圖示，但預設的 IBus 圖示仍然會存在，讓人看到就覺得煩躁進而想要移除掉圖示。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>fcitx 和 IBus 同時存在，但只有 fcitx 能使用，IBus 可以不用理它沒有關係，但看著就怪怪的，所以想要把它的圖示移除。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/IME-%E6%9C%89%E5%85%B6%E4%BB%96%E8%BC%B8%E5%85%A5%E6%B3%95%E6%A1%86%E6%9E%B6%E5%BE%8C%E7%A7%BB%E9%99%A4-IBus-%E5%9C%96%E7%A4%BA%2Fime_icon.png?alt=media&amp;token=508a4f4b-74af-4238-9519-fcc2fb3c5686" alt="輸入法框架圖示"><span class="image-caption">輸入法框架圖示</span></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>移除圖示的原理就是讓 IBus 不要執行，可以將 IBus 的 daemon 檔案移除或更改名字，使系統找不到檔案無法運行 IBus 服務，這裡為了之後有可能有需要用到 IBus 的意外，因此只做改名字的動作，檔案還是存在於系統內。更改檔名後重開機，就發現 IBus 圖示消失啦！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo <span class="built_in">mv</span> /usr/bin/ibus-daemon /usr/bin/ibus-daemon.bak</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ibus</tag>
        <tag>fcitx</tag>
        <tag>18.04</tag>
        <tag>remove</tag>
      </tags>
  </entry>
  <entry>
    <title>[Jupyter] 幫 Notebook 切換虛擬環境</title>
    <url>/2021/08/17/jupyter_notebook_venv/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Python 開發中，常會建立虛擬環境來區隔開發環境，避免套件衝突與其他不必要的問題發生。在這種情況下，若使用 Jupyter Notebook 來開發，就會遇到需要指定虛擬環境的問題。這裡記錄下如何在虛擬環境中建立給 Jupyter 使用的 Kernel，並將其指定其作為在 Jupyter Notebook 中所要執行的環境。</p>
<h2 id="虛擬環境"><a href="#虛擬環境" class="headerlink" title="虛擬環境"></a>虛擬環境</h2><p>新建立一個 Python 虛擬環境，並命名為 <code>scrap</code>，並啟動該虛擬環境，若在命令列前方看到 <code>(scrap)</code> 就代表啟動成功</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">D:\&gt; python <span class="literal">-m</span> venv scrap</span><br><span class="line"></span><br><span class="line">D:\&gt; .\scrap\Scripts\activate</span><br><span class="line"></span><br><span class="line">(scrap) D:\&gt;</span><br></pre></td></tr></table></figure>
<h2 id="建立-Kernel"><a href="#建立-Kernel" class="headerlink" title="建立 Kernel"></a>建立 Kernel</h2><p>保持良好的習慣，安裝套件前先將 <code>pip</code> 更新到最新</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">(scrap) D:\&gt; python <span class="literal">-m</span> pip install <span class="literal">--upgrade</span> pip</span><br></pre></td></tr></table></figure>
<p>安裝 <code>ipykernel</code> 套件，並使用 <code>ipykernel</code> 建立 Kernel 給 Jupyter Notebook 使用，此 Kernel 代表的是該虛擬環境 (scrap)</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">(scrap) D:\&gt; pip install ipykernel</span><br><span class="line"></span><br><span class="line">(scrap) D:\&gt; ipython kernel install <span class="literal">--user</span> <span class="literal">--name</span>=<span class="string">&quot;scrap&quot;</span> <span class="literal">--display-name</span>=<span class="string">&quot;Scrap&quot;</span></span><br><span class="line">Installed kernelspec scrap <span class="keyword">in</span> C:\Users\wrxue\AppData\Roaming\jupyter\kernels\scrap</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--user</code>：該 Kernel 只對當前的使用者有效，因此會將 Kernel 配置安裝於使用者的目錄底下 (<code>C:\Users\&#123;username&#125;\AppData\Roaming\jupyter\kernels\</code>)，若無此 option 則會安裝到全域目錄 (<code>C:\ProgramData\jupyter\kernels\</code>) 讓其他使用者也可使用，在 Jupyter Notebook 中常看到的 <code>Python 3</code> 這個 Kernel 也是在全域的目錄底下唷！</li>
<li><code>--name</code>：Kernel 的名稱。</li>
<li><code>--display-name</code>：Kernel 在 Jupyter Notebook 顯示的名稱，若無指定此 option，預設則是以 <code>--name</code> 的值來顯示。</li>
</ul>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><h3 id="開啟-Notebook"><a href="#開啟-Notebook" class="headerlink" title="開啟 Notebook"></a>開啟 Notebook</h3><p>在任何 Python 虛擬環境或原始環境開啟 Jupyter Notebook，運作起來的結果都是一樣的</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">(scrap) D:\&gt; jupyter notebook</span><br></pre></td></tr></table></figure>
<h3 id="指定虛擬環境"><a href="#指定虛擬環境" class="headerlink" title="指定虛擬環境"></a>指定虛擬環境</h3><p>點選下拉選單 <code>New</code>，新增一個在 <code>Scrap</code> Kernel 運作的 <code>ipynb</code> 檔案，這樣在該檔案中所執行的環境即為指定的虛擬環境囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Jupyter-%E5%B9%AB-Notebook-%E5%88%87%E6%8F%9B%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83%2Fnew_kernel.png?alt=media&amp;token=ba7901f3-57b2-4242-b46d-1e72f5f2b6f0" alt="新增 ipynb 檔案"><span class="image-caption">新增 ipynb 檔案</span></p>
<p>若想要切換 Kernel，則於 <code>Kenrel → Change Kernel</code> 做選擇，便能指定當前要使用哪一個 Kernel (環境) 來執行程式碼</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Jupyter-%E5%B9%AB-Notebook-%E5%88%87%E6%8F%9B%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83%2Fchange_kernel.png?alt=media&amp;token=27a76a62-a598-4fe9-927f-da6f3cf16dc7" alt="選擇 Kernel"><span class="image-caption">選擇 Kernel</span></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>notebook</tag>
        <tag>venv</tag>
        <tag>kernel</tag>
        <tag>python</tag>
        <tag>virtual</tag>
        <tag>ipy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Jupyter] 改變 Jupyter notebook 預設路徑與瀏覽器</title>
    <url>/2021/06/12/python_jupyter/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Jupyter notebook 是一種很方便開發 <code>Python</code> 程式的軟體，可以一步一步地來執行 Python，近年使用率也逐步提高。而我也是使用 Jupyter notebook 的愛用者，最一開始會遇到幾個問題，就是預設的瀏覽器為什麼是 Edge！要怎麼改？再來是預設路徑要怎麼改到我想放 <code>Python</code> 檔案的地方？</p>
<h2 id="產生環境設定檔案"><a href="#產生環境設定檔案" class="headerlink" title="產生環境設定檔案"></a>產生環境設定檔案</h2><p>Jupyter notebook 的環境設定檔預設不會出現，因此要先下指令產生</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;jupyter notebook --generate-config</span><br><span class="line">Writing default config to: C:\Users\user\.jupyter\jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<p>產出的設定檔會在指令所提示的地方 <code>C:\Users\user\.jupyter\jupyter_notebook_config.py</code></p>
<h2 id="修改預設瀏覽器"><a href="#修改預設瀏覽器" class="headerlink" title="修改預設瀏覽器"></a>修改預設瀏覽器</h2><p>開啟 <code>jupyter_notebook_config.py</code> 並搜尋 <code>c.NotebookApp.browser</code>，找到後先把注解符號刪除，再在 <code>&#39;&#39;</code> 內輸入想要的預設瀏覽器應用程式路徑 (如 chrome.exe)，注意：路徑中有斜線的話，要以 <code>/</code> 代替 <code>\</code>，且最後要 <code>%s</code>。不要忘記存檔！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.browser = <span class="string">u&#x27;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe %s&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="修改預設路徑"><a href="#修改預設路徑" class="headerlink" title="修改預設路徑"></a>修改預設路徑</h2><p>一樣開啟 <code>jupyter_notebook_config.py</code> 並搜尋 <code>c.NotebookApp.notebook_dir</code>，先把注解符號刪除，再在 <code>&#39;&#39;</code> 內輸入想要的預設路徑，注意：路徑中有斜線的話，要以 <code>\\</code> 代替 <code>\</code>。不要忘記存檔！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir = <span class="string">u&#x27;D:\\py&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>在打開 Jupyter notebook 就可以看到使用指定瀏覽器，並且在預設路徑囉！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>default</tag>
        <tag>path</tag>
        <tag>jupyter</tag>
        <tag>notebook</tag>
        <tag>python</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>[LaTeX] Texmaker 點擊跳轉失效</title>
    <url>/2021/06/13/latex_texmaker/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>點擊 pdf 跳轉到相對應的 tex 程式碼是非常好用的工具，若少了這項功能 tex 將變得難以使用。</p>
<h2 id="原因及解決方法"><a href="#原因及解決方法" class="headerlink" title="原因及解決方法"></a>原因及解決方法</h2><p>無法使用這個功能主要有兩個可能原因</p>
<ol>
<li><p>先到「選項」→「設定Texmaker」→「命令」，看看自己使用哪個編譯器，我是用的是 <code>XeLaTeX</code></p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xelatex -synctex=1 -interaction=nonstopmode %.tex</span><br></pre></td></tr></table></figure>
<p> 其中 <code>-synctex=1</code> 是將同步 (Synchronize) 功能打開的關鍵，若無法使用很可能是沒有這個，直接加入即可。</p>
</li>
<li><p>檔案路徑中不要有中文或特殊符號，若有，先將檔案移動到沒有中文或特殊符號的路徑下，並確保檔名也符合此條件。再重新開啟 Texmaker 測試點擊跳轉功能。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>synctex</tag>
        <tag>texmaker</tag>
        <tag>not work</tag>
        <tag>jump</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>[MATLAB] 模仿儀器商附的 IP Finder 並整合進自己的系統裡</title>
    <url>/2021/06/12/ip_finder/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近拿到一台要價不菲的轉檯 (<code>FLIR PTU-E46</code> 以下稱為 PTU)，預計要用在無線通道量測的自動化量測系統中，必須能控制其轉向，並且要能夠知道當前角度。</p>
<p>仔細研究一下 PTU 的<a href="https://www.flir.com/support/products/ptu-e46/#Documents">說明書</a>，發現除了 RS-485/232 外，還可以用網際網路來通訊。之後整個系統中預計會有兩個 PTU，為了能讓電腦少一點連接線甚至少到只需要一條網路線，用網路介面來做通訊媒介當然是首選。</p>
<p>廠商有附一個軟體，可以尋找 PTU 在區網內的 IP，但我發現這個軟體使用上非常碰運氣，怎麼說呢？我執行這找 IP 的程式 10 次，可能只有 1 次找得到 IP，重點是每次 PTU 重機開 IP 就會跑掉，這樣對開發人員或使用者來說都是麻煩。</p>
<p>可能看到這裡，就會有人建議可以指定一個 IP 給儀器，這樣不用每次重新開機都要搜尋。這樣可行是沒有錯的，但是指定 IP 並非人人都會，在未來系統的操作手冊中可能就要大篇幅說明這樣的設定流程。</p>
<p>當要控制一個儀器之前，若要先開一個軟體找到它 IP，然後再記下 IP 輸入進另外一個程式裡，連我自己操作都覺得很麻煩！</p>
<p>因此，我就思考，若能自己寫一個能順利找 IP 的程式，再把此功能鑲嵌在未來控制 PTU 的程式裡，豈不美哉？將找 IP 與控制的程式整合在一起，只需要點點滑鼠就能與 PTU 連線，使用者不需花時間在連線上面，大家都開心。</p>
<p>我的一個原則：自動化系統越少人工輸入的地方越好。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>這的確是個問題，通常儀器商不會給原始碼，加上可以想像程式整合後，使用流程上會有多方便，此問題便成立。首先想想這問題該如何切入？</p>
<p>(開始自言自語) 當然是寫一個跟附的軟體一樣的功能阿！但我沒原始程式碼怎麼辦呢？網路上也找不到其他人有說廠商的尋找 IP 程式怎麼寫。啊！這軟體是用來找 IP 的，那肯定跟網路有關，要能使用網路通訊，必定要發封包，對！關鍵應該就是封包！只是不知道封包的內容是甚麼？印象中我好像有學過用 Wireshark 截取封包來看內容，趕緊去載！</p>
<h2 id="一步步破解"><a href="#一步步破解" class="headerlink" title="一步步破解"></a>一步步破解</h2><h3 id="觀察原軟體所發送封包"><a href="#觀察原軟體所發送封包" class="headerlink" title="觀察原軟體所發送封包"></a>觀察原軟體所發送封包</h3><p>載好就來看看這個軟體到底發甚麼封包才能找到儀器，先開啟 Wireshark 預備好，再執行廠商附的尋找 PTU IP 的程式</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Matlab%20%E6%A8%A1%E4%BB%BF%E5%84%80%E5%99%A8%E5%95%86%E9%99%84%E7%9A%84-IP-finder-%E6%89%BE%E5%87%BA%E5%84%80%E5%99%A8-IP%2Finit_package.png?alt=media&amp;token=d1992f48-ff15-45da-b168-891f581b0381" alt="廠商附的 IP Finder 所發送的封包"><span class="image-caption">廠商附的 IP Finder 所發送的封包</span></p>
<p>登愣～抓到！答案呼之欲出，看起來很神秘的程式，說穿不值一文錢。</p>
<p>原來是直接利用 UDP 廣播 (255.255.255.255) 的方式，來找出儀器的 IP 是多少。第一個廣播封包是由我的電腦 (192.168.0.101) 發出，訊息長度是 10 Bytes，這訊息內容就如同「嗨，我想要找的 PTU 們，你們在哪呀？我的通關密語是 &quot;xxxx&quot;(封包內文)」。</p>
<p>當 PTU 判斷廣播封包的通關密語正確，第二個廣播封包便是由 PTU (192.168.0.100) 這端發出，訊息長度是 17 Bytes，想當然就是回應「你好，我在這！我的通關密語是 &quot;yyyy&quot;(封包內文)」。</p>
<p>這時，當軟體判斷接收到包含通關密語 &quot;yyyy&quot; 的封包之時，該封包的 Source IP 即為儀器的 IP！嘿嘿，短短兩個封包，說明一切！</p>
<p>現在知道這程式是如何運作的，基本上也不需要它的原始碼，只要做出一樣的功能即可。也就是說，若能寫出一個程式，發送廣播封包，讓儀器有反應並且回應一個廣播封包，再去抓此封包的 Source IP 就可以解決這個看似困難的問題。</p>
<p>那現在就來看看他們之間的通關密語是甚麼吧</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Matlab%20%E6%A8%A1%E4%BB%BF%E5%84%80%E5%99%A8%E5%95%86%E9%99%84%E7%9A%84-IP-finder-%E6%89%BE%E5%87%BA%E5%84%80%E5%99%A8-IP%2Fpackage_from_computer.png?alt=media&amp;token=ba4efde9-cdcb-44cf-999e-eb8111b92a10" alt="電腦端發送的通關密語"><span class="image-caption">電腦端發送的通關密語</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Matlab%20%E6%A8%A1%E4%BB%BF%E5%84%80%E5%99%A8%E5%95%86%E9%99%84%E7%9A%84-IP-finder-%E6%89%BE%E5%87%BA%E5%84%80%E5%99%A8-IP%2Fpackage_from_ptu.png?alt=media&amp;token=45d11ed0-06d6-4d1e-8e10-5c31f34385c0" alt="PTU 端回應的通關密語"><span class="image-caption">PTU 端回應的通關密語</span></p>
<p>這下可更清楚了，電腦端先說 <code>DCUD_PING\0</code>，儀器端再回覆 <code>DCUD_PONG\0KERNEL\0</code>。雖然個人覺得儀器端的回覆訊息應該有打錯字，PONG 應該為 PING，但是不管這麼多了，說不定儀器商有發現，只是礙於已經賣出產品，目的能溝通正常運行達到就好，沒想到會被別人在這種情況下看到錯字XD。 (但我後來又想想，應該是兵乓球的 PING PONG，賦予這兩個封包有個來回對答的感覺)</p>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>到目前為止，分析的步驟已經結束，完全清楚主機和儀器們在聊什麼，可藉此抓封包來源 IP 得知儀器所在位置。</p>
<p>現在就要開始實做，因為之後控制的軟體的開發都是以 <code>MATLAB</code> 為主，因此採用 <code>MATLAB</code> 來傳送與接收封包，目前知道此封包是</p>
<ul>
<li>廣播</li>
<li>連接埠是 4930</li>
<li>採用 UDP</li>
<li>包含通關密語 <code>DCUD_PING\0</code></li>
</ul>
<p><code>MATLAB</code> 是一個很強大的軟體，工程上的需求應該都有內建函式能用。找到他關於封包發送接收的物件有 <code>tcpip</code>、<code>udp</code> 等等，但在此只會用到 <code>udp</code> 物件。</p>
<p>先看看在 <code>MATLAB</code> 裡面 <code>help udp</code> 的介紹</p>
<blockquote>
<p>OBJ = udp(&#39;RHOST&#39;, RPORT) constructs an udp object associated with remote host, RHOST, and remote port value, RPORT.</p>
</blockquote>
<p>非常簡單！只要給目的地端 IP (RHOST = 255.255.255.255) 和目的端的連接埠 (RPORT = 4930)，就能建立一個udp物件</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; u <span class="built_in">=</span> udp(<span class="string">&#x27;255.255.255.255&#x27;</span>, <span class="number">4930</span>); <span class="comment">%創建一個 udp 物件叫 u。</span></span><br><span class="line">&gt;&gt; u.Status</span><br><span class="line"></span><br><span class="line">ans <span class="built_in">=</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;closed&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>u.Status</code> 是這個 <code>udp</code> 物件現在的狀態，<code>closed</code> 為還沒連線，<code>open</code> 才為連線成功，物件建立好之後要讓其狀態為 <code>open</code> 才能通訊喔！</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; fopen(u); <span class="comment">%用來打開通訊協定物件的連線狀態</span></span><br><span class="line">&gt;&gt; u.Status</span><br><span class="line"></span><br><span class="line">ans <span class="built_in">=</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;open&#x27;</span></span><br></pre></td></tr></table></figure>
<p>這樣代表連線是可以的。來吧，接下來就是傳一個包含通關密語的封包出去看看。</p>
<p>傳送是用 <code>fwrite</code>、<code>fprintf</code> 與 <code>query</code></p>
<ul>
<li><code>fwrite(udp, A)</code>：將資料 <code>A</code> 用連線好的 <code>udp</code> 物件發送出去。</li>
<li><code>fprintf(udp, A)</code>：與 <code>fwrite</code> 功能一樣，但不同的是會「自動」在 <code>A</code> 最後加上一個換行 (<code>LF</code>) 碼，再傳送出去。</li>
<li><code>query(udp, A)</code>：包含 <code>fprintf</code> 的功能，除此之外，還會抓一個在緩存區的封包進來，若一定時間內都沒有封包能抓，<code>query</code> 會回覆逾時的結果。</li>
</ul>
<p>為了跟廠商軟體所發送的封包一樣，因此選擇不會有添加物的 <code>fwrite</code> 來控制封包內容，實現發送封包。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A <span class="built_in">=</span> [<span class="string">&#x27;DCUD_PING&#x27;</span> char(<span class="number">0</span>)]; <span class="comment">%通關密語 &#x27;DCUD_PING\0&#x27;</span></span><br><span class="line">&gt;&gt; fwrite(u, A);</span><br></pre></td></tr></table></figure>
<p>發送封包後，查看 Wireshark 竟然還是空的，難道哪裡做錯或想錯了嗎？目標 IP 為 255.255.255.255 沒錯呀，摁？這個 IP 是廣播 IP，所以每個區網都有，我的電腦好像有兩三張網卡，但我目前沒有設定要廣播在哪個區網，該不會廣播錯網域了吧？來看看其他網域的封包</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Matlab%20%E6%A8%A1%E4%BB%BF%E5%84%80%E5%99%A8%E5%95%86%E9%99%84%E7%9A%84-IP-finder-%E6%89%BE%E5%87%BA%E5%84%80%E5%99%A8-IP%2Fwrong_broadcast.png?alt=media&amp;token=0ef803a6-d0aa-451c-b542-6f8301e055b7" alt="其他網域的封包攔截"><span class="image-caption">其他網域的封包攔截</span></p>
<p>我猜得果然沒錯，儀器是在 192.168.0.0/24 網域內，而這個廣播封包被送去 169.254.0.0/16，儀器當然不會回應。若我想廣播在 192.168.0.0/24，那我必定要以 192.168.0.100 的身分去做廣播，否則會像上面的情況廣播去別地方。那就看看如何設定 <code>udp</code> 物件吧！在 <code>MATLAB</code> 有一個很好用的函式叫做 <code>get(obj)</code>，他能列出物件obj的所有屬性</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; get(u)</span><br><span class="line">   ByteOrder <span class="built_in">=</span> bigEndian</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   LocalHost <span class="built_in">=</span> </span><br><span class="line">   LocalPort <span class="built_in">=</span> <span class="number">62910</span></span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>又抓到了！在此就可以設定自己的 IP (LocalHost) 與連接埠 (LocalPort)。由於儀器廣播的目標連接埠是 4930，因此 LocalPort 需要設定為 4930，否則就算儀器廣播封包送出，連接埠沒對上也接收不到。</p>
<p>再驗證一遍自己的想法</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; u <span class="built_in">=</span> udp(<span class="string">&#x27;255.255.255.255&#x27;</span>, <span class="number">4930</span>, <span class="string">&#x27;LocalHost&#x27;</span>, <span class="string">&#x27;192.168.0.101&#x27;</span>, <span class="string">&#x27;LocalPort&#x27;</span>, <span class="number">4930</span>);</span><br><span class="line">&gt;&gt; fopen(u);</span><br><span class="line">&gt;&gt; A <span class="built_in">=</span> [<span class="string">&#x27;DCUD_PING&#x27;</span> char(<span class="number">0</span>)];</span><br><span class="line">&gt;&gt; fwrite(u, A);</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Matlab%20%E6%A8%A1%E4%BB%BF%E5%84%80%E5%99%A8%E5%95%86%E9%99%84%E7%9A%84-IP-finder-%E6%89%BE%E5%87%BA%E5%84%80%E5%99%A8-IP%2Ffinal_result.png?alt=media&amp;token=9a34d32c-3f81-46ef-9d40-c577441261e3" alt="自製封包被攔截後的樣子"><span class="image-caption">自製封包被攔截後的樣子</span></p>
<p>有沒有！看起來跟廠商附的軟體發的封包一模一樣！但其實我的目標就是模仿到一樣啦。</p>
<h3 id="收成"><a href="#收成" class="headerlink" title="收成"></a>收成</h3><p>到現在這步，已經可以坐收儀器發出來的封包，在 <code>MATLAB</code> 裡用 <code>fgetl</code>、<code>fgets</code>、<code>fscanf</code> 或 <code>fread</code> 來收封包，這些指令都能回傳封包的來源 IP，所以都可以使用，我選擇使用　<code>fscanf</code></p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [A, count, MSG, DatagramAddress] <span class="built_in">=</span> fscanf(u); <span class="comment">%抓封包</span></span><br><span class="line">&gt;&gt; DatagramAddress</span><br><span class="line"></span><br><span class="line">DatagramAddress <span class="built_in">=</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;192.168.0.100&#x27;</span></span><br></pre></td></tr></table></figure>
<p>喔耶，終於拿到儀器的 IP 了。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>遇到工程問題要解決時，必須先弄清其原理，才有創造的可能。這篇是我個人認為將在課堂上所學到的知識與實際問題應用結合的一個典型範例，在此勉勵自己若將來遇到其它問題，也能夠先弄懂原理再舉一反三。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>finder</tag>
        <tag>equipment</tag>
        <tag>wireshark</tag>
        <tag>matlab</tag>
        <tag>ptu</tag>
        <tag>flir</tag>
      </tags>
  </entry>
  <entry>
    <title>[MATLAB] k-means 演算法說明與實作</title>
    <url>/2021/06/12/matlab_k_means/</url>
    <content><![CDATA[<h2 id="k-means-介紹"><a href="#k-means-介紹" class="headerlink" title="k-means 介紹"></a>k-means 介紹</h2><p><code>k-means</code> 又稱 <code>c-means Clustering</code>，是一種分群演算法，k 表示群集的數量，演算法如下</p>
<ol>
<li>給定一資料集 S，選擇 k 個點當群集中心，也稱為群心。</li>
<li>計算每一資料與各群心距離，資料歸類在與之最短距離的群心那群。</li>
<li>歸類好的資料再算出一個新的群心，通常是使用平均值。</li>
<li>比較新的群心與舊的群心位置是否接近或者固定。</li>
<li>重複 2 ~ 4 直到 4 成立，則分群完畢。</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/MATLAB-k-means-%E6%BC%94%E7%AE%97%E6%B3%95%2Fk_means_alg.png?alt=media&amp;token=954cb2ec-bdda-4a67-a154-8181dde1c09e" alt="k-means 流程圖"><span class="image-caption">k-means 流程圖</span></p>
<h2 id="Pseudo-code"><a href="#Pseudo-code" class="headerlink" title="Pseudo code"></a>Pseudo code</h2><p>Pseudo code 如下，先定義參數</p>
<ul>
<li>Input : 群數 <code>k</code>, 群心 Centers of clusters(<code>kC</code>)</li>
<li>Output：分群結果 <code>team</code></li>
<li>Subroutine：算距離 <code>distFunc</code>, 算新的群心 <code>re_center</code>, 分群 <code>clustering</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main k_means(Database, k, kC, distFunc, re_center, k_clustering)</span><br><span class="line">    While 1</span><br><span class="line">        分群結果 team = clustering(Database, kC, distFunc)</span><br><span class="line">        重新找群心 NewkC = re_center(Database, team, k)</span><br><span class="line">        If 新的群心NewkC和舊群心kC差距可接受 Then 　//差距可接受代表分類完成</span><br><span class="line">            kC = NewkC //更新群心</span><br><span class="line">            break;</span><br><span class="line">        Else //還沒找到滿意的群心就繼續找</span><br><span class="line">            kC = NewkC //更新群心</span><br><span class="line">        End If</span><br><span class="line">    End While 1</span><br><span class="line">    return team, kC //回傳資料群集編號和群心</span><br><span class="line">End k_means</span><br><span class="line">    </span><br><span class="line">sub re_center(Database, team, k)</span><br><span class="line">    For each Cluster of k</span><br><span class="line">        新群心NewkC = 屬於第team(Cluster)組的資料取算術平均數為新的群心</span><br><span class="line">    End For Cluster </span><br><span class="line">    return NewkC</span><br><span class="line">End re_center</span><br><span class="line"></span><br><span class="line">sub clustering(Database, kC)</span><br><span class="line">    tempDist = ? //距離暫存器，?要比所有可能的距離都大</span><br><span class="line">    For each P of Database</span><br><span class="line">        For each C of kC</span><br><span class="line">            距離dist = distFunc(C, P)</span><br><span class="line">            If dist &lt; tempDist Then //紀錄哪個群心最近</span><br><span class="line">                tempDist = dist</span><br><span class="line">                FLAG = C </span><br><span class="line">            End If</span><br><span class="line">        End For C</span><br><span class="line">        將tempDist 變回 ?</span><br><span class="line">        team(P) = FLAG //P點的分類完成</span><br><span class="line">    End For P</span><br><span class="line">    return team</span><br><span class="line">End clustering</span><br></pre></td></tr></table></figure>
<h2 id="MATLAB-code"><a href="#MATLAB-code" class="headerlink" title="MATLAB code"></a>MATLAB code</h2><p><code>MATLAB</code> code</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">function [team kx ky]<span class="built_in">=</span> k_means(x, y, kx, ky, seed_num)</span><br><span class="line">while <span class="number">1</span></span><br><span class="line">    team <span class="built_in">=</span> k_Clustering( x, y, kx, ky);<span class="comment">% 分群</span></span><br><span class="line">    [nkx, nky] <span class="built_in">=</span> k_re_center(x, y, team, seed_num); <span class="comment">%更新新的群心</span></span><br><span class="line">    <span class="built_in">if</span> ( sum(kx <span class="built_in">=</span><span class="built_in">=</span> nkx) <span class="built_in">=</span><span class="built_in">=</span> seed_num ) &amp;&amp; ( sum(ky <span class="built_in">=</span><span class="built_in">=</span> nky) <span class="built_in">=</span><span class="built_in">=</span> seed_num) <span class="comment">%新的群心是否跟舊的一樣</span></span><br><span class="line">        kx <span class="built_in">=</span> nkx;</span><br><span class="line">        ky <span class="built_in">=</span> nky;</span><br><span class="line">        break; <span class="comment">%一樣的話就跳出</span></span><br><span class="line">    <span class="built_in">else</span> <span class="comment">%不一樣就繼續</span></span><br><span class="line">        kx <span class="built_in">=</span> nkx;</span><br><span class="line">        ky <span class="built_in">=</span> nky;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function team <span class="built_in">=</span> k_Clustering(x, y, kx, ky)</span><br><span class="line"><span class="comment">% This is for K-Clustering</span></span><br><span class="line"><span class="comment">% (x,y) are dataset and (kx, ky) are Cluster-center</span></span><br><span class="line"></span><br><span class="line">mid_dis <span class="built_in">=</span> <span class="number">9999999999</span>; <span class="comment">%距離的暫存器</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : length(x); <span class="comment">%總共要判斷 length(x) 個資料</span></span><br><span class="line">    for j <span class="built_in">=</span> <span class="number">1</span> : length(kx); <span class="comment">%總共有 length(kx) 個群集中心</span></span><br><span class="line">        dist <span class="built_in">=</span> k_distFunc( [x(i) y(i)], [kx(j) ky(j)]); <span class="comment">%計算第i個資料和第j個群集中心的距離</span></span><br><span class="line">        <span class="built_in">if</span> dist &lt; mid_dis <span class="comment">%判斷距離哪個群集中心較近</span></span><br><span class="line">            mid_dis <span class="built_in">=</span> dist; <span class="comment">%更新距離的暫存器</span></span><br><span class="line">            FLAG <span class="built_in">=</span> j; <span class="comment">%紀錄現在距離哪個群集中心最近</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    mid_dis <span class="built_in">=</span> <span class="number">9999999999</span>; <span class="comment">%距離的暫存器變回初始值</span></span><br><span class="line">    team(i,<span class="number">1</span>) <span class="built_in">=</span> FLAG; <span class="comment">%第 i 個資料屬於第 FLAG 個群集</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function [kx, ky] <span class="built_in">=</span> k_re_center( x, y, team, seed_num)</span><br><span class="line"><span class="comment">% re-find clustered data for new cluster center</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : seed_num</span><br><span class="line">    kx(i) <span class="built_in">=</span> sum(x(team <span class="built_in">=</span><span class="built_in">=</span> i )) / sum(team <span class="built_in">=</span><span class="built_in">=</span> i);</span><br><span class="line">    ky(i) <span class="built_in">=</span> sum(y(team <span class="built_in">=</span><span class="built_in">=</span> i )) / sum(team <span class="built_in">=</span><span class="built_in">=</span> i);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function D <span class="built_in">=</span> k_distFunc(P1, P2)</span><br><span class="line"><span class="comment">% This is for finding Distance Between 2D Points</span></span><br><span class="line"><span class="comment">% Input can be an vector</span></span><br><span class="line">D <span class="built_in">=</span> norm(P1 - P2);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>k</tag>
        <tag>means</tag>
        <tag>pseudo</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>[Math] 以移位運算優化除數為 2 的冪次方的除法</title>
    <url>/2021/06/15/math_2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除法指令在 CPU 中的執行周期相較於其它運算 (加/減/乘) 還要來得長，所以會盡可能的找替代方案來算出除法結果。這裡討論的是，當除以一個 2 的冪次方數時要怎麼減化過程，特別是被除數為負數時的情況。</p>
<h2 id="問題敘述"><a href="#問題敘述" class="headerlink" title="問題敘述"></a>問題敘述</h2><p>基本上 $x\gg k$ 等同於 $\dfrac{x}{2^k}$，但這個結果只能保證在 $x \geq 0$ 時是對的，若在 $x &lt; 0$ 時，可就不一定了！舉例來說，若 $x=-12345$ 且 $k=4$</p>
<p>以除法運算來看，取整數後即 $-771$。</p>
<script type="math/tex; mode=display">x\gg k=-12345\gg 4=\dfrac{-12345}{2^4}=-771.5625</script><p>在以位元運算來看</p>
<script type="math/tex; mode=display">-12345_{10}\gg 4_{10}=1100\_1111\_1100\_0111_2 \gg 4_{10} = 1111\_1100\_1111\_1100_2 = -772</script><p>這與我們想要的結果 ($-771$) 不一樣，因為移位運算後的結果都是取 <code>floor</code> 後的值，即</p>
<script type="math/tex; mode=display">x \gg k = floor(\dfrac{x}{2^k})</script><p>當 $x \geq 0$，我們要得到整數部份就要取 <code>floor</code>，這與移位運算的特性一致；而當 $x &lt; 0$ 時，我們要得到整數部份就要取 <code>ceil</code>，但此時移位運算是取 <code>floor</code>，所以就會有誤。</p>
<p>因此，我們需要一個函數，當 $x &lt; 0$ 時作移位運算後結果為 $ceil(\dfrac{x}{2^k})$ 的演算法</p>
<script type="math/tex; mode=display">(x + (2^k - 1)) >> k</script><h2 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h2><p>目標</p>
<script type="math/tex; mode=display">ceil (\dfrac{x}{2^k}) = (x + (2^k - 1)) \gg k</script><p>要證明上式，必須先證明下式成立，</p>
<script type="math/tex; mode=display">ceil(\dfrac{x}{y})=floor(\dfrac{x+y-1}{y}), \ \textrm{if}\ x\ \in \mathbb{Z}\ \textrm{and}\ y\ \in \mathbb{Z^+}</script><p>令</p>
<script type="math/tex; mode=display">x=qy+r,\ 0 \leq r\leq y-1</script><p>q 為除法商數且 r 為除法餘數。再將此試代入目標等式右邊</p>
<script type="math/tex; mode=display">\dfrac{x+y-1}{y}=\dfrac{qy+r+y-1}{y}=q+\dfrac{r+y-1}{y}</script><p>討論：</p>
<p><code>case 1</code>：如果 $x$ 可以被 $y$ 整除，則 $r=0$</p>
<script type="math/tex; mode=display">floor(\dfrac{x+y-1}{y})=floor(q+\dfrac{y-1}{y})=q=ceil(\dfrac{x}{y})</script><p><code>case 2</code>：如果 $x$ 不能被 $y$ 整除，則 $1\leq r\leq y-1$</p>
<script type="math/tex; mode=display">\dfrac{y}{y}\leq \dfrac{r+y-1}{y}\leq \dfrac{2y-2}{y}</script><script type="math/tex; mode=display">1\leq\dfrac{r+y-1}{y}<2</script><script type="math/tex; mode=display">floor(\dfrac{x+y-1}{y})=floor(q+\dfrac{r+y-1}{y})=q+1=ceil(\dfrac{x}{y})</script><p>最後，再利用這個等式，可以得到若 <code>x &lt; 0</code></p>
<script type="math/tex; mode=display">ceil (\dfrac{x}{2^k}) = floor ( \dfrac{x + 2^k - 1}{2^k}) = (x + (2^k - 1)) \gg k</script><p>得證</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://www.itread01.com/content/1548192791.html">計算機中如何實現除數是2的冪次的除法</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>shift</tag>
        <tag>bit</tag>
        <tag>division</tag>
        <tag>power of 2</tag>
      </tags>
  </entry>
  <entry>
    <title>[Menu] 將程式添加於 Windows 右鍵清單</title>
    <url>/2021/10/08/windows_right_click_menu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>右鍵清單是很常用到的功能，例如：透過右鍵點擊壓縮檔並使用 7-Zip 解壓縮檔案、重新整理桌面/檔案總管、開啟 Git 終端視窗……等等。有些程式使用到的頻率很高，但預設沒有出現在右鍵清單內，這時我們便可以透過手動添加清單項目的方式來達到這個目的。</p>
<h2 id="右鍵清單分類"><a href="#右鍵清單分類" class="headerlink" title="右鍵清單分類"></a>右鍵清單分類</h2><p>右鍵清單主要分為兩種，各有其使用情境</p>
<div class="tabs" id="清單介紹"><ul class="nav-tabs"><li class="tab active"><a href="#清單介紹-1">右鍵點擊桌面/檔案總管的清單</a></li><li class="tab"><a href="#清單介紹-2">右鍵點擊檔案的清單</a></li></ul><div class="tab-content"><div class="tab-pane active" id="清單介紹-1"><p>通常會將<strong>右鍵點擊的目錄路徑</strong>作為參數，傳給被開啟的應用程式去執行下一步動作。<br>    例如：點擊桌面開啟 Terminal，Terminal 的工作目錄就會為桌面的路徑(圖片中範例為 <code>C:\Users\qtuicmn222\Desktop</code>)<br>    <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FcommandTerminal.png?alt=media&amp;token=59b7a8eb-5aee-413c-b33c-daa565464068" alt="右鍵點擊桌面開啟 Terminal"><span class="image-caption">右鍵點擊桌面開啟 Terminal</span></p></div><div class="tab-pane" id="清單介紹-2"><p>通常會將<strong>被右鍵點擊的檔案</strong>作為參數，傳給被開啟的應用程式去執行下一步動作。<br>    例如：用 16 進位查看軟體 Hiew 開啟一個 zip 檔案，這樣的設定可以讓我們不論想查看的檔案在哪裡，只需要找到檔案並點擊右鍵，即可馬上查看資訊！<br>    <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FhiewRightClickOn.png?alt=media&amp;token=367da6af-e4fc-4acb-ab87-e2c5a7bc8721" alt="右鍵點擊檔案並用 Hiew 開啟"><span class="image-caption">右鍵點擊檔案並用 Hiew 開啟</span></p></div></div></div>
<div class="note info">
            <p>這裡說的<strong>通常</strong>真的只是通常而已，不一定要照這樣做，但如此一來，似乎就沒有將程式綁在右鍵清單內的必要性。</p>
          </div>
<h2 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h2><p>在執行以下設定之前，先透過 <code>Windows + R → regedit</code> 開啟 <strong>Registry Editor</strong>。</p>
<div class="tabs" id="清單"><ul class="nav-tabs"><li class="tab active"><a href="#清單-1">右鍵點擊桌面/檔案總管的清單</a></li><li class="tab"><a href="#清單-2">右鍵點擊檔案的清單</a></li></ul><div class="tab-content"><div class="tab-pane active" id="清單-1"><p>在 <strong>Registry Editor</strong> 視窗中，到 <code>\HKEY_CLASSES_ROOT\Directory\Background\shell</code> 路徑下新增機碼(此例為 <code>Hiew</code>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FbackgroundKey.png?alt=media&amp;token=df961c87-d084-488c-ba7b-67178c20e0e8" alt="新增一個右鍵清單的項目"><span class="image-caption">新增一個右鍵清單的項目</span></p>
<p>再將<strong>預設值</strong>修改為想在清單中看到的名稱(此例為 <code>Hiew v8</code>)，若無設定，顯示出來的值即為上一步所設定的機碼值。並新增一個名稱為 <code>Icon</code> 的字串值，其資料設為應用程式路徑(此例為 <code>D:\Program\hiew\hiew32.exe</code>)，其對應到的功能是在右鍵清單中顯示出來的圖示</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FbackgroundIcon.png?alt=media&amp;token=5b20206e-16b9-483d-91e8-b1bde0f0e85c" alt="設定項目於清單中的外觀"><span class="image-caption">設定項目於清單中的外觀</span></p>
<p>到目前為止所設定的是應用程式於清單中的外觀，若要讓清單能作用，則需要在剛新增的項目中(此例為 <code>Hiew</code>)增加一個名為 <code>command</code> 的機碼，並將其預設值設為應用程式的路徑(此例為 <code>D:\Program\hiew\hiew32.exe</code>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FbackgroundCommand.png?alt=media&amp;token=39e60b2c-c300-40ff-9e39-6257032a73c8" alt="設定項目的開啟指令"><span class="image-caption">設定項目的開啟指令</span></p>
<p>最後，在桌面或檔案總管中點擊右鍵，即可使用我們所設定的應用程式項目</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FbackgroundFinal.png?alt=media&amp;token=630efa65-d50a-4cd1-82ee-8c2c83a40d22" alt="新增一個項目於右鍵點擊桌面/檔案總管的清單完成"><span class="image-caption">新增一個項目於右鍵點擊桌面/檔案總管的清單完成</span></p>
<p>可將下方程式碼存成以 <code>reg</code> 為附檔名的文字檔(例如：<code>hiew.reg</code>)，雙擊 <code>reg</code> 檔並執行後所得到的結果與上面所述是相同的，記得將路徑改為正確的應用程式路徑，且路徑中的反斜線(<strong>\</strong>)需要各別多加一個反斜線來跳脫。詳細編寫 <code>reg</code> 檔案的語法可參考 <a href="https://support.microsoft.com/en-us/topic/how-to-add-modify-or-delete-registry-subkeys-and-values-by-using-a-reg-file-9c7f37cf-a5e9-e1cd-c4fa-2a26218a1a23">How to add, modify, or delete registry subkeys and values by using a .reg file</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Hiew]</span><br><span class="line"><span class="meta">@=<span class="string">&quot;Hiew v8&quot;</span></span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span>=<span class="string">&quot;D:\\Program\\hiew\\hiew32.exe&quot;</span></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Hiew\command]</span><br><span class="line"><span class="meta">@=<span class="string">&quot;D:\\Program\\hiew\\hiew32.exe&quot;</span></span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="清單-2"><p>在 <strong>Registry Editor</strong> 視窗中，到 <code>\HKEY_CLASSES_ROOT\*\shell</code> 路徑下新增機碼(此例為 <code>Hiew</code>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FstarKey.png?alt=media&amp;token=bfabe71b-6e64-4af7-aab9-b0600fc19063" alt="新增一個右鍵清單的項目"><span class="image-caption">新增一個右鍵清單的項目</span></p>
<p>再將<strong>預設值</strong>修改為想在清單中看到的名稱(此例為 <code>Hiew v8</code>)，若無設定，顯示出來的值即為上一步所設定的機碼值。並新增一個名稱為 <code>Icon</code> 的字串值，其資料設為應用程式路徑(此例為 <code>D:\Program\hiew\hiew32.exe</code>)，其對應到的功能是在右鍵清單中顯示出來的圖示</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FstarIcon.png?alt=media&amp;token=b99b983e-39e8-4f84-98f6-db18fb62b1de" alt="設定項目於清單中的外觀"><span class="image-caption">設定項目於清單中的外觀</span></p>
<p>到目前為止所設定的是應用程式於清單中的外觀，若要讓清單能作用，則需要在剛新增的項目中(此例為 <code>Hiew</code>)增加一個名為 <code>command</code> 的機碼，並將其預設值設為應用程式路徑且帶一個 <code>%1</code> 作為參數的形式(此例為 <code>D:\Program\hiew\hiew32.exe %1</code>)，其中 <code>%1</code> 即為<strong>被右鍵點擊的檔案</strong></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FstarCommand.png?alt=media&amp;token=70a5d93c-d1ce-444c-b2b2-aa14040e66a5" alt="設定項目的開啟指令"><span class="image-caption">設定項目的開啟指令</span></p>
<p>最後，對任意檔案點擊右鍵，即可使用我們所設定的應用程式項目</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Menu-%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%B6%81%E5%AE%9A%E6%96%BC-Windows-%E5%8F%B3%E9%8D%B5%E6%B8%85%E5%96%AE%2FstarFinal.png?alt=media&amp;token=482b9ac3-c4e8-4b50-b6e5-35ece3382d43" alt="新增一個項目於右鍵點擊檔案的清單完成"><span class="image-caption">新增一個項目於右鍵點擊檔案的清單完成</span></p>
<p>可將下方程式碼存成以 <code>reg</code> 為附檔名的文字檔(例如：<code>hiew.reg</code>)，雙擊 <code>reg</code> 檔並執行後所得到的結果與上面所述是相同的，記得將路徑改為正確的應用程式路徑，且路徑中的反斜線(<strong>\</strong>)需要各別多加一個反斜線來跳脫。詳細編寫 <code>reg</code> 檔案的語法可參考 <a href="https://support.microsoft.com/en-us/topic/how-to-add-modify-or-delete-registry-subkeys-and-values-by-using-a-reg-file-9c7f37cf-a5e9-e1cd-c4fa-2a26218a1a23">How to add, modify, or delete registry subkeys and values by using a .reg file</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\Hiew]</span><br><span class="line"><span class="meta">@=<span class="string">&quot;Hiew v8&quot;</span></span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span>=<span class="string">&quot;D:\\Program\\hiew\\hiew32.exe&quot;</span></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\Hiew\command]</span><br><span class="line"><span class="meta">@=<span class="string">&quot;D:\\Program\\hiew\\hiew32.exe %1&quot;</span></span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://www.howtogeek.com/howto/windows-vista/add-any-application-to-the-desktop-right-click-menu-in-vista/">How to Add Any Application to the Windows Desktop Right-Click Menu</a></p>
</li>
<li><p><a href="https://thegeekpage.com/add-any-program-to-right-click-context-menu/">How to add any program to right click context menu</a></p>
</li>
<li><p><a href="https://superuser.com/questions/136838/which-special-variables-are-available-when-writing-a-shell-command-for-a-context">Which special variables are available when writing a shell command for a context menu</a></p>
</li>
<li><p><a href="https://support.microsoft.com/en-us/topic/how-to-add-modify-or-delete-registry-subkeys-and-values-by-using-a-reg-file-9c7f37cf-a5e9-e1cd-c4fa-2a26218a1a23">How to add, modify, or delete registry subkeys and values by using a .reg file</a></p>
</li>
</ol>
<!-- markdownlint-disable MD033 -->
<script>
    tabs = [];
    document.querySelectorAll('.nav-tabs .tab a').forEach((element) => {
        arr = element.href.split('-');
        index = arr[arr.length - 1]
        if (tabs[index] === undefined)
            tabs[index] = []
        tabs[index].push(element);
    });
    tabs.forEach((elements) => {
        elements.forEach((element) => {
            element.addEventListener('click', () => {
                elements.forEach((e) => {
                    e.click()
                })
            })
        });
    });
</script>

<!-- markdownlint-restore MD033 -->
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>click</tag>
        <tag>menu</tag>
        <tag>right</tag>
        <tag>registry</tag>
        <tag>editor</tag>
        <tag>exe</tag>
        <tag>bind</tag>
        <tag>program</tag>
        <tag>7zip</tag>
        <tag>hiew</tag>
        <tag>regedit</tag>
        <tag>reg</tag>
      </tags>
  </entry>
  <entry>
    <title>[Mount] 掛載與卸載一個 iso 光碟映像檔</title>
    <url>/2021/06/17/mount_iso/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在很多程式的安裝檔都是直接提供 iso 光碟映像檔而不是實體光碟，若想要在 Ubuntu 掛載與卸載進而可以讀取使用，就必須學學 <code>mount</code>/<code>umount</code> 這組指令。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="掛載-iso-檔案"><a href="#掛載-iso-檔案" class="headerlink" title="掛載 iso 檔案"></a>掛載 iso 檔案</h2><p>掛載都是在 <code>/media</code> 目錄底下，因此先在 <code>/media</code> 新增一個目錄，要用來掛載 iso 檔案，藉由此目錄才能存取裡面 iso 檔案的內容，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo <span class="built_in">mkdir</span> /media/iso <span class="comment"># 目錄名稱可以任意更改</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>mount</code> 指令將 iso 檔案掛載到 <code>/media/iso</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo mount -o loop ~/Downloads/*.iso /media/iso             <span class="comment"># * 為檔案名稱，修改為自己 iso 檔的檔名</span></span><br><span class="line">mount: /media/iso: WARNING: device write-protected, mounted read-only. <span class="comment"># 看到這行代表掛載完成</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-o loop</code>：使用 loop device 來掛載</li>
</ul>
<p>完成之後 <code>/media/iso</code> 目錄下就會有 iso 檔案內的檔案</p>
<h2 id="卸載-iso-檔案"><a href="#卸載-iso-檔案" class="headerlink" title="卸載 iso 檔案"></a>卸載 iso 檔案</h2><p>使用 umount 指令即可，執行完指令並確定 <code>/media/iso</code> 目錄下已經無檔案 (目錄還會在)，代表完成卸載</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo umount -l /media/iso <span class="comment">#要卸載的目錄</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>18.04</tag>
        <tag>mount</tag>
        <tag>unmount</tag>
        <tag>iso</tag>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title>[MySQL] CentOS 8 安裝 MySQL 8.0 與更改 root 密碼</title>
    <url>/2021/06/18/mysql_centos_mysql_8_0_root/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 應該是使用 PHP 第一個會碰到的資料庫，通常會包在一起來教學。記錄一下如何在 CentOS 8 單獨安裝 MySQL 吧！</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
</ul>
<h2 id="安裝與啟動-MySQL"><a href="#安裝與啟動-MySQL" class="headerlink" title="安裝與啟動 MySQL"></a>安裝與啟動 MySQL</h2><p>在 CentOS 8 以後 <code>yum</code> 漸漸的會被 <code>dnf</code> 取代，因此都會以 <code>dnf</code> 來做套件安裝移除的動作。開啟 Terminal，安裝 MySQL</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]<span class="comment"># sudo dnf install -y mysql-server</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Installed:</span><br><span class="line">  mariadb-connector-c-config-3.0.7-1.el8.noarch                         mecab-0.996-1.module_el8.0.0+41+ca30bab6.9.x86_64                     mysql-8.0.17-3.module_el8.0.0+181+899d6349.x86_64                    </span><br><span class="line">  mysql-common-8.0.17-3.module_el8.0.0+181+899d6349.x86_64              mysql-errmsg-8.0.17-3.module_el8.0.0+181+899d6349.x86_64              mysql-server-8.0.17-3.module_el8.0.0+181+899d6349.x86_64             </span><br><span class="line">  protobuf-lite-3.5.0-7.el8.x86_64                                     </span><br><span class="line"></span><br><span class="line">Complete! <span class="comment"># 看到這行就代表安裝完成囉</span></span><br></pre></td></tr></table></figure>
<p>CentOS 中的服務安裝後預設都是不開啟的，所以要手動開啟，看到 <code>active (running)</code> 就代表 MySQL 正在運作囉！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl start mysqld.service   <span class="comment"># 馬上開啟mysql daeman(MySQL服務)</span></span><br><span class="line"></span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> mysqld.service  <span class="comment"># 之後開機也要自動開啟MySQL服務</span></span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/mysqld.service → /usr/lib/systemd/system/mysqld.service.</span><br><span class="line"></span><br><span class="line">[user@localhost ~]$ sudo systemctl status mysqld.service  <span class="comment"># 查詢MySQL服務的狀態</span></span><br><span class="line">● mysqld.service - MySQL 8.0 database server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2020-09-15 12:56:47 CST; 1min 37s ago</span><br><span class="line"> Main PID: 8171 (mysqld)</span><br><span class="line">   Status: <span class="string">&quot;Server is operational&quot;</span></span><br><span class="line">    Tasks: 38 (<span class="built_in">limit</span>: 49448)</span><br><span class="line">   Memory: 376.2M</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─8171 /usr/libexec/mysqld --basedir=/usr</span><br><span class="line"></span><br><span class="line">Sep 15 12:56:46 localhost.localdomain systemd[1]: Starting MySQL 8.0 database server...</span><br><span class="line">Sep 15 12:56:47 localhost.localdomain systemd[1]: Started MySQL 8.0 database server.</span><br></pre></td></tr></table></figure>
<h2 id="設定-root-密碼"><a href="#設定-root-密碼" class="headerlink" title="設定 root 密碼"></a>設定 root 密碼</h2><div class="tabs" id="設定密碼"><ul class="nav-tabs"><li class="tab active"><a href="#設定密碼-1">簡易方法</a></li><li class="tab"><a href="#設定密碼-2">進階方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="設定密碼-1"><p>可以使用 <code>mysql_secure_installation</code> 來設定與安全性相關的設定，這個設定工具透過互動式問答幫助管理者設定 root 密碼、移除匿名登入帳號、禁止 root 從遠端登入、移除測試用的資料庫。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="設定密碼-2"><p>root 帳號的密碼預設是無，為了安全起見，登入後一定要改密碼！先登入 ＭySQL</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mysql -u root   <span class="comment"># ← 沒有密碼所以不用參數 -p</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection <span class="built_in">id</span> is 10</span><br><span class="line">Server version: 8.0.17 Source distribution</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br></pre></td></tr></table></figure>
<p>使用 SQL 修改密碼</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;  # password 改為要設定的密碼</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="登入-MySQL"><a href="#登入-MySQL" class="headerlink" title="登入 MySQL"></a>登入 MySQL</h2><p>用密碼登入 MySQL ，看到 <code>Welcome to the MySQL monitor.</code> 就成功囉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mysql -u root -p</span><br><span class="line">Enter password:        <span class="comment"># ← 這裡輸入剛設定的密碼</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="忘記-root-密碼"><a href="#忘記-root-密碼" class="headerlink" title="忘記 root 密碼"></a>忘記 root 密碼</h2><p>若是之前有裝過 MySQL，現在不記得 root 的密碼，請參考 <a href="https://ckahiaku.wordpress.com/2018/03/30/how-to-remove-mysql-entirely-from-linux-system/">HOW TO REMOVE MYSQL ENTIRELY FROM LINUX SYSTEM(CENTOS)</a> 先清除舊的 MySQL 資料再安裝，預設密碼就會為空。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>mysql</tag>
        <tag>8.2</tag>
        <tag>8</tag>
        <tag>root</tag>
        <tag>password</tag>
        <tag>change</tag>
        <tag>forget</tag>
      </tags>
  </entry>
  <entry>
    <title>[NFC] NDEF 解析</title>
    <url>/2022/03/08/nfc_ndef/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RFID (Radio Frequency IDentification) 是一種身份識別技術，採用無線通訊對目標標籤進行識別與讀寫；NFC (Near-field communication) 算是 RFID 的一種應用情境，但其通訊距離較短，適合用在注重安全性的應用上，例如：電子支付等。NDEF (NFC Data Exchange Format) 為 NFC 的主要資料格式，使 NFC 標籤 (Tag) 與讀取器 (Reader) 不會受到廠商的限制。這篇文章主要舉例說明如何解讀 NDEF。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NDEF-%E8%A7%A3%E6%9E%90%2Fscenario.png?alt=media&amp;token=e86f30da-ddca-428d-a49a-874c5b71a1ce" alt="NFC 與 RFIC 的關係"><span class="image-caption">NFC 與 RFIC 的關係</span></p>
<h2 id="NDEF-是什麼？"><a href="#NDEF-是什麼？" class="headerlink" title="NDEF 是什麼？"></a>NDEF 是什麼？</h2><p>NDEF 全名為 NFC Data Exchange Format，簡單來說 NDEF 是一種 NFC 協會定義出來的資料格式，全球通用的標準，讓所有支援 NDEF 的 Tag 與 Reader 可以相互溝通！手機的 NFC Reader 與 NFC Tag 之所以可以達到許多互動，就是依靠解析存放在 Tag 記憶體內 NDEF 訊息區塊的資料，取得對應的指示並執行相關操作。</p>
<h3 id="NDEF-Message-vs-NDEF-Record"><a href="#NDEF-Message-vs-NDEF-Record" class="headerlink" title="NDEF Message vs NDEF Record"></a>NDEF Message vs NDEF Record</h3><p>NDEF 可以根據粒度分為 NDEF Message 與 NDEF Record</p>
<ul>
<li>每一個 NDEF 就是一個 NDEF Message。</li>
<li>而每個 NDEF 可包含多個 NDEF Record。</li>
<li><p>NDEF Record 中的 Payload 才是真正的資料所在。</p>
<p>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NDEF-%E8%A7%A3%E6%9E%90%2Fndef_structure.png?alt=media&amp;token=9c25d8e1-555f-41f0-b1e9-861a28824a39" alt="NDEF 結構示意圖"><span class="image-caption">NDEF 結構示意圖</span></p>
</li>
</ul>
<h2 id="NDEF-Record-格式解析"><a href="#NDEF-Record-格式解析" class="headerlink" title="NDEF Record 格式解析"></a>NDEF Record 格式解析</h2><p>詳細 NDEF 格式說明參考 <a href="https://austinblackstoneengineering.com/nfc-p2p-basics/">NFC P2P NDEF Basics</a> 如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The fields <span class="keyword">in</span> an NDEF Message header are as follows:</span><br><span class="line"> ______________________________</span><br><span class="line">| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0|  </span><br><span class="line">|------------------------------|</span><br><span class="line">| MB| ME| CF| SR| IL|    TNF   |  NDEF StatusByte, 1 byte</span><br><span class="line">|------------------------------|</span><br><span class="line">|        TYPE_LENGTH           |  1 byte, hex value</span><br><span class="line">|------------------------------|</span><br><span class="line">|        PAYLOAD_LENGTH        |  1 or 4 bytes (determined by SR) (LSB first)</span><br><span class="line">|------------------------------|</span><br><span class="line">|        ID_LENGTH             |  0 or 1 bytes (determined by IL)</span><br><span class="line">|------------------------------|</span><br><span class="line">|        TYPE                  |  2 or 5 bytes (determined by TYPE_LENGTH)</span><br><span class="line">|------------------------------|</span><br><span class="line">|        ID                    |  0 or 1 byte  (determined by IL &amp; ID_LENGTH)</span><br><span class="line">|------------------------------|</span><br><span class="line">|        PAYLOAD               |  X bytes (determined by PAYLOAD_LENGTH)</span><br><span class="line">|------------------------------|</span><br></pre></td></tr></table></figure>
<p>這裡直接透過一個實際例子來說明，最容易理解。</p>
<p>以 NDEF 記錄字串 <code>AEIOU</code>，採用 RTD (Record Type Definition) 的 Text Record 格式為 <code>03 0c d1 01 08 54 02 7a 68 41 45 49 4f 55</code>。其中 <code>Record = 藍 (Header) + 紅 (Payload)</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NDEF-%E8%A7%A3%E6%9E%90%2Fndef_parse.png?alt=media&amp;token=017935c8-c193-4e4a-b71e-01df10dfe6e4" alt="NDEF 解析範例"><span class="image-caption">NDEF 解析範例</span></p>
<p>解析：</p>
<ul>
<li>黃色 <code>03</code> 為 NDEF Message <a href="https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef#tlv-blocks-607781-33">TLV</a> 的 NDEF 開頭。</li>
<li>黃色 <code>0c</code> 為 NDEF Record 的長度 (藍色 + 紅色) 的長度，為 12 bytes。</li>
<li>藍色 <code>d1</code> 為 Header 第一個 Byte，即 NDEF StatusByte，<code>d1 = 1101_0001b</code> 對應到 Record 格式示意圖，可知 <code>MB</code>, <code>ME</code>, <code>SR</code> 都為 1，<code>CL</code>, <code>IL</code> 為 0，<code>TNF</code> 為 1 (代表 RTD)。</li>
<li>藍色 <code>01</code> 表示後面的 Type 是用 1 個 byte 來記錄。</li>
<li>藍色 <code>08</code> 表式紅色 Payload 的長度為 8 個 bytes。</li>
<li>因為 <code>IL</code> 為 0，所以與 ID 有關的 Byte 都不存在。</li>
<li>藍色 <code>54</code> 為 T 的 ASCII code，表示為 RTD 的 Text Record <code>T</code>，這要對應到 <code>TNF</code> 為 1，才會是 RTD 的 <code>T</code>。</li>
<li>參考下面表格解析紅色 <code>02 7a 68</code> 分別是 Record StatusByte 與 language code。紅色 <code>02</code> 表示後面為 UTF-8 編碼，且 language code 為 2 個 bytes，也就是 <code>7a 68</code>，這兩個代表 <code>zh</code> 的 ASCII code (英文的 ASCII 與 UTF-8 一樣)。  <!-- markdownlint-disable MD031 -->
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ______________________________</span><br><span class="line">| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0|  </span><br><span class="line">|------------------------------|</span><br><span class="line">|UTF| 0 | Length of Lang Code  |  1 byte Text Record StatusByte</span><br><span class="line">|------------------------------|</span><br><span class="line">|          Lang Code           |  2 or 5 byte, multi-byte language code</span><br><span class="line">|------------------------------|</span><br><span class="line">|             Text             |  Multiple Bytes encoded <span class="keyword">in</span> UTF-8 or UTF-16</span><br><span class="line">|------------------------------|</span><br></pre></td></tr></table></figure>
  <!-- markdownlint-restore MD031 --></li>
<li>最後 <code>41 45 49 4f 55</code> 即為實際訊息 <code>AEIOU</code> 的 ASCII code。</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>NDEF 僅僅是資料格式，然而 NFC Tag 內不僅僅是只有資料而已，還有 Tag 本身的一些資訊，例如：UID/SN、lock bytes 等等。若讀者有興趣知道 NDEF 在 Tag 記憶體中的哪一個位置，歡迎參考 <a href="/2022/03/09/nfc_ntag213/">[NFC] NTAG213 記憶體解析</a>。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://sls.weco.net/node/26010">手機與穿戴式裝置連結透過NFC</a></p>
</li>
<li><p><a href="https://austinblackstoneengineering.com/nfc-p2p-basics/">NFC P2P NDEF Basics</a></p>
</li>
<li><p><a href="https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef">About the NDEF Format</a></p>
</li>
<li><p><a href="http://nfctoday.blogspot.com/2014/11/ch02-13-nfc-type-2-tag.html">NFC TYPE 2 TAG 概觀</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>nfc</tag>
        <tag>ndef</tag>
        <tag>iso14443</tag>
        <tag>iso15693</tag>
        <tag>rfid</tag>
        <tag>tag</tag>
        <tag>reader</tag>
        <tag>message</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title>[NFC] NTAG213 記憶體解析</title>
    <url>/2022/03/09/nfc_ntag213/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>若要撰寫與 NFC 讀取相關的應用，需要先了解對應的 Tag 內存使用方式，這篇文章會以市面上常見的 NFC 晶片 NTAG213 來做說明，透過範例解讀讓讀者更容易理解 Datasheet 內的敘述。</p>
<h2 id="範例解讀"><a href="#範例解讀" class="headerlink" title="範例解讀"></a>範例解讀</h2><p>參考 NXP 大廠產品 NTAG213 的 <a href="https://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf">Datasheet</a>，該晶片支援 ISO14443-3A 規範，各個欄位的介紹與功用請直接到文件中查看，較為詳細！在此只是舉實例來解讀從記憶體讀出來的資料，相信閱讀 Datasheet 時搭配此文章會較容易了解其中的敘述。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NTAG213-%E8%A8%98%E6%86%B6%E9%AB%94%E8%A7%A3%E6%9E%90%2Fmemory_organization.png?alt=media&amp;token=9a1686fd-7ff9-4501-8a12-08062e75be06" alt="NTAG213 內部記憶體配置圖"><span class="image-caption">NTAG213 內部記憶體配置圖</span></p>
<p>以下是從實體 NTAG213 讀出來的資料，接下來以此資料作為範例來解說</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00h</td>
<td style="text-align:center">04</td>
<td style="text-align:center">67</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8b</td>
</tr>
<tr>
<td style="text-align:center">01h</td>
<td style="text-align:center">12</td>
<td style="text-align:center">ee</td>
<td style="text-align:center">64</td>
<td style="text-align:center">81</td>
</tr>
<tr>
<td style="text-align:center">02h</td>
<td style="text-align:center">19</td>
<td style="text-align:center">48</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">03h</td>
<td style="text-align:center">e1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">04h</td>
<td style="text-align:center">03</td>
<td style="text-align:center">0c</td>
<td style="text-align:center">d1</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">05h</td>
<td style="text-align:center">08</td>
<td style="text-align:center">54</td>
<td style="text-align:center">02</td>
<td style="text-align:center">7a</td>
</tr>
<tr>
<td style="text-align:center">06h</td>
<td style="text-align:center">68</td>
<td style="text-align:center">41</td>
<td style="text-align:center">45</td>
<td style="text-align:center">49</td>
</tr>
<tr>
<td style="text-align:center">07h</td>
<td style="text-align:center">4f</td>
<td style="text-align:center">55</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解析-UID-SN-Serial-Number"><a href="#解析-UID-SN-Serial-Number" class="headerlink" title="解析 UID/SN (Serial Number)"></a>解析 UID/SN (Serial Number)</h2><p>UID/SN 資料的所在的範圍為 Page 0, Byte 0 ～ Page 2, Byte 0  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00h</td>
<td style="text-align:center">04</td>
<td style="text-align:center">67</td>
<td style="text-align:center">60</td>
<td style="text-align:center">8b</td>
</tr>
<tr>
<td style="text-align:center">01h</td>
<td style="text-align:center">12</td>
<td style="text-align:center">ee</td>
<td style="text-align:center">64</td>
<td style="text-align:center">81</td>
</tr>
<tr>
<td style="text-align:center">02h</td>
<td style="text-align:center">19</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>前 9 bytes 是 UID (7 bytes) + BCC (2 bytes)。參考：<a href="https://www.nxp.com/docs/en/application-note/AN10927.pdf">AN10927</a></li>
<li>BCC 全名為 Block Check Character，作為校驗碼。其前方 4 個 bytes 做 XOR 運算，就是 BCC 的值。參考：<a href="https://www.nxp.com/docs/en/application-note/AN10927.pdf">AN10927</a><br> <code>8b</code> 與 <code>19</code> 為 BCC<ol>
<li>Page 0, Byte 3 的 <code>8b</code> 為 CT (Cascade Tag = <code>88h</code>), <code>SN0</code>, <code>SN1</code>, <code>SN2</code> 做 XOR 後的值，即 <code>88h xor 04h xor 67h xor 60h = 8bh</code>。</li>
<li>Page 2, Byte 0 的 <code>19</code> 為 <code>SN3</code>, <code>SN4</code>, <code>SN5</code>, <code>SN6</code> 做 XOR 後的值，即 <code>12h xor eeh xor 64h xor 81h = 19h</code>。</li>
</ol>
</li>
<li>若 BCC 皆正確便能確定 UID 是對的。</li>
<li>其中 <code>SN0</code> 代表晶片廠商代碼。參考：<a href="https://forum.xda-developers.com/t/iso-iec-7816-6-am1-chip-manufacturer-codes.1814558/">ISO/IEC 7816-6/AM1 chip manufacturer codes</a></li>
</ol>
<h2 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h2><p>Page 2, Byte 1 在文件中說是 Internal，並沒明說用途。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">02h</td>
<td style="text-align:center">-</td>
<td style="text-align:center">48</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Static-lock-bytes"><a href="#Static-lock-bytes" class="headerlink" title="Static lock bytes"></a>Static lock bytes</h2><p>Page 2 的 Byte 2 與 Byte 3 是 Static lock bytes，只要這 16 個 bit 任一個被設為 1，該 bit 就不能回到 0 了，為不可逆的操作，該 bit 對應的 Page 也會被永久鎖住，不可再被修改，需要小心使用！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">02h</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Capability-Container"><a href="#Capability-Container" class="headerlink" title="Capability Container"></a>Capability Container</h2><p>Page 3 是 Capability Container，即為就是記錄 Tag 能力的 page</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">03h</td>
<td style="text-align:center">e1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">00</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>Page 3, Byte 2：12h 代表這個 tag 有 144 bytes 的空間可以寫 NDEF。</li>
<li>其它 Byte 還不清楚作用。</li>
</ol>
<h2 id="Data-page"><a href="#Data-page" class="headerlink" title="Data page"></a>Data page</h2><p>Page 4 之後 (包含) 的 Page 為 Data page，這是一個 NDEF，解讀方法可參考 <a href="/2022/03/08/nfc_ndef/">[NFC] NDEF 解析</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Page↓\ Byte→</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">04h</td>
<td style="text-align:center">03</td>
<td style="text-align:center">0c</td>
<td style="text-align:center">d1</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">05h</td>
<td style="text-align:center">08</td>
<td style="text-align:center">54</td>
<td style="text-align:center">02</td>
<td style="text-align:center">7a</td>
</tr>
<tr>
<td style="text-align:center">06h</td>
<td style="text-align:center">68</td>
<td style="text-align:center">41</td>
<td style="text-align:center">45</td>
<td style="text-align:center">49</td>
</tr>
<tr>
<td style="text-align:center">07h</td>
<td style="text-align:center">4f</td>
<td style="text-align:center">55</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h2><p>最後的最後，使用市面上的 NFC 解析軟體來驗證自己的觀念是否正確</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NTAG213-%E8%A8%98%E6%86%B6%E9%AB%94%E8%A7%A3%E6%9E%90%2Ftag_detail1.png?alt=media&amp;token=0be64541-92ff-4264-8d43-c55a73faad26" alt="NTAG213 詳細資訊1"><span class="image-caption">NTAG213 詳細資訊1</span></div><div class="group-picture-column" style="width: 50%;"><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/NFC-NTAG213-%E8%A8%98%E6%86%B6%E9%AB%94%E8%A7%A3%E6%9E%90%2Ftag_detail2.png?alt=media&amp;token=377433e2-59db-4eea-ba3f-7d87210a2484" alt="NATG213 詳細資訊2"><span class="image-caption">NATG213 詳細資訊2</span></div></div><div class="group-picture-row"></div></div></div>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://www.nxp.com/docs/en/data-sheet/NTAG213_215_216.pdf">NTAG213/215/216 Datasheet</a></p>
</li>
<li><p><a href="https://www.nxp.com/docs/en/application-note/AN10927.pdf">AN10927 - MIFARE product and handling of UIDs</a></p>
</li>
<li><p><a href="https://forum.xda-developers.com/t/iso-iec-7816-6-am1-chip-manufacturer-codes.1814558/">ISO/IEC 7816-6/AM1 chip manufacturer codes</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>nfc</tag>
        <tag>ndef</tag>
        <tag>ntag213</tag>
        <tag>memory</tag>
        <tag>page</tag>
        <tag>lock</tag>
        <tag>nxp</tag>
      </tags>
  </entry>
  <entry>
    <title>[Nginx] CentOS 安裝網頁伺服器 Nginx</title>
    <url>/2021/06/18/nginx_centos_nginx/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相較於 Apache，Nginx 消耗資源少且處理速度快，又支援高併發，是大流量應用的好選擇。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
</ul>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>開啟 Terminal，使用 <code>dnf</code> 來安裝 Nginx</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf install -y nginx</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Complete!    <span class="comment">#看到這就行代表完成</span></span><br></pre></td></tr></table></figure>
<h2 id="啟動並確認"><a href="#啟動並確認" class="headerlink" title="啟動並確認"></a>啟動並確認</h2><p>Nginx 預設是沒有開啟的，預設當系統開機時也不會自動開啟，所以通過指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl start nginx   <span class="comment"># 現在馬上開啟 nginx 服務</span></span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> nginx  <span class="comment"># 之後開機也要自動開啟 nginx 服務</span></span><br></pre></td></tr></table></figure>
<p>確認 Nginx 的服務狀態，看到 <code>active (running)</code> 代表正在運行囉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl status nginx</span><br><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2020-09-10 09:08:10 CST; 3min 51s ago</span><br><span class="line">  Process: 2892 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2890 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2888 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 2893 (nginx)</span><br><span class="line">    Tasks: 3 (<span class="built_in">limit</span>: 49448)</span><br><span class="line">   Memory: 5.7M</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─2893 nginx: master process /usr/sbin/nginx</span><br><span class="line">           ├─2894 nginx: worker process</span><br><span class="line">           └─2895 nginx: worker process</span><br><span class="line"></span><br><span class="line">Sep 10 09:08:10 localhost.localdomain systemd[1]: Starting The nginx HTTP and reverse proxy server...</span><br><span class="line">Sep 10 09:08:10 localhost.localdomain nginx[2890]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">Sep 10 09:08:10 localhost.localdomain nginx[2890]: nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">Sep 10 09:08:10 localhost.localdomain systemd[1]: Started The nginx HTTP and reverse proxy server.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>web</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>nginx</tag>
        <tag>8.2</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.js] 基於 React 的 Electron 開發環境建立與打包</title>
    <url>/2021/08/04/react_electron_build/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://nodejs.org/en/">Node.js</a> 盛行的年代，使用 JavaScript 開發各種應用程式不在話下，隨著 <a href="https://www.electronjs.org/">Electron</a> 套件的推出，讓前端工程師不須學習額外語言，即可撰寫跨平台桌面應用程式。除此之外，由於 Electron 桌面應用程式是使用 html/css/js 來建立，所以我們可以整合其他前端框架 (<a href="https://zh-hant.reactjs.org/">React</a>/<a href="https://vuejs.org/">Vue</a>/<a href="https://angular.io/">Angular</a> 等) 作為應用程式 UI 開發工具。這裡要分享的是如何建立基於 React 的 Electron 開發環境，並詳細記載最重要的打包步驟。</p>
<h2 id="React-Electron-實際專案"><a href="#React-Electron-實際專案" class="headerlink" title="React + Electron 實際專案"></a>React + Electron 實際專案</h2><ul>
<li><a href="/2021/06/15/tool_it_ap_displayer/">[Tool] IT 的好幫手 - 帳密顯示器</a></li>
</ul>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>node 14.16.1</li>
</ul>
<h2 id="建立開發環境"><a href="#建立開發環境" class="headerlink" title="建立開發環境"></a>建立開發環境</h2><h3 id="CRA"><a href="#CRA" class="headerlink" title="CRA"></a>CRA</h3><p>首先建立 React 專案 (CRA, Create React App)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-based-electron</span><br></pre></td></tr></table></figure>
<ul>
<li><code>npx</code>：使用 <code>create-react-app</code> 套件，但不將該套件下載到本地端。</li>
<li><code>react-based-electron</code>：此為 CRA 的專案名稱，可任意更改。</li>
</ul>
<h3 id="Electron-相關套件"><a href="#Electron-相關套件" class="headerlink" title="Electron 相關套件"></a>Electron 相關套件</h3><p>安裝開發 Electron 桌面應用程式時所需套件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> react-based-electron</span><br><span class="line"></span><br><span class="line">npm install --save-dev electron</span><br><span class="line">npm install --save electron-is-dev</span><br><span class="line">npm install --save wait-on</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.npmjs.com/package/electron"><code>electron</code></a>：為 Electron 套件本身。</li>
<li><p><a href="https://www.npmjs.com/package/electron-is-dev"><code>electron-is-dev</code></a>：能夠得知 Electron 應用目前運行狀態是處於開發階段還是產品階段，讓開發者能輕鬆對不同情況做邏輯分流</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">&#x27;electron-is-dev&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in development&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in production&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.npmjs.com/package/wait-on"><code>wait-on</code></a>：先等待某些服務 (files/ports/sockets/http(s)) 正常運作，再執行接下來的指令</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wait-on tcp:3000 &amp;&amp; electron .    <span class="comment"># 直到 TCP 3000 正常運作，才會執行 electron .</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="main-js-preload-js"><a href="#main-js-preload-js" class="headerlink" title="main.js/preload.js"></a>main.js/preload.js</h3><p>於專案根目錄建立兩個檔案，分別為 Electron 的進入點 <code>main.js</code> (內容如下) 與 <code>preload.js</code> (空白檔案)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">&#x27;electron-is-dev&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">            <span class="attr">preload</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;preload.js&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">        <span class="comment">// 開發階段直接與 React 連線</span></span><br><span class="line">        mainWindow.<span class="title function_">loadURL</span>(<span class="string">&#x27;http://localhost:3000/&#x27;</span>);</span><br><span class="line">        <span class="comment">// 開啟 DevTools.</span></span><br><span class="line">        mainWindow.<span class="property">webContents</span>.<span class="title function_">openDevTools</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 產品階段直接讀取 React 打包好的</span></span><br><span class="line">        mainWindow.<span class="title function_">loadFile</span>(<span class="string">&#x27;./build/index.html&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">createWindow</span>()</span><br><span class="line">    app.<span class="title function_">on</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">BrowserWindow</span>.<span class="title function_">getAllWindows</span>().<span class="property">length</span> === <span class="number">0</span>) <span class="title function_">createWindow</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">platform</span> !== <span class="string">&#x27;darwin&#x27;</span>) app.<span class="title function_">quit</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="入口點與啟動腳本"><a href="#入口點與啟動腳本" class="headerlink" title="入口點與啟動腳本"></a>入口點與啟動腳本</h3><p>於 <code>package.json</code> 中加入 <code>main</code> 資訊與 <code>homepage</code> 資訊，將 Electron 入口點設為 <code>main.js</code>。最後加上 Electron 的啟動腳本 <code>electron-start</code> 與修改 CRA 的啟動腳本 <code>start</code> 內容</p>
<div class="tabs" id="入口點與啟動腳本"><ul class="nav-tabs"><li class="tab active"><a href="#入口點與啟動腳本-1">Windows</a></li><li class="tab"><a href="#入口點與啟動腳本-2">MacOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="入口點與啟動腳本-1"><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-based-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set BROWSER=none &amp;&amp; react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;electron-start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wait-on tcp:3000 &amp;&amp; electron .&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="入口點與啟動腳本-2"><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-based-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;homepage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;export BROWSER=none &amp;&amp; react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;electron-start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wait-on tcp:3000 &amp;&amp; electron .&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div></div></div>
<ul>
<li><code>&quot;start&quot;</code>：<code>BROWSER=none</code> 讓 CRA 啟動的時候不要跳出瀏覽器。</li>
<li><code>&quot;electron-start&quot;</code>：<code>wait-on tcp:3000</code> 先等待 CRA 服務啟動，再執行 <code>electron .</code> 啟動桌面應用程式。</li>
</ul>
<h2 id="運行測試"><a href="#運行測試" class="headerlink" title="運行測試"></a>運行測試</h2><div class="tabs" id="run_script"><ul class="nav-tabs"><li class="tab active"><a href="#run_script-1">Windows</a></li><li class="tab"><a href="#run_script-2">MacOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="run_script-1"><p>開啟兩個 <code>cmd</code>，一個用來啟動 CRA (<code>npm run start</code>)，另一個則是用來啟動 Electron (<code>npm run electron-start</code>)。啟動沒有順序之分，因為我們專案使用 <code>wait-on</code> 套件協助等待 CRA 服務 (預設為 Port 3000) 運行起來，再執行 Electron 桌面應用程式</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Fnpm_run_script.png?alt=media&amp;token=b2c51a2d-f31e-47f9-8a40-09b7b22e4b15" alt="npm run start &amp; electron-start"><span class="image-caption">npm run start &amp; electron-start</span></p>
<p>等待指令運行一小段時間，就會看到 Electron 桌面應用程式中顯示 CRA 預設畫面與瀏覽器的開發工具。到目前為止，已經正確建立基於 React 的 Electron 開發專案環境囉！接著便可以放心的開始使用 React 框架開發桌面應用了</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Felectron_cra_devtool.png?alt=media&amp;token=95f8b646-9c74-4124-9c10-28b4b329fddd" alt="基於 React 的 Electron 桌面應用程式運行"><span class="image-caption">基於 React 的 Electron 桌面應用程式運行</span></p></div><div class="tab-pane" id="run_script-2"><p>開啟兩個 <code>terminal</code>，一個用來啟動 CRA (<code>npm run start</code>)，另一個則是用來啟動 Electron (<code>npm run electron-start</code>)。啟動沒有順序之分，因為我們專案使用 <code>wait-on</code> 套件協助等待 CRA 服務 (預設為 Port 3000) 運行起來，再執行 Electron 桌面應用程式</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Fnpm_run_script_mac.png?alt=media&amp;token=a18fbb8f-ea40-4692-86ff-797d4b872ff2" alt="npm run start &amp; electron-start"><span class="image-caption">npm run start &amp; electron-start</span></p>
<p>等待指令運行一小段時間，就會看到 Electron 桌面應用程式中顯示 CRA 預設畫面與瀏覽器的開發工具。到目前為止，已經正確建立基於 React 的 Electron 開發專案環境囉！接著便可以放心的開始使用 React 框架開發桌面應用了</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Felectron_cra_devtool_mac.png?alt=media&amp;token=aeee83be-4750-49d0-b748-8280dcf643ef" alt="基於 React 的 Electron 桌面應用程式運行"><span class="image-caption">基於 React 的 Electron 桌面應用程式運行</span></p></div></div></div>
<h2 id="打包應用程式"><a href="#打包應用程式" class="headerlink" title="打包應用程式"></a>打包應用程式</h2><p>當我們桌面應用程式開發完成後，下一步就是將專案打包並發佈給其他人使用，讓沒有 Node.js 開發環境的使用者也能來使用服務。</p>
<h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><p>安裝 Electron 打包套件 <code>electron-builder</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev electron-builder</span><br></pre></td></tr></table></figure>
<h3 id="icon-png"><a href="#icon-png" class="headerlink" title="icon.png"></a>icon.png</h3><p>在根目錄放置一個格式為 <code>png</code> 的 Icon 並命名為 <code>icon.png</code>，會將其用作顯示應用程式的代表圖案，圖案大小建議至少 256x256。若讀者手邊沒有圖檔可以使用，這裡提供個人設計的 Logo，僅供練習使用</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Ficon.png?alt=media&amp;token=d68b5e49-aad9-4529-bdaa-d7bc1ef8bee8" alt="Logo (WRX, Wei-Ren Xue)"><span class="image-caption">Logo (WRX, Wei-Ren Xue)</span></p>
<h3 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h3><p>於專案根目錄建立一個檔案，為 Electron 的打包配置檔 <code>build.js</code>，其內容如下</p>
<div class="tabs" id="build_js"><ul class="nav-tabs"><li class="tab active"><a href="#build_js-1">Windows</a></li><li class="tab"><a href="#build_js-2">MacOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="build_js-1"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> builder = <span class="built_in">require</span>(<span class="string">&#x27;electron-builder&#x27;</span>);</span><br><span class="line"></span><br><span class="line">builder.<span class="title function_">build</span>(&#123;</span><br><span class="line">    <span class="attr">projectDir</span>: path.<span class="title function_">resolve</span>(__dirname),</span><br><span class="line">    <span class="attr">win</span>: [<span class="string">&#x27;portable&#x27;</span>, <span class="string">&#x27;nsis&#x27;</span>],  <span class="comment">// portable 為 Windows 的免安裝程式，nsis 為安裝程式</span></span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;appId&#x27;</span>: <span class="string">&#x27;io.github.weirenxue.react-electron-demo&#x27;</span>, <span class="comment">// 應用程式 ID</span></span><br><span class="line">        <span class="string">&#x27;productName&#x27;</span>: <span class="string">&#x27;React Based Electron&#x27;</span>,  <span class="comment">// 應用程式名稱</span></span><br><span class="line">        <span class="string">&#x27;copyright&#x27;</span>: <span class="string">&#x27;Copyright © 2021 Wei-Ren Xue&#x27;</span>,    <span class="comment">// 授權宣告</span></span><br><span class="line">        <span class="string">&#x27;directories&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;output&#x27;</span>: <span class="string">&#x27;electron-build/win&#x27;</span>  <span class="comment">// 打包後的應用程式放置在 electron-build/win</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 設定打包後的 icon</span></span><br><span class="line">        <span class="string">&#x27;win&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;icon.png&#x27;</span>), </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 打包需要用到的原始碼、模組，皆需要寫到 files 內</span></span><br><span class="line">        <span class="string">&#x27;files&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;build/**/*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;node_modules/**/*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;package.json&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;preload.js&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;extends&#x27;</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data),</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="build_js-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> builder = <span class="built_in">require</span>(<span class="string">&#x27;electron-builder&#x27;</span>);</span><br><span class="line"></span><br><span class="line">builder.<span class="title function_">build</span>(&#123;</span><br><span class="line">    <span class="attr">projectDir</span>: path.<span class="title function_">resolve</span>(__dirname),</span><br><span class="line">    <span class="attr">win</span>: [<span class="string">&#x27;portable&#x27;</span>, <span class="string">&#x27;nsis&#x27;</span>],  <span class="comment">// portable 為 Windows 的免安裝程式，nsis 為安裝程式</span></span><br><span class="line">    <span class="attr">mac</span>: [<span class="string">&#x27;dmg&#x27;</span>],   <span class="comment">// dmg 為 Mac 常見的打包方式，若開發環境為 Windows 無法打包，需註解掉，否則會出錯</span></span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;appId&#x27;</span>: <span class="string">&#x27;io.github.weirenxue.react-electron-demo&#x27;</span>, <span class="comment">// 應用程式 ID</span></span><br><span class="line">        <span class="string">&#x27;productName&#x27;</span>: <span class="string">&#x27;React Based Electron&#x27;</span>,  <span class="comment">// 應用程式名稱</span></span><br><span class="line">        <span class="string">&#x27;copyright&#x27;</span>: <span class="string">&#x27;Copyright © 2021 Wei-Ren Xue&#x27;</span>,    <span class="comment">// 授權宣告</span></span><br><span class="line">        <span class="string">&#x27;directories&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;output&#x27;</span>: <span class="string">&#x27;electron-build/win&#x27;</span>  <span class="comment">// 打包後的應用程式放置在 electron-build/win</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 設定打包後的 icon</span></span><br><span class="line">        <span class="string">&#x27;win&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;icon.png&#x27;</span>), </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;mac&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;icon.png&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 打包需要用到的原始碼、模組，皆需要寫到 files 內</span></span><br><span class="line">        <span class="string">&#x27;files&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;build/**/*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;node_modules/**/*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;package.json&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;preload.js&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;extends&#x27;</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data),</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="打包腳本"><a href="#打包腳本" class="headerlink" title="打包腳本"></a>打包腳本</h3><p>於 <code>package.json</code> 加入 <code>electron-build</code> 打包腳本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;electron-start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wait-on tcp:3000 &amp;&amp; electron .&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;electron-build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run build &amp;&amp; node build.js&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&quot;electron-build&quot;</code>：<code>npm run build</code> 先建置 CRA 專案，<code>node build.js</code> 再建置 Electron 專案。</li>
</ul>
<h3 id="執行打包腳本"><a href="#執行打包腳本" class="headerlink" title="執行打包腳本"></a>執行打包腳本</h3><p>第一次執行打包會需要較久時間，因為需要下載相關套件，請耐心等待</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run electron-build</span><br></pre></td></tr></table></figure>
<p>這裡提供成功打包的 Log 做為參考</p>
<div class="tabs" id="build_log"><ul class="nav-tabs"><li class="tab active"><a href="#build_log-1">Windows</a></li><li class="tab"><a href="#build_log-2">MacOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="build_log-1"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PS</span> <span class="attr">C</span>:\<span class="title class_">Users</span>\wrxue\source\nodejs\react-based-electron&gt; npm run electron-build</span><br><span class="line"></span><br><span class="line">&gt; react-based-electron@<span class="number">0.1</span><span class="number">.0</span> electron-build <span class="attr">C</span>:\<span class="title class_">Users</span>\wrxue\source\nodejs\react-based-electron</span><br><span class="line">&gt; npm run build &amp;&amp; node build.<span class="property">js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; react-based-electron@<span class="number">0.1</span><span class="number">.0</span> build <span class="attr">C</span>:\<span class="title class_">Users</span>\wrxue\source\nodejs\react-based-electron</span><br><span class="line">&gt; react-scripts build</span><br><span class="line"></span><br><span class="line"><span class="title class_">Creating</span> an optimized production build...</span><br><span class="line"><span class="title class_">Compiled</span> successfully.</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span> sizes after <span class="attr">gzip</span>:</span><br><span class="line"></span><br><span class="line">  <span class="number">41.34</span> <span class="variable constant_">KB</span>  build\<span class="keyword">static</span>\js\<span class="number">2.</span>e86009e0.<span class="property">chunk</span>.<span class="property">js</span>     </span><br><span class="line">  <span class="number">1.63</span> <span class="variable constant_">KB</span>   build\<span class="keyword">static</span>\js\<span class="number">3.</span>a8f12dc9.<span class="property">chunk</span>.<span class="property">js</span>     </span><br><span class="line">  <span class="number">1.18</span> <span class="variable constant_">KB</span>   build\<span class="keyword">static</span>\js\runtime-main.6c97c200.<span class="property">js</span></span><br><span class="line">  <span class="number">600</span> B     build\<span class="keyword">static</span>\js\main.6d3c4ff6.<span class="property">chunk</span>.<span class="property">js</span>  </span><br><span class="line">  <span class="number">556</span> B     build\<span class="keyword">static</span>\css\main.<span class="property">a617e044</span>.<span class="property">chunk</span>.<span class="property">css</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">The</span> project was built assuming it is hosted at ./.</span><br><span class="line"><span class="title class_">You</span> can control <span class="variable language_">this</span> <span class="keyword">with</span> the homepage field <span class="keyword">in</span> your package.<span class="property">json</span>.</span><br><span class="line"></span><br><span class="line"><span class="title class_">The</span> build folder is ready to be deployed.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Find</span> out more about deployment <span class="attr">here</span>:</span><br><span class="line"></span><br><span class="line">  <span class="attr">https</span>:<span class="comment">//cra.link/deployment</span></span><br><span class="line"></span><br><span class="line">  • electron-builder  version=<span class="number">22.11</span><span class="number">.7</span> os=<span class="number">10.0</span><span class="number">.19042</span></span><br><span class="line">  • description is missed <span class="keyword">in</span> the package.<span class="property">json</span>  appPackageFile=<span class="attr">C</span>:\<span class="title class_">Users</span>\wrxue\source\nodejs\react-based-electron\package.<span class="property">json</span></span><br><span class="line">  • author is missed <span class="keyword">in</span> the package.<span class="property">json</span>  appPackageFile=<span class="attr">C</span>:\<span class="title class_">Users</span>\wrxue\source\nodejs\react-based-electron\package.<span class="property">json</span></span><br><span class="line">  • writing effective config  file=electron-build\win\builder-effective-config.<span class="property">yaml</span></span><br><span class="line">  • packaging       platform=win32 arch=x64 electron=<span class="number">13.1</span><span class="number">.7</span> appOutDir=electron-build\win\win-unpacked</span><br><span class="line">  • building        target=portable file=electron-build\win\<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span> archs=x64</span><br><span class="line">  • building        target=nsis file=electron-build\win\<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="title class_">Setup</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span> archs=x64 oneClick=<span class="literal">true</span> perMachine=<span class="literal">false</span></span><br><span class="line">  • building block map  blockMapFile=electron-build\win\<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="title class_">Setup</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span>.<span class="property">blockmap</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;C:\\Users\\wrxue\\source\\nodejs\\react-based-electron\\electron-build\\win\\React Based Electron 0.1.0.exe&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;C:\\Users\\wrxue\\source\\nodejs\\react-based-electron\\electron-build\\win\\React Based Electron Setup 0.1.0.exe.blockmap&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;C:\\Users\\wrxue\\source\\nodejs\\react-based-electron\\electron-build\\win\\React Based Electron Setup 0.1.0.exe&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="build_log-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrxue@ip233 react-based-electron % npm run electron-build</span><br><span class="line"></span><br><span class="line">&gt; react-based-electron@<span class="number">0.1</span><span class="number">.0</span> electron-build /<span class="title class_">Users</span>/wrxue/<span class="title class_">Desktop</span>/nodejs/react-based-electron</span><br><span class="line">&gt; npm run build &amp;&amp; node build.<span class="property">js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; react-based-electron@<span class="number">0.1</span><span class="number">.0</span> build /<span class="title class_">Users</span>/wrxue/<span class="title class_">Desktop</span>/nodejs/react-based-electron</span><br><span class="line">&gt; react-scripts build</span><br><span class="line"></span><br><span class="line"><span class="title class_">Creating</span> an optimized production build...</span><br><span class="line"><span class="title class_">Compiled</span> successfully.</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span> sizes after <span class="attr">gzip</span>:</span><br><span class="line"></span><br><span class="line">  <span class="number">41.34</span> <span class="variable constant_">KB</span>  build/<span class="keyword">static</span>/js/<span class="number">2.</span>e86009e0.<span class="property">chunk</span>.<span class="property">js</span></span><br><span class="line">  <span class="number">1.63</span> <span class="variable constant_">KB</span>   build/<span class="keyword">static</span>/js/<span class="number">3.</span>a8f12dc9.<span class="property">chunk</span>.<span class="property">js</span></span><br><span class="line">  <span class="number">1.18</span> <span class="variable constant_">KB</span>   build/<span class="keyword">static</span>/js/runtime-main.6c97c200.<span class="property">js</span></span><br><span class="line">  <span class="number">600</span> B     build/<span class="keyword">static</span>/js/main.6d3c4ff6.<span class="property">chunk</span>.<span class="property">js</span></span><br><span class="line">  <span class="number">556</span> B     build/<span class="keyword">static</span>/css/main.<span class="property">a617e044</span>.<span class="property">chunk</span>.<span class="property">css</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">The</span> project was built assuming it is hosted at ./.</span><br><span class="line"><span class="title class_">You</span> can control <span class="variable language_">this</span> <span class="keyword">with</span> the homepage field <span class="keyword">in</span> your package.<span class="property">json</span>.</span><br><span class="line"></span><br><span class="line"><span class="title class_">The</span> build folder is ready to be deployed.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Find</span> out more about deployment <span class="attr">here</span>:</span><br><span class="line"></span><br><span class="line">  <span class="attr">https</span>:<span class="comment">//cra.link/deployment</span></span><br><span class="line"></span><br><span class="line">  • electron-builder  version=<span class="number">22.11</span><span class="number">.7</span> os=<span class="number">20.5</span><span class="number">.0</span></span><br><span class="line">  • description is missed <span class="keyword">in</span> the package.<span class="property">json</span>  appPackageFile=<span class="regexp">/Users/</span>wrxue/<span class="title class_">Desktop</span>/nodejs/react-based-electron/package.<span class="property">json</span></span><br><span class="line">  • author is missed <span class="keyword">in</span> the package.<span class="property">json</span>  appPackageFile=<span class="regexp">/Users/</span>wrxue/<span class="title class_">Desktop</span>/nodejs/react-based-electron/package.<span class="property">json</span></span><br><span class="line">  • writing effective config  file=electron-build/win/builder-effective-config.<span class="property">yaml</span></span><br><span class="line">  • rebuilding native dependencies  dependencies=fsevents@<span class="number">1.2</span><span class="number">.13</span>, fsevents@<span class="number">1.2</span><span class="number">.13</span> platform=darwin arch=x64</span><br><span class="line">  • packaging       platform=darwin arch=x64 electron=<span class="number">13.1</span><span class="number">.7</span> appOutDir=electron-build/win/mac</span><br><span class="line">  • signing         file=electron-build/win/mac/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span>.<span class="property">app</span> identityName=<span class="title class_">Apple</span> <span class="title class_">Development</span>: a0981355215@gmail.<span class="property">com</span> (<span class="title class_">PZRJD74VXK</span>) identityHash=755CB8F653511BDB2E6C567A905176EE278DD9D8 provisioningProfile=none</span><br><span class="line">  • building        target=<span class="variable constant_">DMG</span> arch=x64 file=electron-build/win/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span>-<span class="number">0.1</span><span class="number">.0</span>.<span class="property">dmg</span></span><br><span class="line">  • rebuilding native dependencies  dependencies=fsevents@<span class="number">1.2</span><span class="number">.13</span>, fsevents@<span class="number">1.2</span><span class="number">.13</span> platform=win32 arch=x64</span><br><span class="line">  • packaging       platform=win32 arch=x64 electron=<span class="number">13.1</span><span class="number">.7</span> appOutDir=electron-build/win/win-unpacked</span><br><span class="line">  • building block map  blockMapFile=electron-build/win/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span>-<span class="number">0.1</span><span class="number">.0</span>.<span class="property">dmg</span>.<span class="property">blockmap</span></span><br><span class="line">  • building        target=portable file=electron-build/win/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span> archs=x64</span><br><span class="line">  • building        target=nsis file=electron-build/win/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="title class_">Setup</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span> archs=x64 oneClick=<span class="literal">true</span> perMachine=<span class="literal">false</span></span><br><span class="line">  • building block map  blockMapFile=electron-build/win/<span class="title class_">React</span> <span class="title class_">Based</span> <span class="title class_">Electron</span> <span class="title class_">Setup</span> <span class="number">0.1</span><span class="number">.0</span>.<span class="property">exe</span>.<span class="property">blockmap</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/Users/wrxue/Desktop/nodejs/react-based-electron/electron-build/win/React Based Electron-0.1.0.dmg.blockmap&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/wrxue/Desktop/nodejs/react-based-electron/electron-build/win/React Based Electron-0.1.0.dmg&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/wrxue/Desktop/nodejs/react-based-electron/electron-build/win/React Based Electron 0.1.0.exe&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/wrxue/Desktop/nodejs/react-based-electron/electron-build/win/React Based Electron Setup 0.1.0.exe.blockmap&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/wrxue/Desktop/nodejs/react-based-electron/electron-build/win/React Based Electron Setup 0.1.0.exe&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="查看執行檔"><a href="#查看執行檔" class="headerlink" title="查看執行檔"></a>查看執行檔</h3><p>由於我們在 <code>build.js</code> 中有指定 <code>&#39;output&#39;: &#39;electron-build/win&#39;</code>，所以 <code>electron-builder</code> 會將打包好的安裝檔放置於 <code>electron-build/win</code> 目錄下</p>
<div class="tabs" id="installer"><ul class="nav-tabs"><li class="tab active"><a href="#installer-1">Windows</a></li><li class="tab"><a href="#installer-2">MacOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="installer-1"><p><code>portable</code> 與 <code>nsis</code> 在 Windows 上才可以使用，<code>portable</code> 執行檔啟動較慢但不需安裝，<code>nsis</code> 則是安裝一次後便能啟動快速</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Finstaller.png?alt=media&amp;token=28875000-950a-4c46-a5ca-3cf7f2c8ffa0" alt="打包好的安裝檔"><span class="image-caption">打包好的安裝檔</span></p></div><div class="tab-pane" id="installer-2"><p><code>portable</code> 與 <code>nsis</code> 在 Windows 上才可以使用，<code>portable</code> 的執行檔啟動較慢但不需安裝，<code>nsis</code> 則是安裝一次後便能啟動快速。而 <code>dmg</code> 是給 MacOS 使用的，開啟後將應用程式拖曳到 <code>Applications</code> 目錄便安裝完成</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Node-%E5%9F%BA%E6%96%BC-React-%E7%9A%84-Electron-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8B%E8%88%87%E6%89%93%E5%8C%85%2Finstaller_mac.png?alt=media&amp;token=c5259392-60bc-46c7-82eb-abd7afa22d3c" alt="打包好的安裝檔"><span class="image-caption">打包好的安裝檔</span></p></div></div></div>
<h2 id="原始碼"><a href="#原始碼" class="headerlink" title="原始碼"></a>原始碼</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://github.com/weirenxue/react-based-electron/tree/windows" title="Windows">
            <i class="fab fa-github fa-lg"></i>Windows
          </a>
<a class="btn" href="https://github.com/weirenxue/react-based-electron/tree/macos" title="MacOS">
            <i class="fab fa-github fa-lg"></i>MacOS
          </a>
<!-- markdownlint-restore MD034 -->
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 1338c5d (macos) 加入打包腳本</span><br><span class="line">* 56b90c1 建立 build.js</span><br><span class="line">* 9dc95f5 加入 icon.png</span><br><span class="line">* 1398a05 安裝 electron-builder</span><br><span class="line">* 6e4ed7c 入口點與啟動腳本</span><br><span class="line">| * 928d60b (windows) 加入打包腳本</span><br><span class="line">| * 890669a 建立 build.js</span><br><span class="line">| * a98f6c3 加入 icon.png</span><br><span class="line">| * 6cb08c7 安裝 electron-builder</span><br><span class="line">| * b61b238 入口點與啟動腳本</span><br><span class="line">|/</span><br><span class="line">* 06de8dd (master) main.js/preload.js</span><br><span class="line">* f9cc184 安裝 Electron 相關套件</span><br><span class="line">* aad6a81 Initialize project using Create React App</span><br></pre></td></tr></table></figure>
<p>在實作中遇到困難是難免的，這裡提供原始碼作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
<!-- markdownlint-disable MD033 -->
<script>
    tabs = [];
    document.querySelectorAll('.nav-tabs .tab a').forEach((element) => {
        arr = element.href.split('-');
        index = arr[arr.length - 1]
        if (tabs[index] === undefined)
            tabs[index] = []
        tabs[index].push(element);
    });
    tabs.forEach((elements) => {
        elements.forEach((element) => {
            element.addEventListener('click', () => {
                elements.forEach((e) => {
                    e.click()
                })
            })
        });
    });
</script>

<!-- markdownlint-restore MD033 -->
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>electron</tag>
        <tag>node</tag>
        <tag>js</tag>
        <tag>macos</tag>
        <tag>react</tag>
        <tag>develop</tag>
        <tag>build</tag>
        <tag>environment</tag>
        <tag>javascript</tag>
        <tag>cra</tag>
        <tag>mac</tag>
        <tag>nsis</tag>
        <tag>portable</tag>
        <tag>dmg</tag>
      </tags>
  </entry>
  <entry>
    <title>[Opcode] JMP 轉成機械碼的原理與過程</title>
    <url>/2021/06/12/opcodejmp/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>JMP</code> 指令根據跳轉目的地遠近分成短跳轉 (Short jump)、近跳轉 (Near jump)、遠跳轉 (Far jump)、他們所代表的含意不一樣，使得機械碼 opcode 呈現的方式也不一樣。</p>
<h2 id="閱讀手冊"><a href="#閱讀手冊" class="headerlink" title="閱讀手冊"></a>閱讀手冊</h2><p>引用指令手冊(<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">Intel® 64 and IA-32 Architectures Software Developer&#39;s Manual</a>)裡面一些對於 <code>JMP</code> 的敘述：</p>
<blockquote>
<ol>
<li>Short jump—A near jump where the jump range is limited to –128 to +127 from the current EIP value.</li>
<li>Near jump—A jump to an instruction within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment jump.</li>
<li>Far jump—A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</li>
</ol>
</blockquote>
<p>它們主要是以所要跳的目的地位址與現在的 <code>IP</code> (instruction pointer) 位址差值來區分：</p>
<ol>
<li>短跳轉：差值在 -128 ~ +127 (8-bit) 之內。</li>
<li>近跳轉：目的地在同一個區段內，且差值在 32-bit 可以表示的範圍內，又稱段內跳轉。</li>
<li>遠跳轉：目的地在別的區段，又稱段間跳轉。</li>
</ol>
<p>雖然在組合語言都是以 <code>JMP</code> 來實現跳轉，但在組譯轉成 opcode 時翻譯出來的卻不一樣，短跳轉 (<code>EB</code>)、近跳轉 (<code>E9</code>)、遠跳轉 (<code>EA</code>)。當然，opcode 不一樣就代表是不同的指令，其後的參數要怎麼給是該瞭解的事情。參考手冊說明摘要如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Jump</th>
<th>Opcode</th>
<th>Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>Short Jump</td>
<td>EB cb</td>
<td>JMP rel8</td>
</tr>
<tr>
<td>Near Jump</td>
<td>E9 cw/cd</td>
<td>JMP rel16/rel32</td>
</tr>
<tr>
<td>Far Jump</td>
<td>EA cd/cp</td>
<td>JMP ptr16:16/ptr16:32</td>
</tr>
</tbody>
</table>
</div>
<p>參數解釋</p>
<ol>
<li><code>rel8</code>/<code>rel16</code>/<code>rel32</code>：偏移量(也就是上面提到的差值)能用有號 8/16/32-bit 來表示的相對位址。</li>
<li><code>ptr16:16</code>/<code>ptr16:32</code>：一個相對遠的指標 (pointer)，通常與 <code>IP</code> 不同區段，前面的 16/16 表示 16-bit 的區段暫存器，後面的 16/32 表示目的地在那個區段的偏移量。</li>
<li><code>cb</code>/<code>cw</code>/<code>cd</code>/<code>cp</code>：用來描述代碼的偏移量和新的區段暫存器的值，分別為 1-byte、2-byte、4-byte、6-byte。</li>
</ol>
<h2 id="程式驗證"><a href="#程式驗證" class="headerlink" title="程式驗證"></a>程式驗證</h2><p>有概念之後，用程式來對上面敘述做驗證吧：</p>
<h3 id="短跳轉"><a href="#短跳轉" class="headerlink" title="短跳轉"></a>短跳轉</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Address</th>
<th>Opcode</th>
<th>Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>003F1010</td>
<td>EB 06</td>
<td>JMP  003F1018</td>
</tr>
<tr>
<td>003F1012</td>
<td>EB 04</td>
<td>JMP  003F1018</td>
</tr>
<tr>
<td>003F1014</td>
<td>EB 02</td>
<td>JMP  003F1018</td>
</tr>
</tbody>
</table>
</div>
<p>因為指令位址距目的很近，所以為短跳轉 (<code>EB</code>)，<code>EB</code> 後的數字為目的地與 <code>EIP</code> 的偏移量，但可能有人會問，為什麼對不起來？</p>
<p>像是第一個的 <code>偏移量 = 003F1018h - 003F1010h = 08h</code> 結果不是 <code>EB 08</code>，而是 <code>EB 06</code> 。這是因為 CPU 在運作時，看到 <code>EB 06</code> 知道要跳轉，也由於它已經讀了這一指令，<code>EIP</code> 會再加 2 指向下一指令，再執行 <code>EB 06</code> 這個指令。可以看得出關鍵嗎？在執行 <code>EB 06</code> 時 <code>EIP</code> 已經又加 2 了，實際上的算法應為 <code>偏移量 = 003F1018h - (003F1010h + opcode的長度) = 06h</code></p>
<h3 id="近跳轉"><a href="#近跳轉" class="headerlink" title="近跳轉"></a>近跳轉</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Address</th>
<th>Opcode</th>
<th>Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>013D1035</td>
<td>E9 85 00 00 00</td>
<td>JMP  013D10BF</td>
</tr>
<tr>
<td>013D103A</td>
<td>E9 80 00 00 00</td>
<td>JMP  013D10BF</td>
</tr>
<tr>
<td>013D103F</td>
<td>EB 7E</td>
<td>JMP  013D10BF</td>
</tr>
</tbody>
</table>
</div>
<p>偏移量的算法和短跳轉相同，不同在於近跳轉的 opcode 且 <code>E9</code> 與長度為 5-byte，在計算時要注意。在此特地用跳轉至同目的地但分別為近跳轉與短跳轉來說明，當從 1-byte 的 7E 要進位到 80 時，就會變成 4-byte 的 <code>00 00 00 80h</code>，因為其超出有號 8-bit 可表示範圍。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>far jump</tag>
        <tag>near jump</tag>
        <tag>short jump</tag>
        <tag>jmp</tag>
        <tag>opcode</tag>
      </tags>
  </entry>
  <entry>
    <title>[PHP] CentOS 8.2 + Nginx + MariaDB + php-fpm + phpMyAdmin</title>
    <url>/2021/06/18/centos_phpmyadmin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>說到使用 MySQL/MariaDB 就會想到 phpMyAdmin 這個使用者圖像介面，它是用 PHP 寫出來與 MySQL/MariaDB 互動的介面，所以若要使用，必須先安裝網頁伺服器與 PHP。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
</ul>
<h2 id="安裝-EPEL"><a href="#安裝-EPEL" class="headerlink" title="安裝 EPEL"></a>安裝 EPEL</h2><p>安裝由 Fedora 社群打造的第三方源 EPEL (Extra Packages for Enterprise Linux)，其中包含比官方 repository 還要新的套件版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf -y install epel-release</span><br></pre></td></tr></table></figure>
<h2 id="安裝-Nginx"><a href="#安裝-Nginx" class="headerlink" title="安裝 Nginx"></a>安裝 Nginx</h2><p>詳細安裝與設定過程參考 <a href="/2021/06/18/nginx_centos_nginx/">[Nginx] CentOS 安裝網頁伺服器 Nginx</a>，安裝好後從瀏覽器輸入 <a href="http://localhost">http://localhost</a> 確定可看到 Nginx 預設頁面</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf -y install nginx</span><br><span class="line">[user@localhost ~]$ sudo systemctl start nginx</span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>
<h2 id="安裝-MariaDB"><a href="#安裝-MariaDB" class="headerlink" title="安裝 MariaDB"></a>安裝 MariaDB</h2><p>詳細安裝與設定過程參考 <a href="/2021/06/18/mysql_centos_mysql_8_0_root/">[MySQL] CentOS 8 安裝 MySQL 8.0 與更改 root 密碼</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf -y install mariadb-server mariadb</span><br><span class="line">[user@localhost ~]$ sudo systemctl start mariadb</span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> mariadb</span><br></pre></td></tr></table></figure>
<h2 id="安裝-php-fpm"><a href="#安裝-php-fpm" class="headerlink" title="安裝 php-fpm"></a>安裝 php-fpm</h2><p>這裡安裝預設版本 (目前是7.2版)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf -y install php php-fpm php-json php-mysqlnd php-mbstring</span><br></pre></td></tr></table></figure>
<h3 id="修改-www-conf-設定"><a href="#修改-www-conf-設定" class="headerlink" title="修改 www.conf 設定"></a>修改 www.conf 設定</h3><p>修改 <code>/etc/php-fpm.d/www.conf</code> 檔案內容</p>
<ol>
<li>改 <code>user = apache</code> 為 <code>user = nginx</code></li>
<li>改 <code>group = apache</code> 為 <code>group = nginx</code></li>
<li>改 <code>listen = /run/php-fpm/www.sock</code> 為 <code>listen = /var/run/php-fpm/php-fpm.sock</code></li>
<li>拿掉 <code>;listen.owner = nobody</code> 的分號，並改為 <code>listen.owner = nginx</code></li>
<li>拿掉 <code>;listen.group = nobody</code> 的分號，並改為 <code>listen.group = nginx</code></li>
<li>拿掉 <code>;listen.mode = 0660</code> 的分號</li>
</ol>
<h3 id="啟動-php-fpm-服務"><a href="#啟動-php-fpm-服務" class="headerlink" title="啟動 php-fpm 服務"></a>啟動 php-fpm 服務</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl start php-fpm</span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> php-fpm</span><br></pre></td></tr></table></figure>
<h3 id="修改-php-fpm-conf-設定"><a href="#修改-php-fpm-conf-設定" class="headerlink" title="修改 php-fpm.conf 設定"></a>修改 php-fpm.conf 設定</h3><p>修改 <code>/etc/nginx/conf.d/php-fpm.conf</code> 檔案內容</p>
<ol>
<li>改 <code>server unix:/run/php-fpm/www.sock;</code> 為 <code>server unix:/var/run/php-fpm/php-fpm.sock;</code></li>
</ol>
<h3 id="新增-phpmyadmin-conf-檔案"><a href="#新增-phpmyadmin-conf-檔案" class="headerlink" title="新增 phpmyadmin.conf 檔案"></a>新增 phpmyadmin.conf 檔案</h3><p>新增 <code>/etc/nginx/conf.d/phpmyadmin.conf</code> 檔案，內容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  server_domain_or_IP;</span><br><span class="line"></span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">    index index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line"></span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">        fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重新載入設定"><a href="#重新載入設定" class="headerlink" title="重新載入設定"></a>重新載入設定</h3><p>Nginx 重新載入設定檔，要看到 <code>ok</code> 與 <code>/etc/nginx/nginx.conf test is successful</code> 才是對的哦！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl reload nginx</span><br><span class="line">[user@localhost ~]$ sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>
<h3 id="確認-php-fpm-運作"><a href="#確認-php-fpm-運作" class="headerlink" title="確認 php-fpm 運作"></a>確認 php-fpm 運作</h3><p>創建 <code>/usr/share/nginx/html/info.php</code> 其內容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>
<p>這時從瀏覽器輸入 <a href="http://localhost/info.php">http://localhost/info.php</a> 確定可看到 <code>phpinfo</code> 的頁面，若看得到代表 Nginx + php-fpm 有在正常運作囉</p>
<h2 id="安裝-phpMyAdmin"><a href="#安裝-phpMyAdmin" class="headerlink" title="安裝 phpMyAdmin"></a>安裝 phpMyAdmin</h2><p>下載 <a href="https://www.phpmyadmin.net/">phpMyAdmin</a> 並解壓縮到 <code>/usr/share/nginx/html</code> 目錄</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ unzip Downloads/phpMyAdmin-5.0.2-all-languages.zip </span><br><span class="line">[user@localhost ~]$ sudo <span class="built_in">mv</span> phpMyAdmin-5.0.2-all-languages/ /usr/share/nginx/html/phpMyAdmin</span><br></pre></td></tr></table></figure>
<h3 id="創建-tmp-目錄"><a href="#創建-tmp-目錄" class="headerlink" title="創建 tmp 目錄"></a>創建 tmp 目錄</h3><p>創建 <code>phpMyAdmin/tmp/</code> 目錄並更改擁有者與群組為 <code>nginx:nginx</code>，同時更改權限為 <code>755</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo <span class="built_in">mkdir</span> /usr/share/nginx/html/phpMyAdmin/tmp</span><br><span class="line">[user@localhost ~]$ sudo <span class="built_in">chown</span> nginx:nginx /usr/share/nginx/html/phpMyAdmin/tmp</span><br><span class="line">[user@localhost ~]$ sudo <span class="built_in">chmod</span> 755 /usr/share/nginx/html/phpMyAdmin/tmp</span><br></pre></td></tr></table></figure>
<h3 id="設定-blowfish-secret-金鑰"><a href="#設定-blowfish-secret-金鑰" class="headerlink" title="設定 blowfish_secret 金鑰"></a>設定 blowfish_secret 金鑰</h3><p>複製一個 config 樣板，並改名為 <code>config.inc.php</code>，此樣板會被 phpMyAdmin 載入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo <span class="built_in">cp</span> /usr/share/nginx/html/phpMyAdmin/config.sample.inc.php  /usr/share/nginx/html/phpMyAdmin/config.inc.php</span><br></pre></td></tr></table></figure>
<p>再從 <a href="https://phpsolved.com/phpmyadmin-blowfish-secret-generator/?g=[insert_php]echo%20$code;[/insert_php]">phpMyAdmin blowfish secret generator</a> 取得安全的金鑰，並複製到 <code>config.inc.php</code> 檔案中，例如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cfg</span>[<span class="string">&#x27;blowfish_secret&#x27;</span>] = <span class="string">&#x27;Jh448H=tn1sfkb3b3EKwvofq=QVuitPn&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="權限設定"><a href="#權限設定" class="headerlink" title="權限設定"></a>權限設定</h2><h3 id="開啟-php-session-權限"><a href="#開啟-php-session-權限" class="headerlink" title="開啟 php session 權限"></a>開啟 php session 權限</h3><p>設定 Nginx 對 php session 的權限，需將權限開啟，否則無法使用 phpMyAdmin 的登入功能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo <span class="built_in">chown</span> nginx:nginx /var/lib/php/session/</span><br></pre></td></tr></table></figure>
<h3 id="設定-SELinux"><a href="#設定-SELinux" class="headerlink" title="設定 SELinux"></a>設定 SELinux</h3><p>修改 phpMyAdmin 的安全性文本，讓 Nginx 可以有權限可以讀寫，否則 SELinux 會阻檔，然後在瀏覽器出現 403 的錯誤碼</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo <span class="built_in">chcon</span> -R -t httpd_sys_rw_content_t /usr/share/nginx/html/phpMyAdmin</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>在瀏覽器網址輸入 <a href="http://localhost/phpMyAdmin">http://localhost/phpMyAdmin</a> 就可以如同 Windows 上使用 xampp 一般，使用 phpMyAdmin 操作作資料庫啦！</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-centos-7">How To Install Linux, Nginx, MySQL, PHP (LEMP) stack On CentOS 7</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>mariadb</tag>
        <tag>8.2</tag>
        <tag>php</tag>
        <tag>10</tag>
        <tag>7.2</tag>
        <tag>php-fpm</tag>
        <tag>phpmyadmin</tag>
        <tag>xampp</tag>
      </tags>
  </entry>
  <entry>
    <title>[PHP] Ubuntu 安裝 Apache 2 + PHP 7.4 + Phalcon 4.0</title>
    <url>/2021/06/17/php_ubuntu_apache_php_phalcon/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apache 是一個輕量級的網頁伺服器，搭配 <code>PHP</code> 與高效能的 MVC 框架 Phalcon 是一個不錯的選擇，這裡紀錄如何在 Ubuntu 安裝這些開發環境。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="安裝-Apache"><a href="#安裝-Apache" class="headerlink" title="安裝 Apache"></a>安裝 Apache</h2><p>首先安裝 Apache 2，較簡單</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get update</span><br><span class="line">user@pc:~$ sudo apt-get install apache2</span><br></pre></td></tr></table></figure>
<p>安裝完後，可以用瀏覽器，在網址處輸入 <a href="http://localhost">http://localhost</a>，確認是否有顯示正常的網頁；或者可以用命令來查詢 Apache 2 是否有正常運作，看到 <code>active (running)</code> 代表正在運行服務囉！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo systemctl status apache2</span><br><span class="line">● apache2.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset:</span><br><span class="line">  Drop-In: /lib/systemd/system/apache2.service.d</span><br><span class="line">           └─apache2-systemd.conf</span><br><span class="line">   Active: active (running) since Mon 2020-03-30 22:26:50 CST; 2min 44s ago</span><br><span class="line"> Main PID: 2185 (apache2)</span><br><span class="line">    Tasks: 55 (<span class="built_in">limit</span>: 4915)</span><br><span class="line">   CGroup: /system.slice/apache2.service</span><br><span class="line">           ├─2185 /usr/sbin/apache2 -k start</span><br><span class="line">           ├─2187 /usr/sbin/apache2 -k start</span><br><span class="line">           └─2188 /usr/sbin/apache2 -k start</span><br><span class="line"></span><br><span class="line"> 三  30 22:26:50 user-VirtualBox systemd[1]: Starting The Apache HTTP Server..</span><br><span class="line"> 三  30 22:26:50 user-VirtualBox apachectl[2174]: AH00558: apache2: Could not </span><br><span class="line"> 三  30 22:26:50 user-VirtualBox systemd[1]: Started The Apache HTTP Server.</span><br></pre></td></tr></table></figure>
<h2 id="安裝-PHP"><a href="#安裝-PHP" class="headerlink" title="安裝 PHP"></a>安裝 PHP</h2><p>接著安裝 PHP 7.4，要先引入 ppa 並更新，才能安裝</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-add-repository ppa:ondrej/php</span><br><span class="line">user@pc:~$ sudo apt-get update         <span class="comment">#一定要，不然封包庫還是沒有php</span></span><br><span class="line">user@pc:~$ sudo apt-get install php7.4 <span class="comment">#php+版本號，依照自己需求更改</span></span><br></pre></td></tr></table></figure>
<p>查看 <code>PHP</code> 版本，確認為 7.4 版</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ php -v</span><br><span class="line">PHP 7.4.4 (cli) (built: Mar 20 2020 13:47:45) ( NTS )</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br><span class="line">    with Zend OPcache v7.4.4, Copyright (c), by Zend Technologies</span><br></pre></td></tr></table></figure>
<h2 id="安裝-Phalcon"><a href="#安裝-Phalcon" class="headerlink" title="安裝 Phalcon"></a>安裝 Phalcon</h2><p>直接指令安裝 Phalcon</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install php7.4-phalcon <span class="comment"># 7.4 為版本號，可依照自己需求更改</span></span><br></pre></td></tr></table></figure>
<p>查看 <code>PHP</code> 的模組，初步確定 Phalcon 有安裝完成</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ php -m</span><br><span class="line">⋮</span><br><span class="line">⋮</span><br><span class="line">PDO</span><br><span class="line">phalcon</span><br><span class="line">Phar</span><br><span class="line">⋮</span><br><span class="line">⋮</span><br></pre></td></tr></table></figure>
<p>Apache 2 服務需要重新啟動，才會載入 Phalcon 的套件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo systemctl stop  apache2 <span class="comment"># 關閉</span></span><br><span class="line">user@pc:~$ sudo systemctl start apache2 <span class="comment"># 開啟</span></span><br></pre></td></tr></table></figure>
<p>將 <code>/var/www/html/</code> 目錄下的 <code>index.html</code> 刪除，並新增 <code>index.php</code>，其內容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>()<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>這時在瀏覽器輸入 <a href="http://localhost">http://localhost</a>，應該要能夠看到如下方的資訊，並確認版本正確 (Phalcon 4.0)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/PHP-Ubuntu-%E5%AE%89%E8%A3%9D-Apache-2-PHP-7-4-Phalcon-4-0%2Fphalcon_version.png?alt=media&amp;token=856a2b20-00d4-46c0-8a83-e0bb5c101e97" alt="phpinfo"><span class="image-caption">phpinfo</span></p>
<p>這時在 Ubuntu 上運作的就是 Apache 2 + PHP 7.4 + Phalcon4.0 囉！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ubuntu</tag>
        <tag>server</tag>
        <tag>web</tag>
        <tag>linux</tag>
        <tag>18.04</tag>
        <tag>php</tag>
        <tag>phalcon</tag>
        <tag>install</tag>
      </tags>
  </entry>
  <entry>
    <title>[PHP] 在 Phalcon 新增一個 namespace</title>
    <url>/2021/06/15/php_phalcon_namespace/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>php</code> 中常常會用 namespace 將類別 (Class) 作區隔，然而網路上文章對於在 <code>Phalcon</code> 框架中加入一個新 namespace 的方面沒有太多的著墨，使 <code>Phalcon</code> 入門門檻增加，對新手較不友善。個人也是初次使用 <code>Phalcon</code> 框架，所以會以新手的角度來記錄這個步驟！</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Phalcon 4.0.3</li>
</ul>
<h2 id="創建-namespace-步驟"><a href="#創建-namespace-步驟" class="headerlink" title="創建 namespace 步驟"></a>創建 namespace 步驟</h2><h3 id="新增目錄"><a href="#新增目錄" class="headerlink" title="新增目錄"></a>新增目錄</h3><p>先在 app 目錄下創建一個目錄，是將來要放新 Class 的地方，我這裡是想要放一些我自己擴展 <code>Phalcon\Forms\Form</code> 的類別，所以目錄取名為 <code>forms</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:/var/www/myProject/app$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">├── controllers</span><br><span class="line">├── dbBackup</span><br><span class="line">├── forms</span><br><span class="line">├── library</span><br><span class="line">├── migrations</span><br><span class="line">├── models</span><br><span class="line">└── views</span><br></pre></td></tr></table></figure>
<p>新增 <code>config.php</code> (<code>app/config/config.php</code>) 之中 <code>application</code> 內的路徑 <code>formsDir</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;application&#x27;</span> =&gt; [</span><br><span class="line">        <span class="string">&#x27;appDir&#x27;</span>         =&gt; APP_PATH . <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;controllersDir&#x27;</span> =&gt; APP_PATH . <span class="string">&#x27;/controllers/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;modelsDir&#x27;</span>      =&gt; APP_PATH . <span class="string">&#x27;/models/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;migrationsDir&#x27;</span>  =&gt; APP_PATH . <span class="string">&#x27;/migrations/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;viewsDir&#x27;</span>       =&gt; APP_PATH . <span class="string">&#x27;/views/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pluginsDir&#x27;</span>     =&gt; APP_PATH . <span class="string">&#x27;/plugins/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;libraryDir&#x27;</span>     =&gt; APP_PATH . <span class="string">&#x27;/library/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;formsDir&#x27;</span>       =&gt; APP_PATH . <span class="string">&#x27;/forms/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cacheDir&#x27;</span>       =&gt; BASE_PATH . <span class="string">&#x27;/cache/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;baseUri&#x27;</span>        =&gt; <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    ]   </span><br></pre></td></tr></table></figure>
<h3 id="註冊-namespace"><a href="#註冊-namespace" class="headerlink" title="註冊 namespace"></a>註冊 namespace</h3><p>要註冊新增的 namesapce，這個動作在 <code>loader.php</code> (<code>app/config/loader.php</code>)內完成，Array 中的 Key (e.g.:<code>&#39;AccountSystem\Forms&#39;</code>) 依自己喜歡，不與其它 Key 撞名即可！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$loader</span>-&gt;<span class="title function_ invoke__">registerNamespaces</span>(</span><br><span class="line">    [</span><br><span class="line">       <span class="string">&#x27;AccountSystem\Models&#x27;</span> =&gt; <span class="variable">$config</span>-&gt;application-&gt;modelsDir,</span><br><span class="line">       <span class="string">&#x27;AccountSystem\Forms&#x27;</span>  =&gt; <span class="variable">$config</span>-&gt;application-&gt;formsDir,</span><br><span class="line">    ]      </span><br><span class="line">)-&gt;<span class="title function_ invoke__">register</span>();</span><br><span class="line"><span class="variable">$loader</span>-&gt;<span class="title function_ invoke__">registerDirs</span>(</span><br><span class="line">    [</span><br><span class="line">        <span class="variable">$config</span>-&gt;application-&gt;controllersDir,</span><br><span class="line">        <span class="variable">$config</span>-&gt;application-&gt;modelsDir</span><br><span class="line">    ]</span><br><span class="line">)-&gt;<span class="title function_ invoke__">register</span>();</span><br></pre></td></tr></table></figure>
<h2 id="完成與測試"><a href="#完成與測試" class="headerlink" title="完成與測試"></a>完成與測試</h2><p>這樣就算是新增完成囉！只要在 <code>app/forms</code> 目錄下的類別中，最前面加上 <code>namespace AccountSystem\Forms;</code>，在其它的文件就可以調用 <code>AccountSystem\Forms\SignUpForm</code> 了喔！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">AccountSystem</span>\<span class="title class_">Forms</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Forms</span>\<span class="title">Element</span>\<span class="title">Date</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Forms</span>\<span class="title">Element</span>\<span class="title">Password</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Forms</span>\<span class="title">Form</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Forms</span>\<span class="title">Element</span>\<span class="title">Text</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Phalcon</span>\<span class="title">Forms</span>\<span class="title">Element</span>\<span class="title">Select</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpForm</span> <span class="keyword">extends</span> <span class="title">Form</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>phalcon</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>[Power] Ubuntu 筆電蓋上螢幕不休眠</title>
    <url>/2021/06/17/power_ubuntu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>筆電闔上螢幕不一定是沒有要使用，有可能是在有外接螢幕情況下只需要一個螢幕，這時就可以選擇把螢幕關上將筆電當成桌電主機一樣，因此就需要設定讓筆電關上螢幕時不會有任何動作 (包含睡眠、休眠等等)。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="修改系統參數"><a href="#修改系統參數" class="headerlink" title="修改系統參數"></a>修改系統參數</h2><p>使用 vim 編輯器開啟電源管理的配置檔案 (gedit 無法修改系統參數檔案)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure>
<p><code>HandleLidSwitch</code> 為管理螢幕闔上動作的參數，若要無動作，將其指定為 <code>ignore</code>，且前方不要有註解符號 <code>＃</code>，修改好後 <code>:wq</code> 存檔並重新開機使其生效。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HandleLidSwitch=ignore </span><br></pre></td></tr></table></figure>
<ul>
<li>其他參數的數值還有休眠 (hibernate)、睡眠 (suspend)、關機 (poweroff)</li>
</ul>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
        <tag>screen</tag>
        <tag>sleep</tag>
        <tag>action</tag>
        <tag>cover</tag>
        <tag>suspend</tag>
        <tag>poweroff</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>[Prometheus] 詳解 histogram_quantile(q, sum(rate()) by (le)) 原理</title>
    <url>/2022/04/22/prometheus_histogram_quantile/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Prometheus 是監控與告警系統的工具集，將數據以時間序列的格式存在 TSDB (Time Series Database) 中，並提供 PromQL 來對資料做查詢。histogram_quantile 為其中一個聚合函式，讓我們能夠透過 histogram 類型的 metric 推算出指定的百分位數所對應的值，應用更靈活。在解讀數據之前，個人認為要先了解數據是如何得到的，因此這篇文章紀錄 histogram_quantile 的演算法原理。</p>
<h2 id="histogram-quantile-原理"><a href="#histogram-quantile-原理" class="headerlink" title="histogram_quantile 原理"></a>histogram_quantile 原理</h2><p>Prometheus 是開源專案，所有功能背後的底層實現都能在 <a href="https://github.com/prometheus/prometheus">Prometheus GitHub</a> 找到，我們所在乎的 <a href="https://github.com/prometheus/prometheus/blob/main/promql/quantile.go">histogram_quantile</a> 也不例外。原始碼是最直接理解運作原理的方式，因此直接為相關原始碼作註解，使讀者容易理解運算邏輯</p>
<!-- markdownlint-disable MD010 -->
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">	upperBound <span class="type">float64</span> <span class="comment">// bucket metric 的 le 標籤</span></span><br><span class="line">	count      <span class="type">float64</span> <span class="comment">// bucket metric 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> buckets []bucket</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://pkg.go.dev/sort#Interface</span></span><br><span class="line"><span class="comment">// 為了使用 sort.Sort 排序，必須為資料型態 buckets </span></span><br><span class="line"><span class="comment">// 定義 Len、Swap、Less 三個函式以滿足 Interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buckets)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buckets)</span></span> Swap(i, j <span class="type">int</span>)      &#123; b[i], b[j] = b[j], b[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buckets)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> b[i].upperBound &lt; b[j].upperBound &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketQuantile</span><span class="params">(q <span class="type">float64</span>, buckets buckets)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 三個 if 判斷 q 的合理性</span></span><br><span class="line">    <span class="comment">// 若 q 為 NaN，回傳 NaN</span></span><br><span class="line">    <span class="keyword">if</span> math.IsNaN(q) &#123;</span><br><span class="line">        <span class="keyword">return</span> math.NaN()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 q 小於 0，回傳負無限大</span></span><br><span class="line">    <span class="keyword">if</span> q &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Inf(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 q 大於 1，回傳正無限大</span></span><br><span class="line">    <span class="keyword">if</span> q &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Inf(+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根據 bucket.upperBound 排序</span></span><br><span class="line">    <span class="comment">// 小的在前，大的在後</span></span><br><span class="line">    sort.Sort(buckets)</span><br><span class="line">    <span class="comment">// 判斷最後一個 bucket 的 upperBound (le) 是否為正無限大</span></span><br><span class="line">    <span class="comment">// 若否，則結束運算並回傳 NaN</span></span><br><span class="line">    <span class="keyword">if</span> !math.IsInf(buckets[<span class="built_in">len</span>(buckets)<span class="number">-1</span>].upperBound, +<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> math.NaN()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 upperBound 一樣的 bucket 合併</span></span><br><span class="line">    buckets = coalesceBuckets(buckets)</span><br><span class="line">    <span class="comment">// 確保 buckets 列表中的 count 為遞增</span></span><br><span class="line">    ensureMonotonic(buckets)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buckets 長度小於 2 的情況為</span></span><br><span class="line">    <span class="comment">// 1. buckets 為空</span></span><br><span class="line">    <span class="comment">// 2. buckets[0].upperBound 為正無限大</span></span><br><span class="line">    <span class="comment">// 滿足則回傳 NaN</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buckets) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.NaN()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最後一個的 count 必定包含所有觀察數</span></span><br><span class="line">    observations := buckets[<span class="built_in">len</span>(buckets)<span class="number">-1</span>].count</span><br><span class="line">    <span class="comment">// 若該組 buckets 沒有觀察數，則回傳 NaN</span></span><br><span class="line">    <span class="keyword">if</span> observations == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.NaN()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 百分位 q 在這組 buckets 中所對應的位置為 rank</span></span><br><span class="line">    rank := q * observations</span><br><span class="line">    <span class="comment">// 尋找該 rank 所在的 bucket</span></span><br><span class="line">    b := sort.Search(<span class="built_in">len</span>(buckets)<span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> buckets[i].count &gt;= rank &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 rank 所在為 upperBound 為無限大的 bucket</span></span><br><span class="line">    <span class="comment">// 回傳倒數第二個 bucket 的 upperBound</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="built_in">len</span>(buckets)<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buckets[<span class="built_in">len</span>(buckets)<span class="number">-2</span>].upperBound</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 rank 所在為最低的 bucket 且該 upperBound 小於等於 0</span></span><br><span class="line">    <span class="comment">// 則直接回傳該 upperBound</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &amp;&amp; buckets[<span class="number">0</span>].upperBound &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buckets[<span class="number">0</span>].upperBound</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        bucketStart <span class="type">float64</span></span><br><span class="line">        bucketEnd   = buckets[b].upperBound</span><br><span class="line">        count       = buckets[b].count</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</span><br><span class="line">        bucketStart = buckets[b<span class="number">-1</span>].upperBound</span><br><span class="line">        count -= buckets[b<span class="number">-1</span>].count</span><br><span class="line">        rank -= buckets[b<span class="number">-1</span>].count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// prometheus 假設一個前提，也就是在 bucket 中的</span></span><br><span class="line">    <span class="comment">// 分佈情況是線性的，因此可以使用線性內差的方式計算出</span></span><br><span class="line">    <span class="comment">// rank 對應的數值</span></span><br><span class="line">    <span class="keyword">return</span> bucketStart + (bucketEnd-bucketStart)*(rank/count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- markdownlint-restore MD010 -->
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>histogram_quantile 通常通常其會搭配 sum 與 rate 來使用，因此常會看到 <code>histogram_quantile(q, sum(rate()) by (le))</code> 這樣的 PromQL 出現。到目前為止，已經明白 histogram_quantile 背後的運作原理，再來就是以範例數據來強化記憶。</p>
<h3 id="情境說明"><a href="#情境說明" class="headerlink" title="情境說明"></a>情境說明</h3><p>情境與目標：監控的 Server 有兩個端點，分別為 <code>/user/</code> 與 <code>/system/</code>，我們要想要知道每 1 分鐘內 90 百分位的 http 處理時間 (不限定端點)。</p>
<h3 id="Metric-定義"><a href="#Metric-定義" class="headerlink" title="Metric 定義"></a>Metric 定義</h3><p>用來紀錄 http request 所需處理時間的 metric 的定義如下，其為 histogram 型態</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">prometheus.NewHistogramVec(prometheus.HistogramOpts&#123;</span><br><span class="line">    Name:    <span class="string">&quot;http_request_seconds&quot;</span>,</span><br><span class="line">    Help:    <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">    Buckets: prometheus.DefBuckets, <span class="comment">// []float64&#123;.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10&#125;</span></span><br><span class="line">&#125;, []<span class="type">string</span>&#123;<span class="string">&quot;handler&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>使用 PromQL 如下，即可得到想要的結果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">histogram_quantile(0.90, sum(rate(http_request_seconds_bucket[1m])) by (le))</span><br></pre></td></tr></table></figure>
<h3 id="以實例說明運作原理"><a href="#以實例說明運作原理" class="headerlink" title="以實例說明運作原理"></a>以實例說明運作原理</h3><p>接著，以實例作為輔助來解析這段 PromQL 的含義</p>
<h4 id="數據說明"><a href="#數據說明" class="headerlink" title="數據說明"></a>數據說明</h4><p>假設在時間點 <strong>t - 1m</strong> 時，metrics 的數值如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.005&quot;&#125; 5</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.01&quot;&#125; 111</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.025&quot;&#125; 491</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.05&quot;&#125; 879</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.1&quot;&#125; 1244</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.25&quot;&#125; 1708</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.5&quot;&#125; 1886</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;1&quot;&#125; 1960</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;2.5&quot;&#125; 2000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;5&quot;&#125; 2000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;10&quot;&#125; 2000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;+Inf&quot;&#125; 2000</span><br><span class="line"></span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.005&quot;&#125; 2</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.01&quot;&#125; 38</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.025&quot;&#125; 326</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.05&quot;&#125; 692</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.1&quot;&#125; 1083</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.25&quot;&#125; 1598</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.5&quot;&#125; 1842</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;1&quot;&#125; 1940</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;2.5&quot;&#125; 1994</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;5&quot;&#125; 2000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;10&quot;&#125; 2000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;+Inf&quot;&#125; 2000</span><br></pre></td></tr></table></figure>
<p>再假設在時間點 <strong>t</strong> 時，metrics 的數值如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.005&quot;&#125; 6</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.01&quot;&#125; 159</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.025&quot;&#125; 835</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.05&quot;&#125; 1592</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.1&quot;&#125; 2391</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.25&quot;&#125; 3315</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;0.5&quot;&#125; 3676</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;1&quot;&#125; 3844</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;2.5&quot;&#125; 4000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;5&quot;&#125; 4000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;10&quot;&#125; 4000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/user/&quot;,le=&quot;+Inf&quot;&#125; 4000</span><br><span class="line"></span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.005&quot;&#125; 7</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.01&quot;&#125; 144</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.025&quot;&#125; 844</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.05&quot;&#125; 1628</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.1&quot;&#125; 2400</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.25&quot;&#125; 3318</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;0.5&quot;&#125; 3720</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;1&quot;&#125; 3901</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;2.5&quot;&#125; 3981</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;5&quot;&#125; 4000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;10&quot;&#125; 4000</span><br><span class="line">http_request_seconds_bucket&#123;handler=&quot;/system/&quot;,le=&quot;+Inf&quot;&#125; 4000</span><br></pre></td></tr></table></figure>
<h4 id="計算步驟頗析"><a href="#計算步驟頗析" class="headerlink" title="計算步驟頗析"></a>計算步驟頗析</h4><p>首先計算 <code>rate(http_request_seconds_bucket[1m])</code>，即 <strong>t</strong> 時刻的 metric 的值減去 <strong>t - 1m</strong> 的 metric 的值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>rate(http_request_seconds_bucket&#123;handler=&quot;/user/&quot;&#125;[1m])</code></th>
<th><code>rate(http_request_seconds_bucket&#123;handler=&quot;/system/&quot;&#125;[1m])</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>le=0.005</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>le=0.01</td>
<td>48</td>
<td>106</td>
</tr>
<tr>
<td>le=0.025</td>
<td>344</td>
<td>518</td>
</tr>
<tr>
<td>le=0.05</td>
<td>713</td>
<td>936</td>
</tr>
<tr>
<td>le=0.1</td>
<td>1147</td>
<td>1317</td>
</tr>
<tr>
<td>le=0.25</td>
<td>1607</td>
<td>1720</td>
</tr>
<tr>
<td>le=0.5</td>
<td>1790</td>
<td>1878</td>
</tr>
<tr>
<td>le=1</td>
<td>1884</td>
<td>1961</td>
</tr>
<tr>
<td>le=2.5</td>
<td>2000</td>
<td>1987</td>
</tr>
<tr>
<td>le=5</td>
<td>2000</td>
<td>2000</td>
</tr>
<tr>
<td>le=10</td>
<td>2000</td>
<td>2000</td>
</tr>
<tr>
<td>le=+Inf</td>
<td>2000</td>
<td>2000</td>
</tr>
</tbody>
</table>
</div>
<p><code>sum(rate(http_request_seconds_bucket[1m])) by (le)</code> 則是將兩個 <code>rate</code> 的結果，根據 <code>le</code> 把結果相加起來</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>sum(rate(http_request_seconds_bucket[1m])) by (le)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>le=0.005</td>
<td>6</td>
</tr>
<tr>
<td>le=0.01</td>
<td>154</td>
</tr>
<tr>
<td>le=0.025</td>
<td>862</td>
</tr>
<tr>
<td>le=0.05</td>
<td>1649</td>
</tr>
<tr>
<td>le=0.1</td>
<td>2464</td>
</tr>
<tr>
<td>le=0.25</td>
<td>3327</td>
</tr>
<tr>
<td>le=0.5</td>
<td>3668</td>
</tr>
<tr>
<td>le=1</td>
<td>3845</td>
</tr>
<tr>
<td>le=2.5</td>
<td>3987</td>
</tr>
<tr>
<td>le=5</td>
<td>4000</td>
</tr>
<tr>
<td>le=10</td>
<td>4000</td>
</tr>
<tr>
<td>le=+Inf</td>
<td>4000</td>
</tr>
</tbody>
</table>
</div>
<p>最後，在 golang 內部會將這些 buckets 轉為 go 的 buckets 物件並呼叫 <code>bucketQuantile</code> 函數計算出 90 百分位對應的值，可以將最後的 <code>histogram_quantile</code> 運算等效成以下 golang 程式碼</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// histogram_quantile(0.90, sum(rate(http_request_seconds_bucket[1m])) by (le))</span></span><br><span class="line">bs := buckets&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.005</span>,</span><br><span class="line">        count:      <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.01</span>,</span><br><span class="line">        count:      <span class="number">154</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.025</span>,</span><br><span class="line">        count:      <span class="number">862</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.05</span>,</span><br><span class="line">        count:      <span class="number">1649</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.1</span>,</span><br><span class="line">        count:      <span class="number">2464</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.25</span>,</span><br><span class="line">        count:      <span class="number">3327</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">0.5</span>,</span><br><span class="line">        count:      <span class="number">3668</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">1</span>,</span><br><span class="line">        count:      <span class="number">3845</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">2.5</span>,</span><br><span class="line">        count:      <span class="number">3987</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">5</span>,</span><br><span class="line">        count:      <span class="number">4000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: <span class="number">10</span>,</span><br><span class="line">        count:      <span class="number">4000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        upperBound: math.Inf(+<span class="number">1</span>),</span><br><span class="line">        count:      <span class="number">4000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%f&quot;</span>, bucketQuantile(<span class="number">0.90</span>, bs))</span><br></pre></td></tr></table></figure>
<h3 id="舉一反三"><a href="#舉一反三" class="headerlink" title="舉一反三"></a>舉一反三</h3><p>這樣的 PromQL 是根據整體的數據來查看 90 百分位數的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">histogram_quantile(0.90, sum(rate(http_request_seconds_bucket[1m])) by (le))</span><br></pre></td></tr></table></figure>
<p>但若我們想要查看指定端點的話呢？非常簡單，假設我們只想查看 <code>/user/</code> 90 百分位數的值，只需加上篩選條件 <code>&#123;handler=&quot;/user/&quot;&#125;</code> 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">histogram_quantile(0.90, sum(rate(http_request_seconds_bucket&#123;handler=&quot;/user/&quot;&#125;[1m])) by (le))</span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/55162093/understanding-histogram-quantile-based-on-rate-in-prometheus">Understanding histogram_quantile based on rate in Prometheus</a></p>
</li>
<li><p><a href="https://github.com/prometheus/prometheus/blob/main/promql/quantile.go">Prometheus Source Code</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>prometheus</tag>
        <tag>histogram</tag>
        <tag>quantile</tag>
        <tag>sum</tag>
        <tag>by</tag>
        <tag>le</tag>
        <tag>rate</tag>
        <tag>promql</tag>
        <tag>tsdb</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] 使用 regular expression 驗證密碼長度與安全性</title>
    <url>/2021/06/12/python_regular_expression/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在申請使用者帳號時，常常會看到要求密碼內至少要幾個大寫、小寫與數字。若是我們自己開發的系統，要如何寫才能滿足所有條件？這時候就必須請出正規表示式 (regular expression 也稱為 regex)。</p>
<h2 id="訂定密碼原則"><a href="#訂定密碼原則" class="headerlink" title="訂定密碼原則"></a>訂定密碼原則</h2><p>在寫程式之前，需把所有的限制都先條列出來，避免遺漏或理解錯誤</p>
<ol>
<li>至少有 1 個數字</li>
<li>至少有 1 個小寫英文字母</li>
<li>至少有 1 個大寫英文字母</li>
<li>密碼長度在 6 ~ 20 個字母之間</li>
</ol>
<h2 id="Python-實現"><a href="#Python-實現" class="headerlink" title="Python 實現"></a>Python 實現</h2><p>現在就用 <code>Python</code> 來實現檢查密碼的功能吧！直接上程式碼再解釋</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = <span class="string">&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;6,20&#125;$&quot;</span></span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;Enter string to test: &quot;</span>)</span><br><span class="line">result = re.findall(pattern, password)</span><br><span class="line"><span class="keyword">if</span> (result):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Valid password&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Password not valid&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>regular expression</code> 找字串的原理關鍵是使用 <code>pattern</code>，如上程式碼中的 <code>&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;6,20&#125;$&quot;</code>，再使用 <code>re.findall</code> 查看字串裡面有沒有符合 <code>pattern</code>，若是有符合 <code>pattern</code>，則等同符合密碼原則。</p>
<p>仔細解析一下 <code>pattern</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pattern = <span class="string">&quot;^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;6,20&#125;$&quot;</span></span><br></pre></td></tr></table></figure>
<p>一堆符號看得眼花撩亂？我會拆成有 <code>(?=)</code> 的部分和沒有 <code>(?=)</code> 的部分來看</p>
<ul>
<li>有 <code>(?=)</code>的部分<ol>
<li><code>^(?=.*\d)</code>：從頭 (<code>^</code>) 檢查此字串是否有數字 (<code>.*\d</code>)。</li>
<li><code>^(?=.*[a-z])</code>：從頭 (<code>^</code>) 檢查此字串是否有小寫英文字母 (<code>.*[a-z]</code>)。</li>
<li><code>^(?=.*[A-Z])</code>：從頭 (<code>^</code>) 檢查此字串是否有小寫英文字母 (<code>.*[A-Z]</code>)。</li>
</ol>
</li>
<li>沒有 <code>(?=)</code> 的部分<ol>
<li><code>^.&#123;6,20&#125;$</code>：若上述 <code>(?=)</code> 的條件都滿足，再來找從頭 (<code>^</code>) 到尾 (<code>$</code>) 的字串長度是否在 6 至 20 之間。</li>
</ol>
</li>
</ul>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>正規表示式是非常好用的字串查找、檢查的工具，只要理解如何寫 <code>pattern</code>，就能寫出各種難以用 <code>if else</code> 判斷的功能。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>password</tag>
        <tag>regex</tag>
        <tag>regular</tag>
        <tag>expression</tag>
      </tags>
  </entry>
  <entry>
    <title>[ReactJS] 從頭建立一個 ReactJS 專案</title>
    <url>/2021/10/25/reactjs_from_scratch/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已經有許多套件 (如：CRA、Next.js) 幫忙將 ReactJS 的開發環境包好，讓前端工程師不需花心力在 Webpack 與 Babel 的設定上，對初學者來說是友善的。但相信到一定的程度後，會想要從頭建立一個 ReactJS 專案，藉此了解每個依賴包的作用。因此這篇文章記錄如何從頭設定 Babel、Webpack 讓 ReactJS 可以正常運作，讓未來的自己與讀者們可以從中複習與學習。</p>
<!-- markdownlint-disable MD034 -->
<a class="btn" href="https://github.com/weirenxue/react-from-scratch" title="從頭開始建立的 ReactJS 專案成品">
            <i class="fab fa-react"></i>專案成品 GitHub
          </a>
<!-- markdownlint-restore MD034 -->
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>先確認有安裝 Node.js，若沒有可先至<a href="https://nodejs.org/en/">官方網站</a>根據自己的作業系統下載並安裝，至終端機確認 Node 版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p ~]$ node -v</span><br><span class="line">v14.17.5</span><br></pre></td></tr></table></figure>
<h2 id="初始化-Node-專案"><a href="#初始化-Node-專案" class="headerlink" title="初始化 Node 專案"></a>初始化 Node 專案</h2><p>建立一個名稱為 <code>react-from-scratch</code> 的目錄並初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p ~]$ <span class="built_in">mkdir</span> react-from-scratch</span><br><span class="line">[wrxue@p ~]$ <span class="built_in">cd</span> react-from-scratch</span><br><span class="line">[wrxue@p react-from-scratch]$ npm init -y</span><br></pre></td></tr></table></figure>
<p>初始化使用 <code>npm init -y</code> 是偷懶的方式，讓我們可以跳過填寫專案資訊的步驟，直接建立專案，至於專案的資訊等到之後回頭來修改 <code>package.json</code> 即可。讀者也可以選擇使用 <code>npm init</code> 認真的將專案資訊透過問答方式填寫完成。</p>
<h2 id="ReactJS"><a href="#ReactJS" class="headerlink" title="ReactJS"></a>ReactJS</h2><h3 id="ReactJS-安裝"><a href="#ReactJS-安裝" class="headerlink" title="ReactJS 安裝"></a>ReactJS 安裝</h3><p>不用多說，要用 ReactJS 開發就一定要安裝它啊！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p react-from-scratch]$ npm install react react-dom</span><br></pre></td></tr></table></figure>
<ul>
<li><code>react</code>：ReactJS 主要功能皆包含在內。</li>
<li><code>react-dom</code>：可說是 ReactJS 與 DOM 之間的橋樑，通常只會用到 <code>ReactDOM.render()</code> 函式。</li>
</ul>
<h3 id="ReactJS-程式碼"><a href="#ReactJS-程式碼" class="headerlink" title="ReactJS 程式碼"></a>ReactJS 程式碼</h3><p>建立 <code>./src/App.js</code>，輸出一個 <code>App</code> 元件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>從頭開始建立 ReactJS 專案成功!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
<p>建立 <code>./src/index.js</code>，使用 <code>App</code> 元件並使用 <code>ReactDOM.render()</code> 將其顯示在網頁上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="Babel-安裝"><a href="#Babel-安裝" class="headerlink" title="Babel 安裝"></a>Babel 安裝</h3><p>Babel 是寫 ES6 以上的語法或 ReactJS 時，常常會用到的一個套件，扮演著轉譯 (transpiling，有些人會說編譯，個人認為是不對的說法) 的角色，將這些尚未普及的語法轉譯為 ES5 語法，使瀏覽器可以順利執行。也因此，Babel 是需要安裝的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p react-from-scratch]$ npm install --save-dev @babel/core @babel/preset-react</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@babel/core</code>：使用 Babel 執行轉譯動作的關鍵套件。</li>
<li><code>@babel/preset-react</code>：Babel preset 則是一組含有特定目標語法集合，例如：<code>preset-react</code> 可以使 Babel 將目標語法 <code>jsx</code> 轉譯成 <code>createElement</code>。</li>
</ul>
<h3 id="Babel-設定"><a href="#Babel-設定" class="headerlink" title="Babel 設定"></a>Babel 設定</h3><p>Babel 在預設的情況下不會做任何事，需要透過 <code>.babelrc</code> 檔案來告訴它應該做甚麼，因此先於專案根目錄建立 <code>.babelrc</code> 檔案，並且內容如下，意思是跟 Babel 說：「請幫我使用 <code>preset-react</code> 這組語法集合轉譯程式碼。」</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@babel/preset-react&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="Webpack-安裝"><a href="#Webpack-安裝" class="headerlink" title="Webpack 安裝"></a>Webpack 安裝</h3><p>Webpack 可以幫我們將各種資源 (.js/.sass/.png...等等) 打包為可以發布的狀態，一個專案只需設定一次，便能夠讓我們只專注於 ReactJS 應用開發的部分，這麼方便的套件是必須要安裝的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p react-from-scratch]$ npm install --save-dev webpack webpack-cli babel-loader html-webpack-plugin</span><br></pre></td></tr></table></figure>
<ul>
<li><code>webpack</code>：包含 Webpack 主要功能的套件。</li>
<li><code>webpack-cli</code>：Webpack 4 以上已將 CLI 從 <code>webpack</code> 獨立出來並命名為 <code>webpack-cli</code>。</li>
<li><code>babel-loader</code>：Webpack 在打包過程中，可透過 <code>babel-loader</code> 來載入 Babel 轉譯指定檔案。</li>
<li><code>html-webpack-plugin</code>：一個簡化建立 HTML 檔案的套件，特別是當每次 bundle 出來的 js 檔名都包含雜湊值 (Hash Value) 時，特別有用。</li>
</ul>
<h3 id="Webpack-設定"><a href="#Webpack-設定" class="headerlink" title="Webpack 設定"></a>Webpack 設定</h3><p>於專案根目錄建立內容如下的 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;WRXUE 手把手從頭開始建立 ReactJS 專案&#x27;</span>,</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;template.html&#x27;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>entry</code>：使用 Webpack 打包時，第一個要進入的檔案為 <code>./src/index.js</code>。</li>
<li><code>output</code>：輸出檔案相關設定。<ul>
<li><code>filename</code>：打包完成的檔案應該有的檔名形式，方括號 (<code>[]</code>) 內的字串是將會被替代的字串。</li>
<li><code>path</code>：打包後的檔案輸出的目錄。</li>
</ul>
</li>
<li><code>plugins</code>：使用外掛套件 <code>html-webpack-plugin</code> 協助打包，它可以自動將打包好的 js 自動補進 html 檔案做引用 (例如：<code>&lt;script defer=&quot;defer&quot; src=&quot;index.49aa003bf7e7b451d135.js&quot;&gt;&lt;/script&gt;</code>)，毋須每次檔名有更動就需要手動輸入。</li>
<li><code>module.rules</code>：Webpack 會依據指定的 rule 處理對應的檔案。<ul>
<li><code>test</code>：檔名的匹配模式，即只要結尾為 <code>.js</code> 或 <code>.jsx</code> 的檔案皆為匹配成功。</li>
<li><code>use</code>：若匹配，則使用 <code>babel-loader</code> 來處理匹配成功的檔案。</li>
</ul>
</li>
</ul>
<p><code>html-webpack-plugin</code> 可以使用模板來建立 html 檔案，因為在 ReactJS 中通常會需要 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 來作為根結點，因此於專案根目錄建立 <code>template.html</code>，其內容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>htmlWebpackPlugin.options</code>：在 <code>webpack.config.js</code> 中會將一個物件傳給 <code>html-webpack-plugin</code> 套件，在模板中可透過 EJS 語法來存取對應的值。</li>
</ul>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>在 package.json 檔案中的 <code>scripts</code> 加上啟用 webpack 的指令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>執行 Webpack 打包應用程式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[wrxue@p react-from-scratch]$ npm run build</span><br><span class="line"></span><br><span class="line">&gt; react-from-scratch@1.0.0 build ~/react-from-scratch</span><br><span class="line">&gt; webpack</span><br><span class="line"></span><br><span class="line">asset index.b637f7a49c9b2904dcbd.js 127 KiB [emitted] [immutable] [minimized] (name: index) 1 related asset</span><br><span class="line">asset index.html 381 bytes [emitted] [compared <span class="keyword">for</span> emit]</span><br><span class="line">orphan modules 200 bytes [orphan] 1 module</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>使用瀏覽器開啟 <code>./dist/index.html</code> 且能看到結果即代表 ReactJS 開發環境建置成功。</p>
          </div>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/ReactJS-%E5%BE%9E%E9%A0%AD%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-ReactJS-%E5%B0%88%E6%A1%88%2Ffinal.png?alt=media&amp;token=7756b5cd-c774-4d0b-abae-b07928e478c4" alt="ReactJS 專案建立完成"><span class="image-caption">ReactJS 專案建立完成</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>筆者猜測多數人應該是從 CRA 開始接觸 ReactJS 的開發，再慢慢地去瞭解 Webpack、Babel 等這些關鍵套件的使用。因為筆者自己也不例外，所以想藉由這個機會從頭開始建立一個 ReactJS 開發環境，並明確的理解每個套件的分工。過程中拜讀許多前輩產出的文獻，不乏將原理說明清楚的好文，也因此對於 ReactJS 專案背後的運作更為清晰，同時將有用的文獻紀錄下來供讀者參考。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/34114350/react-vs-reactdom">React vs ReactDOM?</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/47721169/babel-vs-babel-core-vs-babel-loader-vs-babel-preset-2015-vs-babel-preset-react-v">babel vs babel-core vs babel-loader vs babel-preset-2015 vs babel-preset-react vs babel-polyfill</a></p>
</li>
<li><p><a href="https://ithelp.ithome.com.tw/articles/10185730?sc=rss.qu">React Day12 - Babel介紹</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/51948057/install-webpack-vs-install-webpack-cli/51948245">install webpack VS install webpack-cli?</a></p>
</li>
<li><p><a href="https://webpack.js.org/guides/getting-started/">Getting Started | webpack</a></p>
</li>
<li><p><a href="https://webpack.js.org/configuration/output/">Output | webpack</a></p>
</li>
<li><p><a href="https://webpack.js.org/plugins/html-webpack-plugin/">HtmlWebpackPlugin</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/49227613/div-id-root-div-not-transfering-in-webpack-build/49228840">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; not transfering in webpack build</a></p>
</li>
<li><p><a href="https://dev.to/nikhilkumaran/don-t-use-create-react-app-how-you-can-set-up-your-own-reactjs-boilerplate-43l0">Don&#39;t use create-react-app: How you can set up your own reactjs boilerplate.</a></p>
</li>
<li><p><a href="https://dev.to/ruppysuppy/create-react-app-from-scratch-like-a-pro-de0">Create React App from Scratch like a Pro</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>ejs</tag>
        <tag>react</tag>
        <tag>cra</tag>
        <tag>scratch</tag>
        <tag>webpack</tag>
        <tag>babel</tag>
        <tag>next</tag>
        <tag>jsx</tag>
        <tag>preset</tag>
      </tags>
  </entry>
  <entry>
    <title>[Remove] Ubuntu 解除安裝應用程式</title>
    <url>/2021/06/17/remove_ubuntu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安裝與移除幾乎是每天都會作到的動作，移除相較安裝困難，Windows 作業系統中只需要進控制台移除程式，而在 Linux 只能使用指令來做移除的動作，且不確定是否真的移除乾淨相關檔案，最近剛好要移除 libreoffice，因此藉此紀錄移除程式的步驟與指令相對的意義。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="解除安裝"><a href="#解除安裝" class="headerlink" title="解除安裝"></a>解除安裝</h2><p>先移除目標程式及相關檔案</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get purge libreoffice*.*    <span class="comment"># 移除程式包含配置檔 (configuration file)</span></span><br></pre></td></tr></table></figure>
<p>移除因應用程式相依所需而自動安裝，但現在已經不再需要的套件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get autoremove              <span class="comment"># 移除原為「自動」安裝但現在不再需要的套件</span></span><br></pre></td></tr></table></figure>
<p>移除相關的 deb 檔案</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get clean <span class="comment"># 除了「lock」檔案，移除在 /var/cache/apt/archives/ 與</span></span><br><span class="line">                              <span class="comment"># /var/cache/apt/archives/partial/ 目錄下的檔案，</span></span><br><span class="line">                              <span class="comment"># 這兩個目錄是執行「apt-get install」或「apt-get upgrade」指令時，</span></span><br><span class="line">                              <span class="comment"># 放置下載的相關套件所在，因為已經用不到，所以這些東西也可以清理掉</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
        <tag>remove</tag>
        <tag>libreoffice</tag>
        <tag>uninstall</tag>
        <tag>clean</tag>
      </tags>
  </entry>
  <entry>
    <title>[Share] VMware 裡的 CentOS 使用共享資料夾</title>
    <url>/2021/06/19/share_vmware_centos/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>共享資料夾是使用虛擬機時常會碰到的需求，最近遇到要在 CentOS 中設定共享資料夾，沒想到挺麻煩的，因此記錄下來方便以後查閱。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>實體機 (Host) 作業系統：Windows 10</li>
<li>虛擬機 (Guest) 作業系統：CentOS 8.2</li>
<li>虛擬機軟體：VMware 15.5.6</li>
</ul>
<h2 id="設定-Host-共享資料夾"><a href="#設定-Host-共享資料夾" class="headerlink" title="設定 Host 共享資料夾"></a>設定 Host 共享資料夾</h2><p>在 Windows 上於 VMware 設定 Host 要分享的的共享資料夾，這裡的範例是 <code>D:\VMware\Shared</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Share-VMware-%E8%A3%A1%E7%9A%84-CentOS-%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E8%B3%87%E6%96%99%E5%A4%BE%2Fshare_folder.png?alt=media&amp;token=311502b1-730c-4d26-8d29-6eea00ea2fd0" alt="Host 共享資料夾"><span class="image-caption">Host 共享資料夾</span></p>
<h2 id="設定-Guest-共享資料夾"><a href="#設定-Guest-共享資料夾" class="headerlink" title="設定 Guest 共享資料夾"></a>設定 Guest 共享資料夾</h2><p>在 CentOS 8.2 中建立一個要當共享資料夾的目錄</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ <span class="built_in">mkdir</span> ~/shares</span><br></pre></td></tr></table></figure>
<p>掛載共享資料夾，其中 <code>Shared</code> 是 Host 的共享資料夾名稱， <code>~/shares</code> 是 Guest 的共享目錄</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo /usr/bin/vmhgfs-fuse .host:/Shared ~/shares -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure>
<p>此時 Guest 內的 <code>~/shares</code> 目錄與 Host 的 <code>D:\VMware\Shared</code> 資料夾就是互通的囉！</p>
<div class="note info">
            <p>若出現 <code>/usr/bin/vmhgfs-fuse: command not found</code> 訊息，可以參考 <a href="https://docs.vmware.com/en/VMware-Tools/11.3.0/com.vmware.vsphere.vmwaretools.doc/GUID-08BB9465-D40A-4E16-9E15-8C016CC8166F.html">Manually Install VMware Tools on Linux</a> 官方文章，先將 <code>VMware Tools</code> 安裝完成之後，再嘗試一次。</p>
          </div>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://docs.vmware.com/en/VMware-Workstation-Player-for-Windows/15.0/com.vmware.player.win.using.doc/GUID-AB5C80FE-9B8A-4899-8186-3DB8201B1758.html">Mounting Shared Folders in a Linux Guest</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>8.2</tag>
        <tag>windows</tag>
        <tag>10</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>[Sourcetree] 修改 Git 遠端登入密碼</title>
    <url>/2021/09/24/sourcetree_git/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自從 2021 年 8 月 13 GitHub 強制實施使用 token-based authentication 機制，我們就需要常常更新 Git 工具所儲存的密碼。Sourcetree 這套 Git GUI 工具無法直接修改已登入過的密碼，取而代之的是需要找到它的帳密檔且將帳密刪除，才有機會輸入新的密碼。</p>
<h2 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h2><ol>
<li>在 <code>%LOCALAPPDATA%\Atlassian\SourceTree\</code> 路徑下找到 <code>passwd</code> 檔案並開啟。</li>
<li>刪除需要更新密碼的帳密，例如 <!-- markdownlint-disable MD031 -->
 <figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">weirenxue@github.com</span><br><span class="line">AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAVU8+MiF2OkWTz5prBbUaWQAAAAACAAAAAAAQZgAAAAEAACAAAABqvcm8TO9vqfbZYQCXljW2HwwKn/<span class="number">6</span>bIfOoT5oupUchfwAAAAAOgAAAAAIAACAAAAAGdnFITmW2H2I9gZU1xqp/NdBat2Rhwi0t+Q7E5qQ1y2AAAACJQV/p+Y2085gpc5Z6E/oMnz9/<span class="number">0</span>o9licRiWGbvhuX51vJaU3KDCurNE5cTUx1BpsbqnjZgvyL0NfV2ayXAn5l5OmJgNTgWvWrqmI+nLHfSxc/voCm+M+jvnwhrwLwHtmlAAAAAONp3+v5N6qb6UY0DLHsXt4uMi8I3CSkuyM2THC4gt4nuonn9vccPP94lQUq2JlJHz0tZ85nhcyZ+OZ6HLXLIPw==</span><br></pre></td></tr></table></figure>
 <!-- markdownlint-restore MD031 --></li>
<li>根據文章 <a href="/2021/08/17/github_pat/">[GitHub] Please use a personal access token instead.</a> 申請 GitHub 的 PAT。</li>
<li>回到 Sourcetree 進行 fetch/pull/push 操作，便會跳出帳密輸入提示，此時可以將前一步驟產生的 PAT 輸入在密碼欄位。</li>
<li>若順利完成 fetch/pull/push 操作，表示密碼更新為可用的 PAT 囉！</li>
</ol>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://stackoverflow.com/questions/45690641/sourcetree-wont-let-me-delete-password/51395583">SourceTree won&#39;t let me delete password</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>pat</tag>
        <tag>password</tag>
        <tag>sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title>[USB] 有接 USB 但在對應軟體中找不到序列埠的原因與解決方法</title>
    <url>/2021/06/17/usb_usb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Linux 使用序列埠比較麻煩的是權限的問題，在有接上 USB 且 <code>/dev</code> 目錄下有看到所連接的裝置檔案 (例如：ttyUSB0)，若在軟體中還是沒有讀取到的話，通常就是權限設定錯誤的問題。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="問題原因"><a href="#問題原因" class="headerlink" title="問題原因"></a>問題原因</h2><p>先確認目標裝置的權限，可以看到是 <code>660</code> 權限，也就是說非擁有者 (root) 且非群組 (dialout) 成員的其他人，是不能讀取的，這也是為什麼應用程式內讀不到的原因</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ <span class="built_in">ls</span> -al /dev/ttyUSB*</span><br><span class="line">crw-rw---- 1 root dialout 188, 0 十二  4 16:53 /dev/ttyUSB0</span><br><span class="line">crw-rw---- 1 root dialout 188, 1 十二  4 16:53 /dev/ttyUSB1</span><br><span class="line">crw-rw---- 1 root dialout 188, 2 十二  4 16:53 /dev/ttyUSB2</span><br><span class="line">crw-rw---- 1 root dialout 188, 3 十二  4 16:53 /dev/ttyUSB3</span><br></pre></td></tr></table></figure>
<h2 id="加入群組"><a href="#加入群組" class="headerlink" title="加入群組"></a>加入群組</h2><p>一般使用者預設是沒有加入 <code>dialout</code> 群組的，因此將自己加入此群組藉此繼承擁有讀取序列埠的權限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo usermod -a -G dialout user  <span class="comment"># user 當然就是使用者帳號，依需求更改</span></span><br></pre></td></tr></table></figure>
<p>再回到應用程式內找尋 Serial Port 應該就能看到囉！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>port</tag>
        <tag>18.04</tag>
        <tag>usb</tag>
        <tag>serail</tag>
        <tag>privilege</tag>
        <tag>dialout</tag>
        <tag>tty</tag>
        <tag>usermod</tag>
      </tags>
  </entry>
  <entry>
    <title>[User] Linux 新增使用者並賦予其使用 sudo 的權限</title>
    <url>/2021/06/17/user_linux_sudo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多人多工是 Linux 本身就具備的功能，因此新增或移除使用者帳號與更改權限是管理員必備的技能。這篇文章記錄如何在 Ubuntu、CentOS 上新增 sudoer。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><div class="tabs" id="環境"><ul class="nav-tabs"><li class="tab active"><a href="#環境-1">Ubuntu</a></li><li class="tab"><a href="#環境-2">CentOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="環境-1"><ul>
<li>Ubuntu 18.04 LTS</li>
</ul></div><div class="tab-pane" id="環境-2"><ul>
<li>CentOS 8.2</li>
</ul></div></div></div>
<h2 id="新增帳號"><a href="#新增帳號" class="headerlink" title="新增帳號"></a>新增帳號</h2><div class="tabs" id="新增帳號"><ul class="nav-tabs"><li class="tab active"><a href="#新增帳號-1">Ubuntu</a></li><li class="tab"><a href="#新增帳號-2">CentOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="新增帳號-1"><p>開啟 Terminal，新增帳號叫做 <code>test</code>，並填寫相關資料</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo adduser <span class="built_in">test</span>        <span class="comment"># test 是使用者帳號</span></span><br><span class="line">Adding user `<span class="built_in">test</span><span class="string">&#x27; ...</span></span><br><span class="line"><span class="string">Adding new group `test&#x27;</span> (1003) ...</span><br><span class="line">Adding new user `<span class="built_in">test</span><span class="string">&#x27; (1003) with group `test&#x27;</span> ...</span><br><span class="line">Creating home directory `/home/test<span class="string">&#x27; ...</span></span><br><span class="line"><span class="string">Copying files from `/etc/skel&#x27;</span> ...</span><br><span class="line">Enter new UNIX password:     <span class="comment"># 這裡是輸入密碼</span></span><br><span class="line">Retype new UNIX password:    <span class="comment"># 這裡是確認密碼</span></span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information <span class="keyword">for</span> <span class="built_in">test</span></span><br><span class="line">Enter the new value, or press ENTER <span class="keyword">for</span> the default</span><br><span class="line"> Full Name []: <span class="built_in">test</span>   <span class="comment"># 使用者全名</span></span><br><span class="line"> Room Number []:      <span class="comment"># 使用者房號</span></span><br><span class="line"> Work Phone []:       <span class="comment"># 使用者工作電話</span></span><br><span class="line"> Home Phone []:       <span class="comment"># 家用電話</span></span><br><span class="line"> Other []:            <span class="comment"># 備註</span></span><br><span class="line">Is the information correct? [Y/n] Y     <span class="comment"># 確認上述資料無誤後給Y</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="新增帳號-2"><p>開啟 Terminal，新增帳號叫做 <code>test</code>，並填寫相關資料</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo adduser <span class="built_in">test</span>  <span class="comment"># 新增帳號 test</span></span><br><span class="line">[user@localhost ~]$ sudo passwd <span class="built_in">test</span>   <span class="comment"># 修改 test 的密碼</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="賦予使用-sudo-指令的權限"><a href="#賦予使用-sudo-指令的權限" class="headerlink" title="賦予使用 sudo 指令的權限"></a>賦予使用 sudo 指令的權限</h2><div class="tabs" id="賦予使用sudo指令的權限"><ul class="nav-tabs"><li class="tab active"><a href="#賦予使用sudo指令的權限-1">Ubuntu</a></li><li class="tab"><a href="#賦予使用sudo指令的權限-2">CentOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="賦予使用sudo指令的權限-1"><p>需將該使用者增加至 <code>sudo</code> 群組，才可使用 <code>sudo</code> 指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo adduser <span class="built_in">test</span> sudo</span><br></pre></td></tr></table></figure>
<p>此時登入 <code>test</code> 帳號，開啟 Terminal，輸入以下指令驗證有使用 <code>sudo</code> 的權限，若看到有列出 <code>/root</code> 目錄下的檔案資訊，則表示 <code>test</code> 帳號擁有可以使用 <code>sudo</code> 的權限了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>@pc:~$ sudo <span class="built_in">ls</span> -al /root</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>:</span><br><span class="line">total 20</span><br><span class="line">drwx------  3 root root 4096  八   6  2019 .</span><br><span class="line">drwxr-xr-x 24 root root 4096  三   6 13:55 ..</span><br><span class="line">-rw-r--r--  1 root root 3106  四   9  2018 .bashrc</span><br><span class="line">drwx------  2 root root 4096  八   6  2019 .cache</span><br><span class="line">-rw-r--r--  1 root root  148  八  17  2015 .profile</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="賦予使用sudo指令的權限-2"><p>接下來要將使用者加到 <code>sudoer</code> 群組，與 Ubuntu 不同的是在 CentOS 是直接去更改文件中的內容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo visudo     <span class="comment"># visudo 就是 vi sudoers啦！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下為 suduers 檔案內容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Next comes the main part: which users can run what software on</span></span><br><span class="line"><span class="comment">## which machines (the sudoers file can be shared between multiple</span></span><br><span class="line"><span class="comment">## systems).</span></span><br><span class="line"><span class="comment">## Syntax:</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">##      user    MACHINE=COMMANDS</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## The COMMANDS section may have other options added to it.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)       ALL   <span class="comment"># 這行是預設</span></span><br><span class="line">user    ALL=(ALL)       ALL   <span class="comment"># 這行是用「root」身份加的，若沒有這行，就無法以「user」執行sudo</span></span><br><span class="line"><span class="built_in">test</span>    ALL=(ALL)       ALL   <span class="comment"># 這個步驟要加上這行</span></span><br></pre></td></tr></table></figure>
<p>此時登入 <code>test</code> 帳號，開啟 Terminal，輸入以下指令驗證有使用 <code>sudo</code> 的權限，若看到有列出 <code>/root</code> 目錄下的檔案資訊，則表示 <code>test</code> 帳號擁有可以使用 <code>sudo</code> 的權限了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@localhost ~]$ sudo <span class="built_in">ls</span> -al /root</span><br><span class="line">[sudo] password <span class="keyword">for</span> <span class="built_in">test</span>: </span><br><span class="line">total 32</span><br><span class="line">dr-xr-x---.  5 root root  205 Sep 10 08:18 .</span><br><span class="line">dr-xr-xr-x. 17 root root  224 Sep  9 16:48 ..</span><br><span class="line">-rw-------.  1 root root 1369 Sep  9 16:57 anaconda-ks.cfg</span><br><span class="line">-rw-------.  1 root root   13 Sep 10 08:18 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root   18 May 11  2019 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root  176 May 11  2019 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root  176 May 11  2019 .bashrc</span><br><span class="line">drwx------.  3 root root   19 Sep  9 19:50 .cache</span><br><span class="line">drwx------.  3 root root   18 Sep  9 19:50 .config</span><br><span class="line">-rw-r--r--.  1 root root  100 May 11  2019 .cshrc</span><br><span class="line">drwx------.  3 root root   25 Sep  9 19:50 .dbus</span><br><span class="line">-rw-r--r--.  1 root root 1479 Sep  9 19:50 initial-setup-ks.cfg</span><br><span class="line">-rw-r--r--.  1 root root  129 May 11  2019 .tcshrc</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="移除使用-sudo-指令的權限"><a href="#移除使用-sudo-指令的權限" class="headerlink" title="移除使用 sudo 指令的權限"></a>移除使用 sudo 指令的權限</h2><div class="tabs" id="移除使用sudo指令的權限"><ul class="nav-tabs"><li class="tab active"><a href="#移除使用sudo指令的權限-1">Ubuntu</a></li><li class="tab"><a href="#移除使用sudo指令的權限-2">CentOS</a></li></ul><div class="tab-content"><div class="tab-pane active" id="移除使用sudo指令的權限-1"><p>與 <code>adduser</code> 相對的指令是 <code>deluser</code>，將使用者 <code>test</code> 從 <code>sudo</code> 群組中移除，必須注意一定要加上群組名稱 <code>sudo</code>，否則會直接將該使用者移除</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo deluser <span class="built_in">test</span> sudo</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="移除使用sudo指令的權限-2"><p>與加入使用者進 <code>sudoer</code> 群組的步驟相反，將使用者從文件中移除，即可移除使用者使用 <code>sudo</code> 指令的權限囉！</p></div></div></div>
<!-- markdownlint-disable MD033 -->
<script>
    tabs = [];
    document.querySelectorAll('.nav-tabs .tab a').forEach((element) => {
        arr = element.href.split('-');
        index = arr[arr.length - 1]
        if (tabs[index] === undefined)
            tabs[index] = []
        tabs[index].push(element);
    });
    tabs.forEach((elements) => {
        elements.forEach((element) => {
            element.addEventListener('click', () => {
                elements.forEach((e) => {
                    e.click()
                })
            })
        });
    });
</script>

<!-- markdownlint-restore MD033 -->
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>8.2</tag>
        <tag>user</tag>
        <tag>18.04</tag>
        <tag>adduser</tag>
        <tag>deluser</tag>
        <tag>sudo</tag>
        <tag>sudoer</tag>
      </tags>
  </entry>
  <entry>
    <title>[WIN32 API] 函數使用範例</title>
    <url>/2021/06/15/win32_api_function_example/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在閱讀書藉「加密與解密」時，發現很多視窗的開發會用到 <code>DialogBoxParam</code> 等 <code>WIN32 API</code>，引發我想知道這些函數如何使用的好奇心，但網路上的文章總是沒有一個好例子，可以讓我直接 Build 看效果。</p>
<p>因此我看著文件慢慢的嘗試，寫出一個可以用的應用來。這裡收集了個人對於 <code>WIN32 API</code> 調用的範例，除了供大家參考外，自己也可以隨時複習。</p>
<h2 id="原始碼"><a href="#原始碼" class="headerlink" title="原始碼"></a>原始碼</h2><ol>
<li><a href="https://github.com/weirenxue/dialogboxparam-example">DialogBoxParam</a></li>
<li><a href="https://github.com/weirenxue/enablemenuitem-example">EnableMenuItem, GetSubMenu, GetMenuItemID</a></li>
<li><a href="https://github.com/weirenxue/settimer-example">SetTimer</a></li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>win32</tag>
        <tag>api</tag>
        <tag>example</tag>
        <tag>dialogboxparam</tag>
        <tag>enablemenuitem</tag>
        <tag>getsubmenu</tag>
        <tag>getmenuitemid</tag>
        <tag>settimer</tag>
      </tags>
  </entry>
  <entry>
    <title>[WSL] 透過 WSL2 與 VS Code 在 Windows 進行 Linux 應用開發</title>
    <url>/2022/03/22/wsl_vscode/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跨平台是一種趨勢，但也造成開發上許多不便之處。例如：有些服務 (Server) 只能運行在 Windows 環境，而對應的用戶端 (Client) 開發被要求在 Linux 環境。這種情況下，可能會被較多人採用的是 VM 的技術，用以建置這樣的開發環境。得益於 Windows 近年來推出的 WSL2，使虛擬化技術更進一步，成為一種解決方案，因此這篇文章將記錄如何安裝 WSL2 並搭配 VS Code 在 Windows 上進行 Linux 應用開發。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10 19043.1586</li>
</ul>
<h2 id="安裝-WSL2"><a href="#安裝-WSL2" class="headerlink" title="安裝 WSL2"></a>安裝 WSL2</h2><p>安裝 WSL2 的 Windows 10 需求如下 (參考：<a href="https://docs.microsoft.com/zh-tw/windows/wsl/install-manual?ranMID=24542&amp;ranEAID=je6NUbpObpQ&amp;ranSiteID=je6NUbpObpQ-f32b.xkdG0X8ejIGEBnJOQ&amp;epi=je6NUbpObpQ-f32b.xkdG0X8ejIGEBnJOQ&amp;irgwc=1&amp;OCID=AID2200057_aff_7593_1243925&amp;tduid=%28ir__lld2cjdhuckf62ui2aruilpr6e2xtie69qhiws9n00%29%287593%29%281243925%29%28je6NUbpObpQ-f32b.xkdG0X8ejIGEBnJOQ%29%28%29&amp;irclickid=_lld2cjdhuckf62ui2aruilpr6e2xtie69qhiws9n00#step-2---check-requirements-for-running-wsl-2">較舊版本的 WSL 手動安裝步驟</a>)</p>
<ul>
<li>若為 X64 系統：版本 1903 或更高版本，含組建 18362 或更高組建。</li>
<li>若為 ARM64 系統：版本 2004 或更高版本，含組建 19041 或更高組建。</li>
<li>低於 18362 的組建不支援 WSL 2。使用 Windows 更新小幫手來更新您的 Windows 版本。</li>
</ul>
<h3 id="開啟虛擬化技術-VT"><a href="#開啟虛擬化技術-VT" class="headerlink" title="開啟虛擬化技術 (VT)"></a>開啟虛擬化技術 (VT)</h3><p>WSL2 是一種虛擬化技術的產物，使用之前必須開啟 CPU 虛擬化技術 (VT, Virtual Technology) 功能，開啟的方法是先進入 BIOS，<code>進階設定 (F7) -&gt; 進階 -&gt; 處理器設定 -&gt; Intel (VMX) 虛擬化技術</code>，根據 BIOS 版本與 CPU 廠牌，設定的位置與名稱可能有些微差異</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/WSL-%E9%80%8F%E9%81%8E-WSL2-%E8%88%87-VS-Code-%E5%9C%A8-Windows-%E9%80%B2%E8%A1%8C-Linux-%E6%87%89%E7%94%A8%E9%96%8B%E7%99%BC%2Fbios_vt.jpg?alt=media&amp;token=48e34d63-f526-4bf4-9cb3-3a0f52c3cfea" alt="啟用 Intel CPU 虛擬化技術"><span class="image-caption">啟用 Intel CPU 虛擬化技術</span></p>
<h3 id="安裝-WSL2-與-Ubuntu-20-04"><a href="#安裝-WSL2-與-Ubuntu-20-04" class="headerlink" title="安裝 WSL2 與 Ubuntu 20.04"></a>安裝 WSL2 與 Ubuntu 20.04</h3><p>以系統管理員權限開啟 Terminal，首先查看有哪些可以使用的 Linux 發布版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; wsl --list --online</span><br><span class="line">以下是可安裝的有效通訊群組清單。</span><br><span class="line">「*」表示預設的通訊群組。</span><br><span class="line">使用「wsl--安裝-d 」安裝。&lt;Distro&gt;</span><br><span class="line"></span><br><span class="line">  NAME            FRIENDLY NAME</span><br><span class="line">* Ubuntu          Ubuntu</span><br><span class="line">  Debian          Debian GNU/Linux</span><br><span class="line">  kali-linux      Kali Linux Rolling</span><br><span class="line">  openSUSE-42     openSUSE Leap 42</span><br><span class="line">  SLES-12         SUSE Linux Enterprise Server v12</span><br><span class="line">  Ubuntu-16.04    Ubuntu 16.04 LTS</span><br><span class="line">  Ubuntu-18.04    Ubuntu 18.04 LTS</span><br><span class="line">  Ubuntu-20.04    Ubuntu 20.04 LTS</span><br></pre></td></tr></table></figure>
<p>選定 Linux 版本 (這裡選定 Ubuntu 20.04 LTS)，執行指令安裝 WSL2，等待安裝完畢並重新開機</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; wsl --install --distribution Ubuntu-20.04</span><br><span class="line">正在安裝：Windows 子系統 Linux 版</span><br><span class="line">已完成安裝 Windows 子系統 Linux 版。</span><br><span class="line">正在下載：Ubuntu 20.04 LTS</span><br><span class="line">已成功執行所要求的操作。請重新開機，變更才能生效。</span><br></pre></td></tr></table></figure>
<p>重新啟動後會自動彈出 Ubuntu 20.04 LTS 的視窗 (若無，則可以透過 Start Menu 手動開啟)，並詢問要使用的帳號密碼，這裡所指的帳號密碼就是 Ubuntu 中的使用者帳號密碼</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Installing, this may take a few minutes...</span><br><span class="line">Please create a default UNIX user account. The username does not need to match your Windows username.</span><br><span class="line">For more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username: wrxue  <span class="comment"># 帳號</span></span><br><span class="line">New password:                   <span class="comment"># 密碼</span></span><br><span class="line">Retype new password:            <span class="comment"># 密碼確認</span></span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>
<h2 id="WSL-搭配-VS-Code"><a href="#WSL-搭配-VS-Code" class="headerlink" title="WSL 搭配 VS Code"></a>WSL 搭配 VS Code</h2><h3 id="安裝-VS-Code-WSL-擴充"><a href="#安裝-VS-Code-WSL-擴充" class="headerlink" title="安裝 VS Code WSL 擴充"></a>安裝 VS Code WSL 擴充</h3><p>幫 VS Code 安裝 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL</a> Extension，讓 VS Code 可以在 WSL2 環境中執行。</p>
<h3 id="WSL2-環境中的-VS-Code"><a href="#WSL2-環境中的-VS-Code" class="headerlink" title="WSL2 環境中的 VS Code"></a>WSL2 環境中的 VS Code</h3><p>開啟 Ubuntu 20.04 LTS 並執行 <code>code .</code>，等待 Ubuntu 下載 VS Code</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wrxue@DESKTOP-PE4H403:~$ code .</span><br><span class="line">Installing VS Code Server <span class="keyword">for</span> x64 (c722ca6c7eed3d7987c0d5c3df5c45f6b15e77d1)</span><br><span class="line">Downloading: 100%</span><br><span class="line">Unpacking: 100%</span><br><span class="line">Unpacked 1619 files and folders to /home/wrxue/.vscode-server/bin/c722ca6c7eed3d7987c0d5c3df5c45f6b15e77d1.</span><br></pre></td></tr></table></figure>
<p>下載完畢後 VS Code 會被開啟，該 VS Code 的工作環境 (WSL: UBUNTU-20.04) 是在 Ubuntu 內部的，所啟用的 Terminal 也是 Ubuntu 的環境，也就是說在該 VS Code 視窗做的任何操作都是針對 Ubuntu 環境的。如此一來，開發環境已經設定完成，接下來便可如同以往的在 VS Code 上進行 Linux 應用的開發。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/WSL-%E9%80%8F%E9%81%8E-WSL2-%E8%88%87-VS-Code-%E5%9C%A8-Windows-%E9%80%B2%E8%A1%8C-Linux-%E6%87%89%E7%94%A8%E9%96%8B%E7%99%BC%2Fwsl_vscode.png?alt=media&amp;token=9909c1c1-9a47-4041-9655-35adb0473f87" alt="WSL2 搭配 VS Code"><span class="image-caption">WSL2 搭配 VS Code</span></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>wsl</tag>
        <tag>wsl2</tag>
        <tag>vscode</tag>
        <tag>vt</tag>
        <tag>bios</tag>
      </tags>
  </entry>
  <entry>
    <title>[Window] Modal 與 non-Modal 視窗運作原理</title>
    <url>/2021/06/15/window_modal_non_modal/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>對於視窗運作有基本了解，才能夠在對的場景用對的對話框來呈現。這篇文章會帶出 Modal (模態) 與 non-Modal (非模態) 視窗的基本運作機制！</p>
<h2 id="Modal-視窗的運作機制"><a href="#Modal-視窗的運作機制" class="headerlink" title="Modal 視窗的運作機制"></a>Modal 視窗的運作機制</h2><p>由 <code>DialogBox</code> 家族 (例如 <code>DialogBox</code>、<code>DialogBoxIndirect</code>、<code>DialogBoxParam</code> 和 <code>DialogBoxIndirectParam</code>) 創建的對話框是 Modal 視窗。</p>
<p>在創建之前，系統將禁用其父視窗，並在這些 API 函數中為其創建一個新的消息循環 (Message loop)，這些函數還需要回調函數 (例如 <code>DialogProc</code>) 來處理消息。換句話說，Modal 對話框視窗具有其自己的消息循環和不同於主線程的視窗過程，在用戶單擊 <code>確定</code>、<code>取消</code> 或 <code>關閉</code> 之類的按鈕之前，它們始終處於 Modal 視窗消息循環中。單擊按鈕後，使用 <code>EndDialog</code> 返回至主線程中的主消息循環，父視窗可以再次響應。</p>
<h2 id="non-Modal-視窗的運作機制"><a href="#non-Modal-視窗的運作機制" class="headerlink" title="non-Modal 視窗的運作機制"></a>non-Modal 視窗的運作機制</h2><p>由 <code>CreateDialog</code> 家族 (例如 <code>CreateDialog</code>、<code>CreateDialogIndirect</code>、<code>CreateDialogParam</code> 和 <code>CreateDialogIndirectParam</code>) 創建的對話框是 non-Modal 視窗。它們將在創建後返回，而不是創建新的消息循環，該對話框使用在主線程中的消息循環。因此，父視窗也可以響應。</p>
<p>參考原始碼：<a href="https://github.com/weirenxue/dialogboxparam-example">DialogBoxParam 使用範例</a></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>window</tag>
        <tag>modal</tag>
        <tag>non modal</tag>
      </tags>
  </entry>
  <entry>
    <title>[Windows] 32 位元應用程式在 64 位元作業系統運作的原理</title>
    <url>/2021/06/11/3264/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>知道因為 64 位元比較寬可以容納 32 位元的數據，所以可以讓 32 位元應用程式在 64 位元作業系統上正常運作，但是不知道實際到底如何運作，所以這篇就來探討一下這裡面運作的觀念。</p>
<h2 id="32-位元與-64-位元的差異"><a href="#32-位元與-64-位元的差異" class="headerlink" title="32 位元與 64 位元的差異"></a>32 位元與 64 位元的差異</h2><p>首先就要先介紹 32 位元與 64 位元的差異，位元數的定義是以 CPU 內的<strong>通用暫存器</strong>有幾個位元來決定的，像是 x86 的 CPU 就是只有 32 位元的暫存器，數據不能超過 32 位元，超過 32 位元就會當作溢位或忽略，所以在 64 位元系統下開發的應用程式若沒有考慮到給 32 位元的系統用的話，在 32 位元的系統下開啟 64 位元的應用程式是無法正常運作的。</p>
<h2 id="SysWOW64-目錄"><a href="#SysWOW64-目錄" class="headerlink" title="SysWOW64 目錄"></a>SysWOW64 目錄</h2><p>原生 32 位元 Windows 系統 (Windows 9x/NT/7/10) 有 system32 目錄，存放了與系統溝通 32 位元的 API 函式庫 (kernel32.dll、user32.dll)，具有用戶接口、鍵盤滑鼠輸入、影印機等的程式幾乎都會調用到這些API。</p>
<p>而在原生 64 位元的 Windows 為了系統兼容 32 位元的應用程式，將 64 位元的 API 函式庫放到 system32，且函數名稱與基本功能沒有改變，只是變成 64 位元代碼實現運作，而把 32 位元的函式庫通通丟到 SysWOW64 (Windows On Windows 64-bit) 這個文件夾下。</p>
<p>SysWOW64 不只是一個文件夾的名字，它是 Windows 64 位元下的一個子系統，專門用來執行 32 位元應用程式。</p>
<p>看到這裡可以發覺在 Windows 64 位元的作業系統上：</p>
<ul>
<li>system32 放的是 64 位元的 API</li>
<li>SysWOW64 放的是 32 位元的 API</li>
</ul>
<h2 id="32-bit-App-on-64-bit-OS-運作原理"><a href="#32-bit-App-on-64-bit-OS-運作原理" class="headerlink" title="32-bit App on 64-bit OS 運作原理"></a>32-bit App on 64-bit OS 運作原理</h2><p>那 32 位元的應用程式如何在 64 位元的作業系統運作的呢？讀者可能知道因為 64 位元比較寬可以容納32位元的數據，所以可以正常運作，但是不知道實際到底如何運作。</p>
<p>它的運作方式如下說明，當 32 位元應用程序開始加載時，WOW64 會依照 32 位元的 ntdll.dll 來建立 32 位元所需要的啟動環境，將 64 位元 CPU 的運作模式切換為 32 位元的模式，開始執行 32 位元的加載器並運行應用程式。</p>
<p>WOW64 並不會直接依 32 位元的 ntdll.dll 去發送指令，反而是重定向至 64 位元的 ntdll.dll，此時 WOW64 會轉換為原生 64 位元的模式進行函數調用與取得回傳值等操作，並會將取得的資料先由 64 位元轉回 32 位元，再將運作模式轉回 32 位元，把資料給 32 位元的應用程式去處理後續動作。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>bit</tag>
        <tag>32</tag>
        <tag>64</tag>
        <tag>application</tag>
        <tag>os</tag>
        <tag>wow64</tag>
      </tags>
  </entry>
  <entry>
    <title>[ZIP] 壓縮檔內中文檔名呈現亂碼的解決方法</title>
    <url>/2021/06/15/zip_chinese_garbled/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想練英文從生活周遭開始是最直接的，安裝英文版版作業系統也不奇怪，但身在中文環境工作與學習，通常經手的會是中文檔名的檔案，當英文版作業系統遇見中文檔名，總是會發生一些惱人的錯誤。這次遇到的問題是，在瀏灠內含中文檔名的 zip 壓縮檔時，中文會呈現出亂碼型態。</p>
<h2 id="狀況描述"><a href="#狀況描述" class="headerlink" title="狀況描述"></a>狀況描述</h2><p>原本目錄為中文(示範用)，壓縮後開啟瀏覽呈現為亂碼</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/ZIP-%E5%A3%93%E7%B8%AE%E6%AA%94%E5%85%A7%E4%B8%AD%E6%96%87%E6%AA%94%E5%90%8D%E5%91%88%E7%8F%BE%E4%BA%82%E7%A2%BC%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fgarbled.png?alt=media&amp;token=2c282188-e3cb-4481-9f3b-24d820ed2d74" alt="亂碼的檔案名稱"><span class="image-caption">亂碼的檔案名稱</span></p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>先開啟控制台 (Control Panel)，按照下圖所示操作，將語言更換為 <code>Chinese (Traditional, Taiwan)</code> 之後，電腦會要求重開機，就重開機吧！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/ZIP-%E5%A3%93%E7%B8%AE%E6%AA%94%E5%85%A7%E4%B8%AD%E6%96%87%E6%AA%94%E5%90%8D%E5%91%88%E7%8F%BE%E4%BA%82%E7%A2%BC%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Foperation.png?alt=media&amp;token=0933c050-25ae-4a77-a8c6-1f42ca9840a0" alt="操作步驟"><span class="image-caption">操作步驟</span></p>
<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>重開機後就能再次開啟該 zip 壓縮檔來查看正常的檔案名稱啦！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/ZIP-%E5%A3%93%E7%B8%AE%E6%AA%94%E5%85%A7%E4%B8%AD%E6%96%87%E6%AA%94%E5%90%8D%E5%91%88%E7%8F%BE%E4%BA%82%E7%A2%BC%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95%2Fno_grabled.png?alt=media&amp;token=174f988f-0f11-46e0-abb7-903c57691af0" alt="沒有亂碼的檔案名稱"><span class="image-caption">沒有亂碼的檔案名稱</span></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>file</tag>
        <tag>name</tag>
        <tag>zip</tag>
        <tag>chinese</tag>
        <tag>garbled</tag>
      </tags>
  </entry>
  <entry>
    <title>[apt] Unable to locate package 問題</title>
    <url>/2021/06/17/apt_unable_to_locate_package/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有時候在使用 <code>apt-get</code> 安裝套件時會遇到錯誤情況，比較多是輸入錯誤，但也有一種情況是雖然輸入正確，卻找不到相關套件可以下載。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>我遇到的情況是這樣子的，要安裝 <code>ntpdate</code> 時卻發現出現錯誤訊息 <code>Unable to locate package ntpdate</code>，意思是說無法找到 <code>ntpdate</code> 套件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install ntpdate</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package ntpdate</span><br></pre></td></tr></table></figure>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>很有可能是因為 <code>apt-get</code> 的安裝清單沒有更新，所以資料庫裡面沒有 <code>ntpdate</code> 的安裝連結，這時只需簡單的更新 <code>apt-get</code>，完成更新後再次嘗試執行安裝指令，即可找到該套件連結並順利進行安裝</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get update</span><br><span class="line">user@pc:~$ sudo apt-get upgrade <span class="comment"># 視情況執行</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>apt-get update</code>：更新 <code>apt-get</code> 安裝清單內對應的連結為最新的連結。若沒有進行清單更新，有些連結所對應到的是舊版本套件，更有可能對應到已失效連結。</li>
<li><code>apt-get upgrade</code>：將所有由 <code>apt-get</code> 指令安裝的套件依據安裝清單更新為最新的版本。若不需要更新現有的套件，則不需要執行此指令。</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>使用 <code>apt-get</code> 安裝之前先執行 <code>apt-get update</code> 是一個好習慣，以確保資料庫為最新，減少一個浪費時間的可能。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
        <tag>install</tag>
        <tag>apt</tag>
        <tag>get</tag>
        <tag>update</tag>
      </tags>
  </entry>
  <entry>
    <title>[link] 缺少 libudev.so.0 的解決方法</title>
    <url>/2021/06/17/link_libdev_so_0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在安裝德州儀器的軟體時出現缺少 <code>libudev.so.0</code> 的字樣，有些解法是直接安裝 <code>libudev0:i386</code> 的套件，不幸的是這在 Ubuntu 14.04 之後的版本就移除了，取而代之的是 <code>libudev1:i386</code>，但軟體安裝就是硬要 <code>libudev.so.0</code> 這個檔案存在。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>解決的方法就是自己創一個連結檔，連結到 <code>libudev.so.1</code>，名為 <code>libudev.so.0</code> (雖然 <code>libudev.so.1</code> 本身也是連結檔 XD)。建立連結檔有兩種方式</p>
<h3 id="使用-cp-指令"><a href="#使用-cp-指令" class="headerlink" title="使用 cp 指令"></a>使用 cp 指令</h3><p>用 <code>cp</code> 指令建立連結檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo <span class="built_in">cp</span> -s /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.1 /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.0</span><br><span class="line">user@pc:~$ <span class="built_in">ls</span> -l /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.*         <span class="comment">#查看是否有建立</span></span><br><span class="line">lrwxrwxrwx 1 root root     34 十二  5 17:23 /lib/x86_64-linux-gnu/libudev.so.0 -&gt; /lib/x86_64-linux-gnu/libudev.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     16 十一 15 23:01 /lib/x86_64-linux-gnu/libudev.so.1 -&gt; libudev.so.1.6.9</span><br><span class="line">-rw-r--r-- 1 root root 121016 十一 15 23:01 /lib/x86_64-linux-gnu/libudev.so.1.6.9</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(arch)</code>：是在指令執行之前，先執行 <code>arch</code> 命令，取得當前電腦的硬體架構 (例如：x86_64) 並填回當前位置。</li>
</ul>
<p>可以看到 <code>libudev.so.1 -&gt; libudev.so.1.6.9</code>，也就是說最終是連結到 <code>libudev.so.1.6.9</code> 實體檔案。</p>
<h3 id="使用-ln-指令"><a href="#使用-ln-指令" class="headerlink" title="使用 ln 指令"></a>使用 ln 指令</h3><p>其實步驟都與上面一樣，只是用不同指令達成。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo <span class="built_in">ln</span> -sf /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.1 /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.0</span><br><span class="line">user@pc:~$ <span class="built_in">ls</span> -l /lib/$(<span class="built_in">arch</span>)-linux-gnu/libudev.so.*         <span class="comment">#查看是否有建立</span></span><br><span class="line">lrwxrwxrwx 1 root root     34 十二  5 17:23 /lib/x86_64-linux-gnu/libudev.so.0 -&gt; /lib/x86_64-linux-gnu/libudev.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     16 十一 15 23:01 /lib/x86_64-linux-gnu/libudev.so.1 -&gt; libudev.so.1.6.9</span><br><span class="line">-rw-r--r-- 1 root root 121016 十一 15 23:01 /lib/x86_64-linux-gnu/libudev.so.1.6.9</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>link</tag>
        <tag>libudev</tag>
        <tag>so</tag>
        <tag>i386</tag>
        <tag>cp</tag>
        <tag>ln</tag>
      </tags>
  </entry>
  <entry>
    <title>優雅的單位轉換公式與推導</title>
    <url>/2022/08/30/unit_convert/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>單位轉換是多數系統中會碰到的課題，單純兩個單位之間的轉換還算容易，而多個單位的轉換就有點困難。以「速度」來說，在 <code>m/s</code>, <code>mph</code> 與 <code>km/h</code> 等數種單位之間互相轉換，排列組合就多達九種以上；而「貨幣」幾乎是每一個國家一種單位，需要在更多單位之間做轉換。如何寫出易於維護可擴展的單位轉換程式碼是非常重要的，這篇文章帶領讀者從數學角度出發，一步步推導出單位轉換公式並將其化為最簡。</p>
<h2 id="直接的做法"><a href="#直接的做法" class="headerlink" title="直接的做法"></a>直接的做法</h2><p>以「速度」為例，<code>m/s</code>, <code>mph</code> 與 <code>km/h</code> 三個單位若需要互相轉換，最直接且暴力的做法是建立一個表記錄下每個單位之間的轉換因子，轉換時只需將原本的值乘以轉換因子 (factor)，即可得到進行單位轉換後的數值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unitFactors = &#123;</span><br><span class="line">    <span class="string">&#x27;m/s&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;m/s&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;mph&#x27;</span>: <span class="number">2.23693629</span>,</span><br><span class="line">        <span class="string">&#x27;km/h&#x27;</span>: <span class="number">3.6</span>,</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&#x27;mph&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;m/s&#x27;</span>: <span class="number">0.44704</span>,</span><br><span class="line">        <span class="string">&#x27;mph&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;km/h&#x27;</span>: <span class="number">1.609344</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;km/h&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;m/s&#x27;</span>: <span class="number">0.277777778</span>,</span><br><span class="line">        <span class="string">&#x27;mph&#x27;</span>: <span class="number">0.621371192</span>,</span><br><span class="line">        <span class="string">&#x27;km/h&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unitConvert</span>(<span class="params">value, <span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value * unitFactors[<span class="keyword">from</span>][to]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unitConvert</span>(<span class="number">1</span>, <span class="string">&#x27;km/h&#x27;</span>, <span class="string">&#x27;mph&#x27;</span>)) <span class="comment">// 0.621371192</span></span><br></pre></td></tr></table></figure>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ol>
<li><p>很多重複的資料：例如 <code>unitFactors[&#39;m/s&#39;][&#39;mph&#39;]</code> 其實就等於 <code>1/unitFactors[&#39;mph&#39;][&#39;m/s&#39;]</code>。</p>
</li>
<li><p>難以擴增：若要增加一個單位例如 <code>ft/s</code>，就要大幅改動轉換因子表如下所示，造成開發者的負擔</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unitFactors = &#123;</span><br><span class="line">    <span class="string">&#x27;m/s&#x27;</span>: &#123;</span><br><span class="line">        ..., <span class="comment">// (ellipsis)</span></span><br><span class="line">        <span class="string">&#x27;ft/s&#x27;</span>: <span class="number">3.28084</span>,</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&#x27;mph&#x27;</span>: &#123;</span><br><span class="line">        ..., <span class="comment">// (ellipsis)</span></span><br><span class="line">        <span class="string">&#x27;ft/s&#x27;</span>: <span class="number">1.466667</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;km/h&#x27;</span>: &#123;</span><br><span class="line">        ..., <span class="comment">// (ellipsis)</span></span><br><span class="line">        <span class="string">&#x27;ft/s&#x27;</span>: <span class="number">0.911344</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;ft/s&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;m/s&#x27;</span>: <span class="number">0.3048</span>,</span><br><span class="line">        <span class="string">&#x27;mph&#x27;</span>: <span class="number">0.681818</span>,</span><br><span class="line">        <span class="string">&#x27;km/h&#x27;</span>: <span class="number">1.09728</span>,</span><br><span class="line">        <span class="string">&#x27;ft/s&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="推導單位轉換公式"><a href="#推導單位轉換公式" class="headerlink" title="推導單位轉換公式"></a>推導單位轉換公式</h2><p>為了避免之後要償還技術債，不如現在就將單位轉換過程進行簡化。簡化的方式有很多種，這裡會透過數學推導來得到好用的單位轉換公式。</p>
<p>參數說明：</p>
<ul>
<li>$v_1$：現在的值。</li>
<li>$u_1$：現在的單位。</li>
<li>$v_2$：單位轉換後的值。</li>
<li>$u_2$：轉換後的單位。</li>
<li>$f_{12}$：單位由 $u_1$ 轉換為 $u_2$ 時，所需乘的轉換因子。</li>
<li>$u_0$：基底單位。</li>
<li>$f_{01}$：單位由 $u_0$ 轉換為 $u_1$ 時，所需乘的轉換因子。</li>
<li>$f_{02}$：單位由 $u_0$ 轉換為 $u_2$ 時，所需乘的轉換因子。</li>
</ul>
<p>可列出方程式</p>
<script type="math/tex; mode=display">v_1 \cdot u_1 = v_2 \cdot u_2</script><p>我們的<strong>目標</strong>就是算出 $v_2$</p>
<script type="math/tex; mode=display">v_2 = v_1 \cdot \frac{u_1}{u_2} = v_1 \cdot f_{12}</script><p>這時我們知道單位轉換的公式為 $v_1$ 乘以 $u_1/u_2$，將分數部分上下同除一個基底單位 $u_0$</p>
<script type="math/tex; mode=display">f_{12} = \frac{u_1}{u_2} = \frac{u_1/u_0}{u_2/u_0}=\frac{u_0/u_2}{u_0/u_1} = \frac{f_{02}}{f_{01}}</script><p>$u_0$ 用來作為轉換的一個中間單位，它可以是任何單位如 <code>m/s</code>, <code>mph</code> 或 <code>km/h</code>，接下來將會演示如何使用此公式</p>
<script type="math/tex; mode=display">v_2 = v_1 \cdot \frac{f_{02}}{f_{01}}</script><h2 id="使用公式實作單位轉換"><a href="#使用公式實作單位轉換" class="headerlink" title="使用公式實作單位轉換"></a>使用公式實作單位轉換</h2><p>這裡選定 <code>m/s</code> 基底單位 $u_0$，先建立以 <code>m/s</code> 為基底單位的轉換因子表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unitFactors = &#123;</span><br><span class="line">    <span class="string">&#x27;m/s&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;mph&#x27;</span>: <span class="number">2.23693629</span>,</span><br><span class="line">    <span class="string">&#x27;km/h&#x27;</span>: <span class="number">3.6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後實作單位轉換函數 <script type="math/tex">v_2 = v_1 \cdot f_{02}/f_{01}</script></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unitConvert</span>(<span class="params">value, <span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="comment">// v1 * (f02 / f01)</span></span><br><span class="line">    <span class="keyword">return</span> value * (unitFactors[to]/unitFactors[<span class="keyword">from</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unitConvert</span>(<span class="number">1</span>, <span class="string">&#x27;km/h&#x27;</span>, <span class="string">&#x27;mph&#x27;</span>)) <span class="comment">// 0.6213711916666667</span></span><br></pre></td></tr></table></figure>
<h3 id="問題的改善"><a href="#問題的改善" class="headerlink" title="問題的改善"></a>問題的改善</h3><ol>
<li><p>沒有重複的資料：重複的資料已經隱含在 $1/f_{01}$ 之中，因此不需要再多記倒數後的結果。</p>
</li>
<li><p>容易擴充的轉換因子表：若要多加一個單位例如 <code>ft/s</code>，只需增加一行</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unitFactors = &#123;</span><br><span class="line">    ..., <span class="comment">// (ellipsis)</span></span><br><span class="line">    <span class="string">&#x27;ft/s&#x27;</span>: <span class="number">3.28084</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>unit</tag>
        <tag>convert</tag>
        <tag>fomula</tag>
        <tag>speed</tag>
        <tag>factor</tag>
      </tags>
  </entry>
  <entry>
    <title>[asm] NEG 的運作與應用</title>
    <url>/2021/06/11/asmneg/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>NEG</code> 在程式中不常用到，不過當在高階語言寫完，使用 Debug 介面的時候有機會看到它在組合語言中出現。</p>
<p>它的運作影響了旗標，進而用來當作實現 <code>BOOL function</code> 回傳的一個選項。就一起來看看 <code>NEG</code> 是如何運作以及對應到的高階語言是如何呈現的。</p>
<h2 id="運作原理"><a href="#運作原理" class="headerlink" title="運作原理"></a>運作原理</h2><p>想知道一個程式碼如何運作，不外乎就是兩種方法：</p>
<ol>
<li>直接編譯/組譯然後執行，觀察結果(暫存器輸出、旗標設置等等)，此方式在本篇文章不強調。</li>
<li>最基本的就是看技術文件，若參數很多或者回傳複雜無法直接觀察結果推斷的時候，相關文件最有用了。例如 Windows 的 API 可以去 MSDN 上找函數介紹，而組合語言的語法能夠找所使用 CPU 的廠商要文檔，AMD 與 Intel 的組合語言可能有差異，所以若是使用 Intel 的就請找 Intel 的指令手冊來參考。</li>
</ol>
<p>我的電腦為 Intel CPU，上網找到對應的指令手冊(<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">Intel® 64 and IA-32 Architectures Software Developer&#39;s Manual</a>)，內文對 <code>NEG</code> 指令的描述摘要如下</p>
<blockquote>
<p>NEG—Two&#39;s Complement Negation<br>Description<br>Replaces the value of operand (the destination operand) with its two&#39;s complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.</p>
</blockquote>
<p>簡單說明一下，<code>NEG</code> 是一個 2 補數的運算，將一個數取 2 補數之後放回原本的目的地，等同於一個數被 0 減掉再放回暫存器(即 <code>eax = 0 - eax</code>)，目的地可以是暫存器也可以是記憶體位址。它原文下面還有說明，但到這就能夠來說明想要表達的程式碼了。再來看看它的流程 Pseudo code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Operation</span><br><span class="line">IF DEST = <span class="number">0</span></span><br><span class="line">　THEN CF ← <span class="number">0</span>;</span><br><span class="line">　ELSE CF ← <span class="number">1</span>;</span><br><span class="line">FI;</span><br><span class="line">DEST ← [– (DEST)]</span><br></pre></td></tr></table></figure>
<p>短短幾行 Pseudo code，代表了無數的文字，相信一看就懂它想說甚麼。在簡短的 <code>NEG</code> 描述與操作流程可以知道若 <code>DEST</code> 不為 0，進位旗標 (<code>CF</code>) 會被設置為 1，這是因為 0 減非 0 的數需要補位。</p>
<h2 id="應用方式"><a href="#應用方式" class="headerlink" title="應用方式"></a>應用方式</h2><p>這時候假設你的程式中有個副程式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">NEGtest</span><span class="params">(TCHAR *str1, TCHAR *str2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">lstrcmp</span>(str1, str2) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不論是組合語言或高階語言，有很多不同編寫方式來完成相同的事情，然而這個函數內的 <code>if else</code> 所對應到的組合語言可能為</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">push ebp        <span class="comment">//str2 的位址</span></span><br><span class="line">push eax        <span class="comment">//str1 的位址</span></span><br><span class="line">call [<span class="number">00404004</span>] <span class="comment">//呼叫 lstrcmp 函數</span></span><br><span class="line">neg eax         <span class="comment">//API 函數回傳值都放在 eax 暫存器裡，因此對比較後的結果作 NEG 運算</span></span><br><span class="line">sbb eax, eax    <span class="comment">//eax = eax - eax - CY</span></span><br><span class="line">inc eax         <span class="comment">//eax = eax + 1</span></span><br></pre></td></tr></table></figure>
<p><code>lstrcmp</code> 需要兩個參數，因此先壓參數入堆疊再調用 (call) 其函數，而它的回傳值放在 <code>eax</code> 裡面，若兩個字串相同，則 <code>eax == 0</code>；反之 <code>eax != 0</code>。此時分為兩個情況來討論：</p>
<ol>
<li><code>str1 == str2</code><br> 在第三行指令執行完時 <code>eax</code> 值為 0，<code>neg eax</code> 之後 <code>eax</code> 還是 0 且 <code>CY</code> 為 0，因此到程式結束時 <code>eax</code> 為 1，即 <code>return true</code></li>
<li><code>str1 !=  str2</code><br> 在第三行指令執行完時 <code>eax</code> 值為非 0，<code>neg eax</code> 之後 <code>eax</code> 還是非 0 且 <code>CY</code> 為1，因此第五行的執行結果為 <code>eax = eax - eax - CY = 0xFFFFFFFF</code> (32位元的話)，最後 <code>eax = eax + 1 = 0</code> 即 <code>return false</code></li>
</ol>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>這個執行結果，與高階語言的效果是一樣的。當然，也可以用 <code>cmp</code>、<code>jmp</code>等指令來完成同一件事，但不覺得程式拐個彎寫得簡單優雅，會有更有成就感嗎？呵呵！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>neg</tag>
        <tag>sbb</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>[轉檔] Keynote 轉 PowerPoint (pptx 而不是 ppsx)</title>
    <url>/2021/06/27/mac_keynote_powerpoint_pptx/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Mac 上使用 Keynote 來做投影片非常方便，但在有些場合必須提供 pptx 檔案，這時必定需要使用到轉檔功能了。然而在新版的 Keynote 選擇 PowerPoint 格式輸出時，竟然輸出為奇怪的格式 ppsx，找了許久才找到解決方法，正常轉為 pptx 檔案，因此在此紀錄下來。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>macOS Big Sur 11.4</li>
<li>Keynote 11.1</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>要轉檔為 <code>pptx</code> 的方法很繞圈子，必須先將 Keynote 轉為 <code>Keynote &#39;09</code>，再開啟 <code>Keynote &#39;09</code> 檔轉為 <code>pptx</code>，若用最原始的 Keynote 檔案來轉檔只會得到 <code>ppsx</code>。</p>
<h3 id="Keynote-39-09"><a href="#Keynote-39-09" class="headerlink" title="Keynote &#39;09"></a>Keynote &#39;09</h3><p>開啟想要轉的 Keynote，依照指示 <code>File -&gt; Export To -&gt; Keynote &#39;09... -&gt; Next</code> 轉為 Keynote &#39;09 類型檔案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Mac-Keynote-%E8%BD%89-PowerPoint-pptx%2Fexport_keynote09.png?alt=media&amp;token=74d16eb4-25c9-40f4-a4d4-02af3b840eb4" alt="轉檔為 Keynote &#39;09"><span class="image-caption">轉檔為 Keynote &#39;09</span></p>
<p>可以觀察一下有沒有 &#39;09 到底差在哪裡，我自己除了檔案大小外，看不出差異，所以要我判斷出某個檔案是 Keynote 還是 Keynote &#39;09 是不太可能的！若有知道如何分辨的朋友們，歡迎在底下討論區留言！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Mac-Keynote-%E8%BD%89-PowerPoint-pptx%2FkeynoteVSkeynote09.png?alt=media&amp;token=80e7fc49-1ee5-4c7b-b07f-c2d71fdf3ad1" alt="Keynote 檔 (左) 與 Keynote &#39;09 檔 (右) 比較"><span class="image-caption">Keynote 檔 (左) 與 Keynote &#39;09 檔 (右) 比較</span></p>
<h3 id="pptx"><a href="#pptx" class="headerlink" title="pptx"></a>pptx</h3><p>最後就是重頭戲了，開啟剛剛轉好的 Keynote &#39;09&#39; 檔案，依照指示 <code>File -&gt; Export To -&gt; PowerPoint... -&gt; Advanced Options -&gt; .pptx -&gt; Next</code>，最後得到 pptx 檔案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Mac-Keynote-%E8%BD%89-PowerPoint-pptx%2Fkey09topptx.png?alt=media&amp;token=14b8ee4b-5c46-46a6-a38b-5c4847c39bb4" alt="Keynote &#39;09 轉 pptx"><span class="image-caption">Keynote &#39;09 轉 pptx</span></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不知道為什麼 Apple 要繞成這樣，需要先轉為 Keynote &#39;09 才能轉為 pptx，還不說明白讓人困擾。另外個人覺得根本不應該將 Keynote 轉為 pptx，有非常多格式會因此跑掉，因此強烈建議是直接將 Keynote 轉為 pdf 即可，但最終要轉檔成甚麼還是需要看應用場景。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>1 <a href="https://discussions.apple.com/thread/8524312">Keynote exports to PPSX instead of PPTX</a></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>keynote</tag>
        <tag>powerpoint</tag>
        <tag>pptx</tag>
        <tag>ppsx</tag>
      </tags>
  </entry>
  <entry>
    <title>[轉檔] 將 rpm 檔轉為 deb 檔</title>
    <url>/2021/06/17/rpm_deb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些軟體只提供 rpm 檔，但在 Ubuntu 的系統只能安裝 deb 檔，這時候就需要將 rpm 轉為 deb。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="轉檔並安裝"><a href="#轉檔並安裝" class="headerlink" title="轉檔並安裝"></a>轉檔並安裝</h2><p><a href="https://wiki.ubuntu-tw.org/index.php?title=HowtoInstallRPM">alien</a> 套件可以幫忙把 rpm 等其他安裝檔轉成 deb 安裝檔，在 Ubuntu 中預設是沒有安裝 <code>alien</code> 套件的，因此要先安裝</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get update</span><br><span class="line">user@pc:~$ sudo apt-get install alien</span><br></pre></td></tr></table></figure>
<p>將 <code>name.rpm</code> 轉為 <code>name.deb</code> 檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo ~/somedir/name.rpm  <span class="comment"># 會轉為同檔名的 deb 檔案，但都改為小寫</span></span><br><span class="line">                                    <span class="comment"># ~/somedir 是 rpm 的檔案路徑，依情況改寫</span></span><br></pre></td></tr></table></figure>
<p>用 dpkg 套件執行 deb 安裝檔安裝應用程式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo dpkg -i ~/somedir/name.deb  <span class="comment">#開始安裝</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>file</tag>
        <tag>18.04</tag>
        <tag>convert</tag>
        <tag>rpm</tag>
        <tag>deb</tag>
        <tag>alien</tag>
        <tag>dpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>[雙系統] Win10 + Ubuntu 開機選單，讓使用者開機可以選擇系統</title>
    <url>/2021/06/16/win_10_ubuntu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 是一個非常輕便且好用的作業系統，在 Windows 下使用 Linux 大多是透過虛擬機器 (VM, Virtual Machine)，但對一個想要深入研究 Linux 的同好來說，灌雙系統是一個不錯的選擇。灌完雙系統之後，有機率會遇到一種情況「電腦會直接進Windows，不會出現選擇作業系統的畫面」。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
<li>Windows 10</li>
</ul>
<h2 id="環境確認"><a href="#環境確認" class="headerlink" title="環境確認"></a>環境確認</h2><p>灌好 Ubuntu 後重新開機，若沒有出現系統選單，而直接進入 Windows 系統的話，那就要先確定一些設定：</p>
<ol>
<li><p>控制台 -&gt; 電源選項 -&gt; 選擇蓋上螢幕時的行為(左方) -&gt; 「取消勾選」開啟快速啟動</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E9%9B%99%E7%B3%BB%E7%B5%B1-Win10-Ubuntu-%E9%96%8B%E6%A9%9F%E9%81%B8%E5%96%AE%EF%BC%8C%E8%AE%93%E4%BD%BF%E7%94%A8%E8%80%85%E9%96%8B%E6%A9%9F%E5%8F%AF%E4%BB%A5%E9%81%B8%E6%93%87%E7%B3%BB%E7%B5%B1%2Fcancel_quick_boot.png?alt=media&amp;token=0b90e051-8718-46fd-9888-2ba9c1af1fd6" alt="不要勾選開啟快速啟動"><span class="image-caption">不要勾選開啟快速啟動</span></p>
</li>
<li><p>重新開機進入 BIOS -&gt; Fast Boot -&gt; Disabled</p>
</li>
<li><p>同樣在 BIOS -&gt; Secure Boot Contorl -&gt; Disabled</p>
</li>
</ol>
<p>以上三點都確認完，重開機後還是沒有出現選單的話，再接著去做下面的事情</p>
<h2 id="grubx64-efi-確認"><a href="#grubx64-efi-確認" class="headerlink" title="grubx64.efi 確認"></a>grubx64.efi 確認</h2><p>進 EFI 系統分割磁碟區(參考：<a href="/2021/06/16/efi_windows_efi/">[EFI] 顯示 Windows 的 EFI 系統分割磁碟</a>)下的 ubuntu 目錄，看是否有關鍵檔案 <code>grubx64.efi</code>，這是 Linux 的引導開機檔案，若沒有看到的話請 <a href="https://mega.nz/#!iIonWA4a!unTw_2I5r6pXLZaXUe-gU5D_lOqCHQJVwgcDeQyl0FU">點此下載 grubx64.efi</a> 並將其移到這個目錄下，再繼續下一步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">P:\EFI\ubuntu&gt;<span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"> P:\EFI\ubuntu 的目錄</span><br><span class="line">2019/09/27  下午 06:16    &lt;DIR&gt;          .</span><br><span class="line">2019/09/27  下午 06:16    &lt;DIR&gt;          ..</span><br><span class="line">2019/09/27  下午 06:16    &lt;DIR&gt;          fw</span><br><span class="line">2019/09/27  下午 06:16            75,992 fwupx64.efi</span><br><span class="line">2019/09/27  下午 06:20               121 grub.cfg</span><br><span class="line">2019/09/27  下午 06:20         1,334,816 shimx64.efi</span><br><span class="line">2019/09/27  下午 06:20         1,269,496 mmx64.efi</span><br><span class="line">2019/09/27  下午 06:20               108 BOOTX64.CSV</span><br><span class="line">2019/09/28  下午 01:01           956,792 grubx64.efi</span><br><span class="line">               6 個檔案       3,637,325 位元組</span><br><span class="line">               3 個目錄     236,093,440 位元組可用</span><br></pre></td></tr></table></figure>
<p>以系統管理員身分開啟 cmd (打開命令提示字元)，並在命令提示字元視窗內輸入下方指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;bcdedit /set &#123;bootmgr&#125; path \EFI\ubuntu\grubx64.efi</span><br><span class="line"></span><br><span class="line">操作順利完成。</span><br></pre></td></tr></table></figure>
<p>重新開機之後就可以看到選單啦！不過它等 10 秒沒操作的話就會自動進入預設的系統哦，所以要開機時需要注意，否則錯過進錯系統也只能再重開機。若想修改預設選項，可以參考 <a href="/2021/06/16/dual_system_change_default/">[雙系統] 更改開機系統選單的預設值</a>。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>18.04</tag>
        <tag>menu</tag>
        <tag>10</tag>
        <tag>dual</tag>
        <tag>system</tag>
        <tag>option</tag>
        <tag>boot</tag>
        <tag>grub</tag>
        <tag>grubx64.efi</tag>
      </tags>
  </entry>
  <entry>
    <title>[雙系統] 同步 Ubuntu 與 Windows 的系統時間</title>
    <url>/2021/06/17/ubuntu_windows_time/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 Ubuntu + Windows 雙系統的用戶，應該會發現 Ubuntu 的時間總是與 Windows 的不一樣，在 UTC+8 的地方，Ubuntu 比 Windows 快 8 小時，切換系統後總是要手動調整時間，造成一定的困擾。最佳解決之道應為將雙系統時間設為同步，因此這裡紀錄了如何將雙系統的時間設為一致。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
<li>Windows 10</li>
</ul>
<h2 id="原因說明"><a href="#原因說明" class="headerlink" title="原因說明"></a>原因說明</h2><p>此問題是由於 Ubuntu 和 Windows 的時間設定方式不同所導致，以當地時間 UTC+8 為例</p>
<ul>
<li>Windows：取得硬體時間 (BIOS 的時間) 直接為當地時間 (Local Time)。</li>
<li>Ubuntu：取得硬體時間 (BIOS 的時間) 並視之為 UTC+0，所以顯示出來的時間是硬體時間 +8 後的結果，也就是 Windows 的時間 +8。</li>
</ul>
<p>簡而言之，正是因為 Ubuntu 會把硬體時間視為 UTC+0，切到 Windows 顯示出來的時間才會比 Ubuntu 慢上 8 個小時！</p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>以下皆是在 Ubuntu 操作，先取得正確時間，若發現找不到 <code>ntpdate</code> 套件，可以參考：<a href="/2021/06/17/apt_unable_to_locate_package/">[apt] Unable to locate package 問題</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install ntpdate            <span class="comment"># network time protocol date </span></span><br><span class="line">user@pc:~$ sudo ntpdate time.windows.com           <span class="comment"># 從微軟公司的時間伺服器取得時間</span></span><br></pre></td></tr></table></figure>
<p>將系統中的時間更新到硬體上，並請 Ubuntu 將硬體時間視為當地時間，如此一來 Ubuntu 與 Windows 顯示時間的運作方式就會一樣</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo hwclock --systohc --localtime    <span class="comment"># hardware clock</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>--systohc</code>：將系統時間同步到硬體內</li>
<li><code>--localtime</code>：將硬體時間當作當地時間</li>
</ul>
<p>最後，只需要重開機進入 Windows 確認時間是否正常顯示。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>18.04</tag>
        <tag>10</tag>
        <tag>dual</tag>
        <tag>system</tag>
        <tag>synchronize</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>[雙系統] 更改開機系統選單的預設值</title>
    <url>/2021/06/16/dual_system_change_default/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要切換雙系統的方法主要有兩種，一是修改 BIOS 的 Boot Option，另一個是使用 grub (參考：<a href="/2021/06/16/win_10_ubuntu/">[雙系統] Win10 + Ubuntu 開機選單，讓使用者開機可以選擇系統</a>])。grub 預設是以 Ubuntu 開機，若在選單畫面超過 10 秒沒有動作，預設直接進入 Ubuntu。對於主要是用 Windows 的人來說稍嫌不便，因為每次開機都要等選單出現，以免不小心進其他系統，這篇主要紀錄如何將預設系統改為 Windows。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
<li>Windows 10</li>
</ul>
<h2 id="修改-grub"><a href="#修改-grub" class="headerlink" title="修改 grub"></a>修改 grub</h2><p>以下動作皆在 Ubuntu 中執行，先知道 Windows 啟動檔的位置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ <span class="built_in">cat</span> /boot/grub/grub.cfg | grep windows</span><br><span class="line">menuentry <span class="string">&#x27;Windows Boot Manager (於 /dev/sdb2)&#x27;</span> --class windows --class os <span class="variable">$menuentry_id_option</span> <span class="string">&#x27;osprober-efi-264C-BB58&#x27;</span> &#123;</span><br></pre></td></tr></table></figure>
<p>記住檔案位置 <code>&#39;Windows Boot Manager (於 /dev/sdb2)&#39;</code> 後，再開啟 <code>/ect/default/grub</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>修改 <code>GRUB_DEFAULT=0</code> 為 <code>GRUB_DEFAULT=&#39;Windows Boot Manager (於 /dev/sdb2)&#39;</code> 並儲存，注意不要少了單引號</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E9%9B%99%E7%B3%BB%E7%B5%B1-%E6%9B%B4%E6%94%B9%E9%96%8B%E6%A9%9F%E7%B3%BB%E7%B5%B1%E9%81%B8%E5%96%AE%E7%9A%84%E9%A0%90%E8%A8%AD%E5%80%BC%2Fchange_setting.png?alt=media&amp;token=55bafa2f-b2ff-4fb6-94a1-7a81fc3e9107" alt="修改 GRUB_DEFAULT"><span class="image-caption">修改 GRUB_DEFAULT</span></p>
<p>更新 grub 後重新開機，就可以發現預設選項落在 Windows 上囉！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo update-grub</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>18.04</tag>
        <tag>menu</tag>
        <tag>10</tag>
        <tag>dual</tag>
        <tag>system</tag>
        <tag>option</tag>
        <tag>boot</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象是什麼？聽起來好抽象</title>
    <url>/2022/09/19/abstraction/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我在學 Design Pattern 時，請教前輩：「抽象是什麼？」對方熱心的一陣瘋狂輸出解釋並舉些範例，我的心中最後冒出一個想法：「聽起來好抽象。」同時依然無法體會抽象的含義，這便是我的親身經歷。就是這麼奇怪，我知道什麼場景可以用這個詞，但背後含意卻不清楚。為了徹底弄懂「抽象」的含義，特別寫成文章強迫自己將認為的「抽象」解釋出來。</p>
<h2 id="辭典解釋"><a href="#辭典解釋" class="headerlink" title="辭典解釋"></a>辭典解釋</h2><p>根據<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=122548&amp;la=0&amp;powerMode=0">教育部國語辭典</a>，「抽象」有兩個解釋：</p>
<ol>
<li>哲學上指從個別的、偶然的不同事物中，分析出其共同點的思想活動。相對於具體而言。</li>
<li>泛指籠統概括。亦相對於具體而言。</li>
</ol>
<p>這才明白，原來日常生活中所說的「抽象」，指的是第二個解釋「泛指籠統概括」。當所說的話語過於籠統不夠具體，導致聽者不懂時，聽者通常會說「聽起來好抽象」，如同我的親身經歷。</p>
<p>接下來讓我們回到正題，<strong>抽象是什麼？</strong></p>
<h2 id="抽象是什麼？"><a href="#抽象是什麼？" class="headerlink" title="抽象是什麼？"></a>抽象是什麼？</h2><!-- markdownlint-disable MD033 -->
<p>國語辭典的第一個解釋則與程式設計中的「抽象」沾到邊了！「抽象」指的是<font style="color:red;"><strong>一種思想活動，從個別的、偶然的不同事物中分析出其共同點的思考過程</strong></font>。但為什麼我說只是沾到邊呢？因為還少了一個重點，就是抽象還<font style="color:red;"><strong>隱藏了不相關的細節</strong></font>。<br><!-- markdownlint-enable MD033 --></p>
<p>我在 <a href="https://www.udemy.com/course/solid-principles-object-oriented-design-architecture/">Abstractions in Digital World</a> 發現一個對於抽象 (Abstraction) 一詞不錯的解釋</p>
<blockquote>
<p>Abstraction:<br>Alternative representation of a concept that hides irrelevant details and exposes only the properties that we’re interested in.</p>
<p>翻譯蒟蒻：抽象為一個概念的替代性表述，隱藏不相關的細節，只暴露我們感興趣的屬性。</p>
</blockquote>
<p>簡單來說抽象主要做了兩件事</p>
<ol>
<li>分析不同東西之間的共同點</li>
<li>隱藏不相關的細節，只暴露感興趣的屬性</li>
</ol>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>學習一個觀念要能夠舉出例子，才算真的明白它的道理，這裡舉出兩個常見但沒有仔細思考過的範例：</p>
<ol>
<li><p>奇數：若看到一串數字 <code>1, 3, 5, 7, 9, ...</code>，會覺得這串數字背後所想表達的含義是什麼？也許會說「這些數字都是奇數 (正奇數、正整數或整數 ... 等等)」，不論如何，這些都是我們針對不同的數字進行分析，發現它們共通點所產生的結論。</p>
<ul>
<li><p>可以說奇數是使用來替代性的表示這些數字的一個概念 (抽象)，我們感興趣的並非數字本身 (細節)，而是它們整體的特質，例如皆不能被 2 整除 (感興趣的屬性)。</p>
</li>
<li><p>將其抽象為奇數後，我們便能捨棄原本的數字，直接對奇數進行更高層次的討論。</p>
</li>
</ul>
</li>
<li><p>通訊設備：手機可以透過 4G LTE 通話、電腦可以透過乙太網路通話、平板可以透過 Wi-Fi 通話，它們的共通點都是可以通話，差別只在於實現通話的方式不同。</p>
<ul>
<li>我們可以使用通訊設備這個概念 (抽象) 來替代性的表示手機、電腦與平板，不去理會通話的原理 (細節)，就能夠用它來撥通號碼 (感興趣的屬性)。</li>
</ul>
</li>
</ol>
<h2 id="在-OOP-應用抽象的範例"><a href="#在-OOP-應用抽象的範例" class="headerlink" title="在 OOP 應用抽象的範例"></a>在 OOP 應用抽象的範例</h2><p>情境：寶可夢中的小智 (Ash Ketchum) 想要計算背包中的寶貝球數量。</p>
<p>(為說明方便，只取兩種寶貝球來說明：超級球 (Great Ball)、大師球 (Master Ball))</p>
<p>為了讓小智可以取得不同的寶貝球，定義了兩個函式分別為 <code>StoreGreatBall</code> 與 <code>StoreMasterBall</code>，並使用兩個陣列各自存放不同的寶貝球，最後將各個陣列拿來算出長度再加起來，計算出總共有多少寶貝球。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GreatBall <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b GreatBall)</span></span> CatchPokemon() &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;great ball catching...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MasterBall <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b MasterBall)</span></span> CatchPokemon() &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;master ball catching...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AshKetchum <span class="keyword">struct</span> &#123;</span><br><span class="line">    GreatBalls  []GreatBall</span><br><span class="line">    MasterBalls []MasterBall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AshKetchum)</span></span> StoreGreatBall(b GreatBall) &#123;</span><br><span class="line">    a.GreatBalls = <span class="built_in">append</span>(a.GreatBalls, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AshKetchum)</span></span> StoreMasterBall(b MasterBall) &#123;</span><br><span class="line">    a.MasterBalls = <span class="built_in">append</span>(a.MasterBalls, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AshKetchum)</span></span> BallCount() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(a.GreatBalls) + <span class="built_in">len</span>(a.MasterBalls)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ash := AshKetchum&#123;&#125;</span><br><span class="line">    ash.StoreGreatBall(GreatBall&#123;&#125;)</span><br><span class="line">    ash.StoreGreatBall(GreatBall&#123;&#125;)</span><br><span class="line">    ash.StoreMasterBall(MasterBall&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Ash Ketchum has %d poké balls\n&quot;</span>, ash.BallCount())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- markdownlint-disable MD033 -->
<p>僅僅是兩種寶貝球而已，就讓我們感覺到很多重複的程式碼出現，若再加 10 種寶貝球怎麼辦？還好，我們學過抽象，仔細觀察可以發現 <code>GreatBall</code> 與 <code>MasterBall</code> 其實有一個共通點，就是他們都可以抓寶可夢 (擁有 <code>CatchPokemon</code> 函式)。<font style="color:red;"><strong>事實上，我們淺意識中就是將是否可以抓寶可夢的球定義為寶貝球，只是沒有特別強調過，為了實作而歸納出這個結論是非常合理的。</strong></font><br><!-- markdownlint-enable MD033 --></p>
<p>接下來可以利用抽象出來「寶貝球」的這個概念，讓我們的程式更簡化，先定義出寶貝球的概念 (對應於 <code>interface</code>)，其說明了只要包含 <code>CatchPokemon</code> 這個方法的球都是寶貝球。這樣做可以讓小智不需要為了一種球就定義一個函式、陣列，計算總數也只需要針對儲存所有寶貝球的那個陣列做運算即可！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PokeBall <span class="keyword">interface</span> &#123;</span><br><span class="line">    CatchPokemon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GreatBall <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b GreatBall)</span></span> CatchPokemon() &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;great ball catching...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MasterBall <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b MasterBall)</span></span> CatchPokemon() &#123;</span><br><span class="line">    fmt.Print(<span class="string">&quot;master ball catching...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AshKetchum <span class="keyword">struct</span> &#123;</span><br><span class="line">    PokeBalls []PokeBall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AshKetchum)</span></span> StorePokeBall(b PokeBall) &#123;</span><br><span class="line">    a.PokeBalls = <span class="built_in">append</span>(a.PokeBalls, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AshKetchum)</span></span> BallCount() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(a.PokeBalls)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ash := AshKetchum&#123;&#125;</span><br><span class="line">    ash.StorePokeBall(GreatBall&#123;&#125;)</span><br><span class="line">    ash.StorePokeBall(GreatBall&#123;&#125;)</span><br><span class="line">    ash.StorePokeBall(MasterBall&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Ash Ketchum has %d poké balls\n&quot;</span>, ash.BallCount())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>哪一種寶貝球並不重要 (細節)，我們只關心它是不是能抓寶可夢的球 (感興趣的屬性，也是共通點)，這就是抽象的結果。</p>
          </div>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>其實要理解抽象並不難，會覺得難的是因為我們平常把「抽象」理解為「籠統概括、艱澀難懂」，而不知道他還有另一個含義「尋找共通點、隱藏細節」，所以抽象真的抽象嗎？好像又沒這麼抽象了！</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=122548&amp;la=0&amp;powerMode=0">教育部國語辭典</a></p>
</li>
<li><p><a href="https://www.udemy.com/course/solid-principles-object-oriented-design-architecture/">SOLID Principles of Object-Oriented Design and Architecture - Abstractions in Digital World</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>program</tag>
        <tag>design</tag>
        <tag>pattern</tag>
        <tag>abstract</tag>
        <tag>abstraction</tag>
        <tag>oop</tag>
        <tag>object</tag>
        <tag>oriented</tag>
        <tag>pokemon</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo × NexT × Firestore 顯示瀏覽人次</title>
    <url>/2021/06/11/hexo_next_firestore_visitors/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>擴充性高的部落格框架有許多功能或是套件需要自己手動加入，因此在研究如何顯示瀏覽人次的同時記錄整個過程。</p>
<h2 id="使用-Firebase"><a href="#使用-Firebase" class="headerlink" title="使用 Firebase"></a>使用 Firebase</h2><h3 id="建立-Firebase-專案"><a href="#建立-Firebase-專案" class="headerlink" title="建立 Firebase 專案"></a>建立 Firebase 專案</h3><p>到 <a href="https://console.firebase.google.com/u/0/">Firebase</a> 官方網站登入後，再建立專案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hexo-x-Next-x-Firestore-%E9%A1%AF%E7%A4%BA%E7%80%8F%E8%A6%BD%E4%BA%BA%E6%AC%A1%2Fcreate_firebase_project.png?alt=media&amp;token=d872c7b7-704e-4912-8fbb-47b5b64ed16b" alt="建立 Firebase 專案"><span class="image-caption">建立 Firebase 專案</span></p>
<h3 id="啟用-Authentication-功能"><a href="#啟用-Authentication-功能" class="headerlink" title="啟用 Authentication 功能"></a>啟用 Authentication 功能</h3><p>必須要啟用此功能才會有 apiKey！再記住 <strong>專案 ID</strong>(<code>projectId</code>) 與 <strong>網路 API 金鑰</strong>(<code>apiKey</code>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hexo-x-Next-x-Firestore-%E9%A1%AF%E7%A4%BA%E7%80%8F%E8%A6%BD%E4%BA%BA%E6%AC%A1%2Fuse_firebase_authentication.png?alt=media&amp;token=08472c0a-f7b0-43cf-bfd9-215d1c88ca65" alt="啟用 Authentication"><span class="image-caption">啟用 Authentication</span></p>
<h3 id="建立-Firestore-Database"><a href="#建立-Firestore-Database" class="headerlink" title="建立 Firestore Database"></a>建立 Firestore Database</h3><p>建立的過程中選項先選擇 <strong>以測試模式啟動</strong>，之後測試若沒有問題會再改為較安全的安全性設定。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hexo-x-Next-x-Firestore-%E9%A1%AF%E7%A4%BA%E7%80%8F%E8%A6%BD%E4%BA%BA%E6%AC%A1%2Fcreate_firestore_database.png?alt=media&amp;token=81bde63a-be37-4451-960a-ae4b89d92f63" alt="建立 Firestore Database"><span class="image-caption">建立 Firestore Database</span></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改 _config.yml"></a>修改 <code>_config.yml</code></h2><p>Hexo 本身設定檔 <code>_config.yml</code> 內 <code>url</code> 的值必須與正式的 Domain 相符，這個值表示此部落格預計對外服務的 Domain。這是因為 Next 主題會先判斷使用者閱讀的網頁該 Domain 是否與 <code>url</code> 欄位的 Domain 相同，若相同則表示該流量來自對外公開的站點，是真的使用者帶來的瀏覽流量，盡可能的避免我們在 localhost 測試時影響到真實的瀏覽數！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://weirenxue.github.io</span> <span class="comment"># Modify this to meet your situation</span></span><br></pre></td></tr></table></figure>
<p><code>themes/next/_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firestore:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">collection:</span> <span class="string">articles</span> <span class="comment"># Required, a string collection name to access firestore database</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">AIzaSyDPv4yBy3wupULx0wmE8-SXg4fxjgnrE9w</span> <span class="comment"># Required</span></span><br><span class="line">  <span class="attr">projectId:</span> <span class="string">gh-pages-d3782</span> <span class="comment"># Required</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>enable</code>：改為 true</li>
<li><code>collection</code>：不用更改，預設為 articles</li>
<li><code>apiKey</code>：網路 API 金鑰</li>
<li><code>projectId</code>：專案 ID</li>
</ul>
<p>修改好之後就可以發布囉，計數在發布後才有效，本地測試是沒有用的哦！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<h3 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h3><p>可以試著點擊文章，看是否真的有計數，並且可以看到 <strong>Firestore</strong> 有一個叫做 <code>articles</code> 的 <strong>collection</strong>，裡面有紀錄每篇文章的瀏覽次數。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hexo-x-Next-x-Firestore-%E9%A1%AF%E7%A4%BA%E7%80%8F%E8%A6%BD%E4%BA%BA%E6%AC%A1%2Fvisitors_test.png?alt=media&amp;token=a6a8dae6-4aeb-4e12-96b4-069144f36485" alt="閱讀次數測試"><span class="image-caption">閱讀次數測試</span></p>
<h2 id="修改-Firestore-安全性設定"><a href="#修改-Firestore-安全性設定" class="headerlink" title="修改 Firestore 安全性設定"></a>修改 Firestore 安全性設定</h2><p>確定有寫入後，那就要修改一下 <strong>Firestore</strong> 的規則，讓應用對特定的 <strong>collection</strong> 或 <strong>article</strong> 擁有特定的權限，要特別注意的是，有時候測試雖然會看到從 0 變成 1，但在 firestore 卻沒看到數據，最有可能的原因就是 firestore 安全性規則擋掉了創建文件的權限。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hexo-x-Next-x-Firestore-%E9%A1%AF%E7%A4%BA%E7%80%8F%E8%A6%BD%E4%BA%BA%E6%AC%A1%2Ffirestore_security.png?alt=media&amp;token=10cc20c9-72bd-41f2-b515-5f6ee81d63e2" alt="Firestore 安全性設定"><span class="image-caption">Firestore 安全性設定</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules_version = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">service cloud.<span class="property">firestore</span> &#123;</span><br><span class="line">  match /databases/&#123;database&#125;/documents &#123;</span><br><span class="line">    match /articles/&#123;<span class="variable language_">document</span>=**&#125; &#123;</span><br><span class="line">      allow read, <span class="attr">create</span>: <span class="keyword">if</span> <span class="literal">true</span>;</span><br><span class="line">      allow <span class="attr">write</span>: <span class="keyword">if</span> request.<span class="property">resource</span>.<span class="property">data</span>.<span class="property">count</span>==resource.<span class="property">data</span>.<span class="property">count</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    match /&#123;<span class="variable language_">document</span>=**&#125; &#123;</span><br><span class="line">      allow read, <span class="attr">write</span>: <span class="keyword">if</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo 使用筆記</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>hexo</tag>
        <tag>firestore</tag>
        <tag>visitors</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo × NexT × LikeCoin 安裝</title>
    <url>/2021/07/09/hexo_next_likecoin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LikeCoin 是一種區塊鏈技術的應用，旨在讓優質內容的提供者能夠得到應得的回報。這篇文章記錄如何在 Hexo 搭配 NexT 主題時，在文章頁面中安裝 LikeCoin。雖然官方有給出教學，但程式碼有些微錯誤且安裝過程中會報錯，讓我決定還是記錄下自己的安裝步驟，讓以後的自己或有需要的讀者可以參考。</p>
<h2 id="like-coin-swig"><a href="#like-coin-swig" class="headerlink" title="like_coin.swig"></a>like_coin.swig</h2><p>先建立 <code>themes/next/layout/_custom/like_coin.swig</code>，方便在其他檔案中直接引用 LikeCoin，不需重複輸入程式碼，內容如下，記得將 <code>[LikerID]</code> 修改為自己的 LikerID</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">write</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;&lt;iframe scrolling=&#x27;no&#x27; frameborder=&#x27;0&#x27; style=&#x27;height: 212px; width: 100%;&#x27; &quot;</span> + </span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;sandbox=&#x27;allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-storage-access-by-user-activation&#x27; &quot;</span> + </span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;src=&#x27;https://button.like.co/in/embed/[LikerID]/button?referrer=&quot;</span> +</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">encodeURIComponent</span>(location.<span class="property">href</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;#&quot;</span>)[<span class="number">0</span>]) + <span class="string">&quot;&#x27;&gt;&lt;/iframe&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>這邊特別注意閉 <code>div</code> 是要有反斜線 (<code>&lt;/div&gt;</code>) 的，原官方教學因少了反斜線讓我整個版面走鐘，debug 很久才找到這個小錯誤。</p>
          </div>
<h2 id="加上-LikeCoin"><a href="#加上-LikeCoin" class="headerlink" title="加上 LikeCoin"></a>加上 LikeCoin</h2><h3 id="每個-Post"><a href="#每個-Post" class="headerlink" title="每個 Post"></a>每個 Post</h3><p>NexT 主題對於 Post 的 Layout 是寫在 <code>themes/next/layout/_macro/post.swig</code>，因此若想在每篇文章加上 LikeCoin，修改此檔案即可，我是在相關文章區塊前加上 LikeCoin，若想看效果，可以拉到文章下方 LikeCoin 處查看。放在此處並且能顯示的前提是，在主題 <code>_config.yml</code> 的 <code>related_posts</code> 需要啟用才會顯示，若無啟用，可以調整放置到任何想放置的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;</span><br><span class="line">    &#123;&#123; partial(&#x27;../_custom/like_coin.swig&#x27;) &#125;&#125;</span><br><span class="line">    &#123;&#123; partial(&#x27;_partials/post/post-related.swig&#x27;) &#125;&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>若是依照原官方教學使用 ejs + include，會出現明明檔案存在但回報 <code>template not found</code> 的情況，但若按照我上方的作法，就可以在文章中正常顯示 LikeCoin 囉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Error: template not found: D:\weirenxue.github.io\themes\next\layout\_custom\like_coin.ejs</span><br></pre></td></tr></table></figure>
          </div>
<h3 id="每個-Page"><a href="#每個-Page" class="headerlink" title="每個 Page"></a>每個 Page</h3><p>NexT 主題對於 Page 的 Layout 是寫在 <code>themes/next/layout/page.swig</code>，因此若想在每個頁面 (例如：tag、category 或其他自建頁面，但不包含 archive 頁面) 加上 LikeCoin，修改此檔案即可，這邊我是在該頁面主體結束後加上 LikeCoin，若想看放置後的效果可以到我的頁面 <a href="/tools/">工具箱</a>、<a href="/portfolios/">學習歷程</a> 查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &#123;#####################&#125;</span><br><span class="line">    &#123;### END PAGE BODY ###&#125;</span><br><span class="line">    &#123;#####################&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% include &#x27;_partials/page/breadcrumb.swig&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; partial(&#x27;./_custom/like_coin.swig&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><p>NexT 主題對於 Archive 頁面的 Layout 是獨立寫在 <code>themes/next/layout/archive.swig</code>，因此若想在歸檔頁面加上 LikeCoin，修改此檔案即可，這邊同樣是在該頁面主體結束後加上 LikeCoin，若想看放置後的效果可以到 <a href="/archives/">歸檔</a> 查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; partial(&#x27;./_custom/like_coin.swig&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;#########################&#125;</span><br><span class="line">&#123;### END ARCHIVE BLOCK ###&#125;</span><br><span class="line">&#123;#########################&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://docs.like.co/v/zh/user-guide/creator/self-host/hexo-next">如何在 Hexo 開發環境的文章中加入 LikeCoin button</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo 使用筆記</category>
      </categories>
      <tags>
        <tag>ejs</tag>
        <tag>install</tag>
        <tag>next</tag>
        <tag>hexo</tag>
        <tag>likecoin</tag>
        <tag>template</tag>
        <tag>swig</tag>
        <tag>include</tag>
        <tag>partial</tag>
      </tags>
  </entry>
  <entry>
    <title>[SSL] 數位簽名與驗證的過程</title>
    <url>/2021/06/15/ssl_digital_signed_verify/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSL 是用來提升 HTTP 安全性的手法，網路上不乏許多原理講解與實作。但我有發現一個現象，就是當講到如何驗證憑證是否為某 CA 所發，都是說以 CA 公鑰去檢查憑證，但到底檢查甚麼，又是怎樣檢查的，非常令人好奇，因此查了一些相關資訊並整理後記錄在這。</p>
<h2 id="產製數位憑證"><a href="#產製數位憑證" class="headerlink" title="產製數位憑證"></a>產製數位憑證</h2><p>認證機構 (CA) 會先對要簽署的數據 (Data, 例如：Public Key, Subject ... 等等憑證資訊，皆為明碼) 做雜湊 (Hash) 運算，得到雜湊值 (Hash Value)，再以 CA 的私鑰 (Private Key) 對其加密以達到防止更改效果，這個產出即為數位簽章 (Digital Signature)</p>
<script type="math/tex; mode=display">Data\xrightarrow{HASH\;By\;CA}Hash\;Value\xrightarrow{Private\;Key\;of\;CA}Digital\;Signature</script><p>得到數位簽章後，將其與原本資料合起來，就為所謂的數位憑證 (Digital Certificate)</p>
<script type="math/tex; mode=display">Data+Digital\;Signature=Digital\;Certificate</script><p>這個數位憑證就會被稱為被某 CA 所簽發的憑證。</p>
<h2 id="驗證數位簽章"><a href="#驗證數位簽章" class="headerlink" title="驗證數位簽章"></a>驗證數位簽章</h2><p>在進行 https 連線的過程中，Server 會給 Client 一個數位憑證，當 Client 拿到數位憑證後，會馬上驗證是否真的為憑證上說的CA所發。</p>
<p>第一步把憑證拆回 Data 與 Digital Signature</p>
<script type="math/tex; mode=display">Digital\;Certificate=Data+Digital\;Signature</script><p>Client 先自行對 Data 做 Hash 運算</p>
<script type="math/tex; mode=display">Data\xrightarrow{HASH\;By\;Client}Hash\;Value</script><p>再對 Digital Signature 做解密運算，取得 CA 對 Data 做 Hash 運算的結果</p>
<script type="math/tex; mode=display">Digital\;Signature\xrightarrow{Public\;Key\;of\;CA}Hash\;Value\;via\;Signature</script><p>再比對 Client 自己算出的 Hash Value 與經由數位簽章解密所得到的 Hash Value 是否相同，若相同，表示此憑證確實是該 CA 所發！</p>
<script type="math/tex; mode=display">Hash\;Value\overset{\underset{\mathrm{?}}{}}{=}Hash\;Value\;via\;Signature</script><h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/">What is the difference between a digital signature and a digital certificate</a></li>
</ol>
]]></content>
      <categories>
        <category>SSL 筆記</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>ssl</tag>
        <tag>digital</tag>
        <tag>signature</tag>
        <tag>verify</tag>
        <tag>ca</tag>
        <tag>certificate</tag>
        <tag>private</tag>
        <tag>public</tag>
        <tag>key</tag>
      </tags>
  </entry>
  <entry>
    <title>[SSL] 確認申請回來的憑證與手中的私鑰匹配</title>
    <url>/2021/06/15/ssl_crt_key/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司為了資安規定，所有系統上線都要裝上 SSL，4 月多發出申請的 CSR (Certificate Signing Request) 到最近 9 月才拿到申請回來的憑證，這期間雖然沒有去碰私鑰的檔案，但難免會怕因為什麼因素而使公私鑰對不上，所以找了方法來驗證。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
<li>OpenSSL 1.1.1f</li>
</ul>
<h2 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h2><p>輸入下面三行指令，<code>server.key</code> 為私鑰、<code>server.crt</code> 為憑證檔 (含公鑰)、<code>server.csr</code> 為憑證簽章要求，若三個指令的結果都一樣，代表都是同一組公私鑰的產物，正常來說測試到公私鑰即可，這裡順便記錄 CSR 的測試方法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@ubuntu:~$ openssl rsa -noout -modulus -<span class="keyword">in</span> server.key | openssl md5</span><br><span class="line">(stdin)= 1981515b2826b407bf658678b2a342da</span><br><span class="line">user@ubuntu:~$ openssl x509 -noout -modulus -<span class="keyword">in</span> server.crt | openssl md5</span><br><span class="line">(stdin)= 1981515b2826b407bf658678b2a342da</span><br><span class="line">user@ubuntu:~$ openssl req -<span class="keyword">in</span> server.csr -noout -modulus | openssl md5</span><br><span class="line">(stdin)= 1981515b2826b407bf658678b2a342da</span><br></pre></td></tr></table></figure>
<p>這一步確認後，才有心情抓安裝 SSL 過程中出現的 bug。</p>
]]></content>
      <categories>
        <category>SSL 筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
        <tag>ssl</tag>
        <tag>key</tag>
        <tag>crt</tag>
        <tag>match</tag>
        <tag>cert</tag>
        <tag>csr</tag>
      </tags>
  </entry>
  <entry>
    <title>[SSL] 自簽憑證過程</title>
    <url>/2021/06/15/ssl_self_sign/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSL 是讓 Web 應用程式能擁有機密傳輸特性的一個機制，運作在應用層上。然而要申請一個有效的憑證，過程是非常耗時的，因此若在開發、測試階段，可先用自簽憑證來應急。但是！要上線的系統最好等有了合法憑證再發布，避免遭受中間人攻擊 (Man in The Middle, MITM)。</p>
<h2 id="產生-CA-SSL"><a href="#產生-CA-SSL" class="headerlink" title="產生 CA SSL"></a>產生 CA SSL</h2><p>⾸先為我們的 CA (Certificate Authority) 產⽣⼀把私鑰，這個步驟可以說是為自己建立一個 CA，這個 CA 完全由自己掌控</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out root/ca.key 4096</span><br></pre></td></tr></table></figure>
<p>再使⽤這把私鑰產⽣⼀份⾃我簽署的 CA 憑證，其中 <code>subj</code> 可依自己需求做更改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -sha256 \ </span><br><span class="line">    -subj <span class="string">&quot;/C=TW/ST=Taipei/O=your_company/OU=your_department/CN=localhost&quot;</span> \ </span><br><span class="line">    -key root/ca.key \ </span><br><span class="line">    -out root/ca.crt</span><br></pre></td></tr></table></figure>
<h2 id="產生-Server-SSL"><a href="#產生-Server-SSL" class="headerlink" title="產生 Server SSL"></a>產生 Server SSL</h2><p>為我們的 Server 產⽣不加密之 PEM 格式的私密⾦鑰</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server/server.key 2048</span><br></pre></td></tr></table></figure>
<p>產⽣憑證請求檔 CSR (Certificate Signing Request)，其中 <code>subj</code> 可依自己需求做更改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -new -key server/server.key \ </span><br><span class="line">    -subj <span class="string">&quot;/C=TW/ST=Taipei/O=your_company/OU=your_department/CN=your_service_FQDN&quot;</span> \ </span><br><span class="line">    -out server/server.csr</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CN</code> 會填上 Server 的 FQDN，要注意的是 <strong>CN 不可與 CA 的 CN 相同</strong>。</li>
</ul>
<p>把 CSR 丟給自己的 CA 簽署，也可以換句話說：讓自己的 CA 簽署該憑證</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -CAcreateserial -days 30 -sha256 \ </span><br><span class="line">    -CA root/ca.crt -CAkey root/ca.key \ </span><br><span class="line">    -<span class="keyword">in</span> server/server.csr \ </span><br><span class="line">    -out server/server.crt</span><br></pre></td></tr></table></figure>
<p>現在⽬錄應該有以下這些文件，<code>server.key</code> 是 Server 的私鑰，<code>server.crt</code> 是 Server 的憑證，也因為是用我們自創的 CA 來簽核的一個憑證，又稱為自簽憑證</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -alR . </span><br><span class="line"></span><br><span class="line">./root: </span><br><span class="line">total 20 </span><br><span class="line">drwxrwxr-x 2 user user 4096 Oct 21 02:05 . </span><br><span class="line">drwxrwxr-x 4 user user 4096 Oct  7 22:40 .. </span><br><span class="line">-rw-rw-r-- 1 user user 1968 Oct 21 02:05 ca.crt </span><br><span class="line">-rw------- 1 user user 3243 Oct 21 02:05 ca.key </span><br><span class="line">-rw-rw-r-- 1 user user   41 Oct 21 02:05 ca.srl </span><br><span class="line"></span><br><span class="line">./server: </span><br><span class="line">total 20 </span><br><span class="line">drwxrwxr-x 2 user user 4096 Oct 21 02:05 . </span><br><span class="line">drwxrwxr-x 4 user user 4096 Oct  7 22:40 .. </span><br><span class="line">-rw-rw-r-- 1 user user 1501 Oct 21 02:05 server.crt </span><br><span class="line">-rw-rw-r-- 1 user user  972 Oct 21 02:05 server.csr </span><br><span class="line">-rw------- 1 user user 1679 Oct 21 02:05 server.key</span><br></pre></td></tr></table></figure>
<div class="note info">
            <ol><li>若讀者想知道如何確認 CA 簽回的憑證是否與手上私鑰是一對的，可以參考 <a href="/2021/06/15/ssl_crt_key/">[SSL] 確認申請回來的憑證與手中的私鑰匹配</a>。</li><li>若讀者想更進一步知道 SSL 簽名與驗證過程，也可以參考 <a href="/2021/06/15/ssl_digital_signed_verify/">[SSL] 數位簽名與驗證的過程</a>。</li></ol>
          </div>
]]></content>
      <categories>
        <category>SSL 筆記</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>ca</tag>
        <tag>key</tag>
        <tag>crt</tag>
        <tag>csr</tag>
        <tag>self</tag>
        <tag>sign</tag>
        <tag>openssl</tag>
        <tag>mitm</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vivado Vitis] 在軟體開發環境中缺少一堆 .h 檔的解決方法</title>
    <url>/2021/06/13/vivado_vitis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接手一個 Zynq 的開發板 (RFSoC ZCU111)，新手上路肯定是要參考網路上豐富的文件，才會學得快。但在參考文獻的過程中碰到一個似乎教學的作者沒有提及，但自己遇到的問題，也就是 Build 時缺少一堆 <code>.h</code> 檔案的錯誤提示。</p>
<h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><ul>
<li>Vivado 2019.2</li>
<li>Vitis 2019.2</li>
<li>Windows 10</li>
</ul>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>網路上沒有提供清楚的解決方法，因此自己記錄下遇到的問題與解決的步驟</p>
<ol>
<li><p>在 Vitis (或 SDK) 創建 Application Project，硬體平台選擇 Vivado 輸出的 <code>*.xsa</code> 檔案，並且將範例 <code>*.c</code> 檔匯入 <code>src</code> 目錄下，開始 Build，會出現以下的提示，這是在路徑下找不到 <code>*.h</code> 檔案的意思，但照理來說 Vivado 的 <code>xsa</code> 都包含這些了。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">22:54:01 **** Incremental Build of configuration Debug <span class="keyword">for</span> project LED ****</span><br><span class="line">make all </span><br><span class="line">make --no-print-directory pre-build</span><br><span class="line">a9-linaro-pre-build-step</span><br><span class="line"><span class="string">&#x27; &#x27;</span></span><br><span class="line">make --no-print-directory main-build</span><br><span class="line"><span class="string">&#x27;Building file: ../src/LED_test_tut_1C.c&#x27;</span></span><br><span class="line"><span class="string">&#x27;Invoking: ARM v7 gcc compiler&#x27;</span></span><br><span class="line">arm-none-eabi-gcc -Wall -O0 -g3 -c -fmessage-length=0 -MT<span class="string">&quot;src/LED_test_tut_1C.o&quot;</span> -mcpu=cortex-a9 -mfpu=vfpv3 -mfloat-abi=hard -IC:/Zynq_Book/first_zynq_design/SDK/first_zynq_system_wrapper/export/first_zynq_system_wrapper/sw/first_zynq_system_wrapper/standalone_domain/bspinclude/include -MMD -MP -MF<span class="string">&quot;src/LED_test_tut_1C.d&quot;</span> -MT<span class="string">&quot;src/LED_test_tut_1C.o&quot;</span> -o <span class="string">&quot;src/LED_test_tut_1C.o&quot;</span> <span class="string">&quot;../src/LED_test_tut_1C.c&quot;</span></span><br><span class="line">../src/LED_test_tut_1C.c:31:10: fatal error: xgpio.h: No such file or directory</span><br><span class="line"><span class="comment">#include &quot;xgpio.h&quot;</span></span><br><span class="line">        ^~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">make[1]: *** [src/subdir.mk:23: src/LED_test_tut_1C.o] Error 1</span><br><span class="line">make: *** [makefile:34: all] Error 2</span><br><span class="line"></span><br><span class="line">22:54:02 Build Finished (took 987ms)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看在 <code>*.h</code> 目錄底下到底有甚麼檔案，我的路徑為：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\Zynq_Book\first_zynq_design\SDK\first_zynq_system_wrapper\<span class="built_in">export</span>\first_zynq_system_wrapper\sw\first_zynq_system_wrapper\standalone_domain\bspinclude\include</span><br></pre></td></tr></table></figure>
<p> 發現只有一個檔案 <code>xparameters.h</code> ，這為不正常的結果。</p>
</li>
<li><p>再回到 Vitis 畫面，直接重新 Build BSP 一次，並等待執行完成。再回到步驟 2 的路徑去查看，會發現多出很多 <code>*.h</code> 檔案，回到Vitis，Build <code>*.c</code> 檔案，結果為可以順利完成。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Xilinx 使用筆記</category>
      </categories>
      <tags>
        <tag>vivado</tag>
        <tag>vitis</tag>
        <tag>h</tag>
        <tag>lack</tag>
        <tag>sdk</tag>
        <tag>xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title>[Xilinx SDK] GPIO 常用到的參數</title>
    <url>/2021/06/13/xilinx_sdk_gpio/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 API 時，最重要的是正確地輸入對應參數，因此必定要先了解參數所代表的涵義，才能有正確的使用 API 姿勢。</p>
<h2 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h2><ul>
<li>RFSoC ZCU111</li>
</ul>
<h2 id="參數說明"><a href="#參數說明" class="headerlink" title="參數說明"></a>參數說明</h2><ol>
<li><p><code>channel</code>：這是在 Vivado 內使用 IP 來做設計時就決定的，打開 GPIO 的 IP 設定視窗可以看到 GPIO 與 GPIO2，這裡的例子通道 1 與通道 2 分別為 led 與 push button。</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Xilinx-SDK-GPIO-%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%83%E6%95%B8%2Fgpio.png?alt=media&amp;token=1edff119-f05f-4e10-bc7a-fb60595872fa" alt="GPIO IP 設定畫面"><span class="image-caption">GPIO IP 設定畫面</span></p>
</li>
<li><p><code>DirectionMask</code>：這是決定 GPIO 為輸入或輸出 (相對於晶片來說) 的參數，需要特別點開 <code>*.h</code> 或 <code>*.c</code> 去看說明，此說明在 <code>xgpio.c</code> 的註解裡，以下為摘要</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bits set to 0 are output and bits set to 1 are input.</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Xilinx 使用筆記</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>sdk</tag>
        <tag>xilinx</tag>
        <tag>gpio</tag>
        <tag>channel</tag>
        <tag>directionmask</tag>
      </tags>
  </entry>
  <entry>
    <title>[Xilinx SDK] make: Nothing to be done for &#39;all&#39;. 的問題</title>
    <url>/2021/06/13/xilinx_sdk_make_nothing_to_be_done_for_all/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Xilinx SDK 編輯完程式之後，通常會 Build Project 看看是否可以運行，但常常在 Console 看到 <code>make: Nothing to be done for &#39;all&#39;.</code> 的訊息。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>這個意思是跟上次編譯結果相比，沒有東西被更動，所以不需要再 make 一次。明明剛修改好然後而去按 Build Project，為什麼也會看到這訊息呢？這主要是因為 SDK 預設存檔的動作包含 Build，也就是說，存檔 + Build Project是同時做的，存好檔案之後可以直接在 Console 查看 Build 的結果，不需要再自行編譯一次。</p>
]]></content>
      <categories>
        <category>Xilinx 使用筆記</category>
      </categories>
      <tags>
        <tag>sdk</tag>
        <tag>xilinx</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Slack Webhook! 一起 Slack 最大化</title>
    <url>/2021/09/09/hello_slack_webhook/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Slack 通訊軟體儼然成為企業在合作溝通上的一種選擇，除了可以針對特定不同專案開設不同頻道外，還能使用 Incoming Webhooks、Slash Commands 等工具協助作業流程自動化。這篇文章記錄如何建立 Incoming Webhooks 並且實際通過 Webhook 傳輸訊息！</p>
<h2 id="建立-Slack-應用程式"><a href="#建立-Slack-應用程式" class="headerlink" title="建立 Slack 應用程式"></a>建立 Slack 應用程式</h2><p>由工作空間畫面左上方 <code>工作空間(圖中為 WRXUE-個人工作室) → 設定與管理 → 管理應用程式</code>，進入管理應用程式介面</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fmanage_app.png?alt=media&amp;token=0493f7fe-8b2c-4746-96b0-a68168389c62" alt="開啟管理應用程式介面"><span class="image-caption">開啟管理應用程式介面</span></p>
<p>於應用程式管理介面右上角點擊 <code>建立</code> 按鈕，進入建立應用程式介面</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fcreate_app.png?alt=media&amp;token=f0b34e79-e02d-4187-84d0-a0d64c659f77" alt="進入建立應用程式介面"><span class="image-caption">進入建立應用程式介面</span></p>
<p>點選 <code>Create New App</code> 按鈕來新增一個 Slack 應用程式</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fcreate_new_app.png?alt=media&amp;token=e3a5ac05-c746-422e-8887-51e121bcc2a7" alt="新增 Slack 應用程式"><span class="image-caption">新增 Slack 應用程式</span></p>
<p>選擇 <code>From scratch</code> 方法從頭開始建立應用程式，填寫應用程式名稱 (<code>App Name</code>) 與選擇該應用程式所對應的工作空間 (<code>Pick a workspace to develop your app in:</code>)，這裡要注意的是應用程式名稱在建立之後可以更改，但所對應工作空間是不能更改的</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fcreate_new_app_detail.png?alt=media&amp;token=b52c517a-9af2-4beb-b014-ad4b91f68a2a" alt="填寫詳細資訊"><span class="image-caption">填寫詳細資訊</span></p>
<p>建立完成後會跳轉到所建立應用程式的設定介面，先啟用 <code>Incoming Webhooks</code> 功能</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fenable_webhook.png?alt=media&amp;token=e723f8c5-b660-4026-8f4e-ae84d06fad1a" alt="啟用 Incoming Webhooks"><span class="image-caption">啟用 Incoming Webhooks</span></p>
<p>並於 <code>App Home</code> 設定中設定顯示名稱，這步一定要執行，否則在設定 <code>Incoming Webhook</code> 時可能會出現錯誤訊息</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fapp_home.png?alt=media&amp;token=237e7fd8-a843-4ec3-a97e-a18066d1424c" alt="修改應用程式首頁顯示設定"><span class="image-caption">修改應用程式首頁顯示設定</span></p>
<h2 id="建立-Webhook-URL"><a href="#建立-Webhook-URL" class="headerlink" title="建立 Webhook URL"></a>建立 Webhook URL</h2><p>在 <code>Incoming Webhooks</code> 設定中新增 (<code>Add New Webhook to Workspace</code>) 一個 Webhook，並選擇該 Webhook 對應到的頻道或私訊</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fincoming_webhooks_add.png?alt=media&amp;token=40307e42-193d-4e72-833e-7e31542744ce" alt="新增一個 Webhook URL"><span class="image-caption">新增一個 Webhook URL</span></p>
<p>新增之後，可以回到 Slack 中查看該頻道中是否出現整合訊息 (<code>added an integration to this channels: &#123;APP Name&#125;</code>)，若有則代表該 Webhook 確實對應到該頻道</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fwebhook_integration_msg.png?alt=media&amp;token=b7245ece-ea71-4795-a1ba-1b34635947ea" alt="應用程式整合頻道訊息"><span class="image-caption">應用程式整合頻道訊息</span></p>
<p>每個 Webhook 都有一個專屬的 URL，該 URL 為機密性的，每個擁有該 URL 的人都可以往該頻道發送訊息，因此 URL 需要保護好</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fwebhook_url_copy.png?alt=media&amp;token=a0c2a0c5-6d2c-4b88-ba08-27205fa5cd5e" alt="Webhook URL"><span class="image-caption">Webhook URL</span></p>
<h2 id="測試-Slack-Webhook"><a href="#測試-Slack-Webhook" class="headerlink" title="測試 Slack Webhook"></a>測試 Slack Webhook</h2><p>這裡使用 <a href="https://www.postman.com/">Postman</a> 這套強大的 API 測試軟體來進行 Webhook 的測試。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Hello-Slack-Webhook-%E4%B8%80%E8%B5%B7-Slack-%E6%9C%80%E5%A4%A7%E5%8C%96%2Fwebhook_test.png?alt=media&amp;token=d2ecb387-2771-4d01-98c9-65d7b90b356d" alt="發送測試訊息"><span class="image-caption">發送測試訊息</span></p>
<ol>
<li>選擇 <code>POST</code> 方法。</li>
<li>將 Webhook URL 貼上。</li>
<li>選擇 <code>Body</code> 設定 Payload。</li>
<li>選擇 <code>raw</code> 讓 Payload 為純文字。</li>
<li>選擇 <code>JSON</code> 讓 Payload 為 JSON 格式。</li>
<li>貼上 <a href="https://app.slack.com/block-kit-builder/T01TUSL8UAV#%7B%22blocks%22:%5B%7B%22type%22:%22section%22,%22text%22:%7B%22type%22:%22mrkdwn%22,%22text%22:%22Hello%20Slack%20Webhook!%22%7D%7D%5D%7D">Payload</a> <!-- markdownlint-disable MD031 -->
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;blocks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;section&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mrkdwn&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello Slack Webhook!&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>點擊 Send 按鈕，送出製作好的 Request。</li>
<li>Slack Webhook 伺服器回應訊息為 <code>ok</code>，代表運作正常；若非 <code>ok</code> 則表示有問題存在。</li>
<li>在頻道中能看到剛剛傳遞的訊息囉！！ (<code>Hello Slack Webhook!</code>)<!-- markdownlint-restore MD031 -->
</li>
</ol>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Slack Webhook 這個功能其實算是蠻方便使用的一個功能，可以舉幾個應用情境給讀者想像 (<strong>非常歡迎各位讀者於討論區分享自己的使用情境～讓大家可以互相學習與進步</strong>)：</p>
<ol>
<li>每天需要人工去檢查備份資料的工作，可以交由排程將報表透過 Webhook 傳到頻道中，讓相關人士都可以得到第一手資訊。</li>
<li>追的劇或者漫畫更新時，傳訊息到頻道中。</li>
<li>傳個人部落格瀏覽率報表到頻道中。</li>
<li>伺服器若有異常，可傳訊息通知頻道中的人員。</li>
</ol>
<p>簡單來說，任何要人工查看程式執行結果的作業項目，都可以考慮結合 Slack Webhook，將結果直接顯示在頻道中。</p>
]]></content>
      <categories>
        <category>Slack 使用筆記</category>
      </categories>
      <tags>
        <tag>channel</tag>
        <tag>slack</tag>
        <tag>webhook</tag>
        <tag>command</tag>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title>[Slack API] files.upload 將檔案傳到頻道中</title>
    <url>/2021/09/10/slack_api_files_upload/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2021/09/09/hello_slack_webhook/">Hello Slack Webhook! 一起 Slack 最大化</a> 一文詳細說明如何使用 Slack 的 Incoming Webhook 來做到將訊息傳送到頻道或對話中。儘管 Slack Webhook 如此好用，還是有美中不足的地方，也就是它無法傳送檔案，必須使用其他方法來達到傳送檔案的功能。這篇文章詳細記載如何在 Slack 中開通傳送檔案權限，最後再以 Python 寫一個傳送檔案的範例，讓讀者更有感。</p>
<h2 id="開通-Slack-寫檔案權限"><a href="#開通-Slack-寫檔案權限" class="headerlink" title="開通 Slack 寫檔案權限"></a>開通 Slack 寫檔案權限</h2><p>需先按照 <a href="/2021/09/09/hello_slack_webhook/">Hello Slack Webhook! 一起 Slack 最大化</a> 創建一個 Slack 應用程式，再於 <code>OAuth &amp; Permissions</code> 設定中新增 <code>files.write</code> 權限，並且重新安裝應用程式 (<code>reinstall your app</code>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Ffiles_write_permission.png?alt=media&amp;token=3bd96ee1-6e23-4529-bcf3-f1c11fe29d74" alt="設定 files:write 權限"><span class="image-caption">設定 files:write 權限</span></p>
<p>並且允許應用程式可以取得這項權限</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Fallow.png?alt=media&amp;token=a91885f6-543b-4f89-ba57-1e6f43c360f5" alt="允許"><span class="image-caption">允許</span></p>
<p>記下 <code>Bot User OAuth Token</code>，其為 <code>xoxb-</code> 開頭 (若為 <code>User OAuth Token</code> 則為 <code>xoxp-</code> 開頭，參考 <a href="https://api.slack.com/authentication/token-types#bot">Access tokens</a>)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Foauth_token.png?alt=media&amp;token=f6a6f2a4-5f1f-4a17-b8ab-07607c30eb74" alt="Bot User OAuth Token"><span class="image-caption">Bot User OAuth Token</span></p>
<p>OAuth Token 為機密性的資訊，若有外流或其他情況可以選擇到 <code>OAuth &amp; Permissions</code> 最下方撤銷 Token。如此一來，重新安裝該 Slack 應用程式到工作空間時，便可得到新的 OAuth Token</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Frevoke%20tokens.png?alt=media&amp;token=e485fffb-3201-4b7b-9523-f8dabc00e014" alt="撤銷 OAuth Token"><span class="image-caption">撤銷 OAuth Token</span></p>
<h2 id="將應用程式整合至頻道中"><a href="#將應用程式整合至頻道中" class="headerlink" title="將應用程式整合至頻道中"></a>將應用程式整合至頻道中</h2><p>與 Webhook 不同的是，使用 <a href="https://api.slack.com/methods/files.upload">files.upload</a> API 上傳檔案之前，需要將應用程式加入到 (整合) 對應的頻道中</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Fintegrate_app.png?alt=media&amp;token=a2b17e30-13f4-4930-91e7-7b73f4c84af0" alt="頻道整合"><span class="image-caption">頻道整合</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Fadd_integrate_app.png?alt=media&amp;token=6479c423-0d8c-41aa-9c7d-b8e87fb6d38a" alt="選擇應用程式"><span class="image-caption">選擇應用程式</span></p>
<p>若頻道中出現對應訊息，表示應用程式已經整合進頻道中囉！</p>
<h2 id="測試檔案上傳"><a href="#測試檔案上傳" class="headerlink" title="測試檔案上傳"></a>測試檔案上傳</h2><h3 id="傳至特定頻道中"><a href="#傳至特定頻道中" class="headerlink" title="傳至特定頻道中"></a>傳至特定頻道中</h3><p><a href="https://api.slack.com/methods/files.upload">files.upload</a> 是透過頻道識別碼來判斷要上傳到哪一個頻道中的，因此需要先記錄下頻道識別碼，該資訊可以在頻道的 <code>關於</code> 或網址列中得到</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Fchannel_id.png?alt=media&amp;token=99ffaad6-e29d-44f4-980e-19a80f6d6eab" alt="頻道識別碼位置"><span class="image-caption">頻道識別碼位置</span></p>
<p>準備一個內容如下的測試檔案 <code>D:\test.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello Slack files.upload!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wei-Ren Xue&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在執行 Python 程式之前，需要先安裝 <a href="https://slack.dev/python-slack-sdk/#installation">slack_sdk</a> 套件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install slack_sdk</span><br></pre></td></tr></table></figure>
<p>等待套件安裝完畢，便可執行下方 Python 程式，主要有三個地方要注意</p>
<ol>
<li><code>your_bot_user_auth_token</code>：取代為你的 <code>Bot User OAuth Token</code> (<code>xoxb-</code> 為開頭)。</li>
<li><code>target_channel_id</code>：取代為你的頻道識別碼。若想一次傳給多個頻道，可以用半形逗號 (,) 來分隔，例如：傳給 <code>C111</code> 與 <code>C222</code> 頻道，則將 <code>target_channel_id</code> 替換為 <code>C111,C222</code>。當然地，對應的頻道需要將該 Slack 應用程式整合進頻道中才能接收到檔案。</li>
<li><code>D:/test.json</code>：檔案路徑的部分需要依讀者的環境來做變化。</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> slack_sdk <span class="keyword">import</span> WebClient</span><br><span class="line"><span class="keyword">from</span> slack_sdk.errors <span class="keyword">import</span> SlackApiError</span><br><span class="line"></span><br><span class="line">oauth_token = <span class="string">&#x27;your_bot_user_auth_token&#x27;</span></span><br><span class="line">client = WebClient(token=oauth_token)</span><br><span class="line">channel_id = <span class="string">&#x27;target_channel_id&#x27;</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;D:/test.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = client.files_upload(</span><br><span class="line">        channels=channel_id,</span><br><span class="line">        initial_comment=<span class="string">&#x27;Here\&#x27;s my file :smile:&#x27;</span>,</span><br><span class="line">        file=file_name,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">except</span> SlackApiError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error uploading file: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br></pre></td></tr></table></figure>
<p>最後，在頻道中就能看到 Slack 應用程式傳來的檔案囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Ffile_content.png?alt=media&amp;token=16b1c62a-cc4a-4210-abde-4918f600723d" alt="透過 Python 傳輸檔案到 Channel 中"><span class="image-caption">透過 Python 傳輸檔案到 Channel 中</span></p>
<h3 id="私訊傳至特定使用者"><a href="#私訊傳至特定使用者" class="headerlink" title="私訊傳至特定使用者"></a>私訊傳至特定使用者</h3><p>與頻道識別碼相同，需要先找出使用者識別碼。首先於工作空間的左側選單中找到 <code>人員與使用者群組</code>，再尋找想要用 Slack API 私訊的成員，點擊 <code>更多</code> 即可查看成員識別碼</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Slack-API-files-upload-%E5%B0%87%E6%AA%94%E6%A1%88%E5%82%B3%E5%88%B0%E9%A0%BB%E9%81%93%E4%B8%AD%2Fuser_id.png?alt=media&amp;token=3a0c40c6-ed54-4ceb-87dc-a8580e3b891b" alt="使用者識別碼"><span class="image-caption">使用者識別碼</span></p>
<p>使用與傳輸至頻道一樣的程式碼，只是 <code>target_channel_id</code> 就需要用使用者識別碼來取代。同樣地，可以使用半形逗號 (,) 來分隔多個頻道識別碼、使用者識別碼，一次將檔案傳輸給多個頻道或者私訊給多個使用者！</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Slack API 與 Webhook 是互補的關係，舉例來說：我們可以透過 <code>files.upload</code> 上傳檔案後，再用 <code>Webhook</code> 傳輸訊息來對檔案做註解，讓頻道中的同仁可以更清楚該檔案的作用是甚麼。因此，並不是只能在 Slack API 與 Webhook 兩者中擇一使用，這樣的特性讓 Slack 應用程式使用方式更多元！</p>
]]></content>
      <categories>
        <category>Slack 使用筆記</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>channel</tag>
        <tag>slack</tag>
        <tag>webhook</tag>
        <tag>files</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist 幫你吸引目光 - 文章點閱率顯示</title>
    <url>/2021/10/31/gist_article_click/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GitHub 的 Gist 服務不僅能拿來紀錄程式碼片段、寫筆記，還能讓你的 GitHub Profile 更加引人注目。此篇文章紀錄如何使用 Gist API 將部落格點擊率放置到 GitHub Profile！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Gist-%E5%B9%AB%E4%BD%A0%E5%90%B8%E5%BC%95%E7%9B%AE%E5%85%89-%E6%96%87%E7%AB%A0%E9%BB%9E%E9%96%B1%E7%8E%87%E9%A1%AF%E7%A4%BA%2Fgithub_profile.png?alt=media&amp;token=b5f60c45-089d-4306-9ab4-b99606956147" alt="完成後的樣子"><span class="image-caption">完成後的樣子</span></p>
<div class="note info">
            <p>歡迎直接進入<a href="https://github.com/weirenxue">我的 GitHub</a> 參觀唷！</p>
          </div>
<!-- markdownlint-disable MD034 -->
<a class="btn" href="https://github.com/weirenxue/click-ranking-gist" title="Source Code of using Gist API">
            <i class="fab fa-github"></i>Source Code
          </a>
<!-- markdownlint-restore MD034 -->
<h2 id="Gist-API"><a href="#Gist-API" class="headerlink" title="Gist API"></a>Gist API</h2><p><a href="https://docs.github.com/en/rest/reference/gists">Gist API</a> 有提供 Shell 操作 API 的範例，基本上可以透過任何程式語言來操作。此外，也有提供 Node 的 SDK <a href="https://github.com/octokit/core.js#readme">octokit/core.js</a> 使我們不需要從頭建立一個 Request，只需給定參數即可達到想要效果。秉持著用輪不造輪的精神，此專案使用 <a href="https://github.com/octokit/core.js#readme">octokit/core.js</a> 呼叫 Gist API。</p>
<h2 id="手動建立一個-Gist"><a href="#手動建立一個-Gist" class="headerlink" title="手動建立一個 Gist"></a>手動建立一個 Gist</h2><p>在使用 Gist API 更新 Gist 之前，需要先有一個可被更新的 Gist 目標，若沒有則需要建立一個 Gist。進入 <a href="https://gist.github.com/">GitHub Gist 創建頁面</a>，如下圖建立一個 <strong>Public Gist</strong> (若為 Secret Gist 則無法釘選到 GitHub Profile)</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Gist-%E5%B9%AB%E4%BD%A0%E5%90%B8%E5%BC%95%E7%9B%AE%E5%85%89-%E6%96%87%E7%AB%A0%E9%BB%9E%E9%96%B1%E7%8E%87%E9%A1%AF%E7%A4%BA%2Fcreate_a_gist.png?alt=media&amp;token=26993bca-e51b-474d-a1f6-ed1cd9a8c99b" alt="建立一個 Gist"><span class="image-caption">建立一個 Gist</span></p>
<p>再進入該 Gist 觀察 URL，記下 URL 中的 Gist ID。例如：<a href="https://gist.github.com/weirenxue/1582d41aa4cf561d9a51fc1606f388bc">我的 Gist</a> ，其 Gist ID 為 <code>1582d41aa4cf561d9a51fc1606f388bc</code>。</p>
<h2 id="申請-PAT"><a href="#申請-PAT" class="headerlink" title="申請 PAT"></a>申請 PAT</h2><p>參考申請 PAT (Personal Access Token) 的詳細教學 <a href="/2021/08/17/github_pat/">[GitHub] Please use a personal access token instead.</a>，其中需要注意的是 <code>Select scopes</code> 要勾選 <code>gist (Create gists)</code>，這樣才有編輯 Gist 的權限唷！申請好之後別忘了把 PAT 記錄下來。</p>
<h2 id="使用-octokit-core-上傳內容"><a href="#使用-octokit-core-上傳內容" class="headerlink" title="使用 @octokit/core 上傳內容"></a>使用 @octokit/core 上傳內容</h2><p>開發之前，需先安裝 <code>@octokit/core</code> 套件至 Node 專案中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i @octokit/core</span><br></pre></td></tr></table></figure>
<p>上傳內容到指定 Gist ID 下的檔案，以註解來說明程式運作邏輯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Octokit</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;@octokit/core&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = []</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        處理取得部落格點閱率的邏輯，</span></span><br><span class="line"><span class="comment">        並用 data 變數來存每一筆紀錄</span></span><br><span class="line"><span class="comment">        例如：</span></span><br><span class="line"><span class="comment">        record = `$&#123;點閱率&#125;|$&#123;文章名稱&#125;`;</span></span><br><span class="line"><span class="comment">        data.push(record);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// &#123;PAT&#125; 要替換為真實的 PAT</span></span><br><span class="line">    <span class="keyword">const</span> octokit = <span class="keyword">new</span> <span class="title class_">Octokit</span>(&#123;</span><br><span class="line">        <span class="attr">auth</span>: <span class="string">&#x27;&#123;PAT&#125;&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// &#123;gist_id&#125; 要替換為真實的 Gist ID</span></span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> octokit.<span class="title function_">request</span>(<span class="string">&#x27;PATCH /gists/&#123;gist_id&#125;&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">files</span>: &#123;</span><br><span class="line">            <span class="comment">// ranking 為 Gist 中的目標檔名，依情況更改</span></span><br><span class="line">            <span class="string">&#x27;ranking&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">content</span>: data.<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">public</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼叫 main 函式</span></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>
<!-- markdownlint-disable MD034 -->
<div class="note info">
            <ul><li><p>個人的專案是使用 Firebase 的 Firestore Database 來存放每個文章的點閱率。因此，若剛好讀者也是使用 Firestore Database，歡迎參考<a href="https://github.com/weirenxue/click-ranking-gist">原始碼</a>。</p></li><li><p>若讀者的部落格是 Hexo 搭配 NexT 主題的話，也可以參考 <a href="/2021/06/11/hexo_next_firestore_visitors/">Hexo × NexT × Firestore 顯示瀏覽人次</a> 如何將瀏覽人次使用 Firestore 來存放。</p></li></ul>
          </div>
<!-- markdownlint-restore MD034 -->
<h2 id="Pin-Gist-至-Profile"><a href="#Pin-Gist-至-Profile" class="headerlink" title="Pin Gist 至 Profile"></a>Pin Gist 至 Profile</h2><p>在 GitHub Profile 頁面中點擊 <code>Customize your pins</code>，選擇對應的 Gist，儲存後便可以在 Profile 看到 Gist 的內容囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Gist-%E5%B9%AB%E4%BD%A0%E5%90%B8%E5%BC%95%E7%9B%AE%E5%85%89-%E6%96%87%E7%AB%A0%E9%BB%9E%E9%96%B1%E7%8E%87%E9%A1%AF%E7%A4%BA%2Fpin_gist.png?alt=media&amp;token=b9580ccd-68a8-4f9d-baa3-a4625bed9926" alt="釘選 Gist"><span class="image-caption">釘選 Gist</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我們已經學會如何使用程式的方式上傳 Gist，若要使 Gist 能定時自動更新，讀者只需要利用排程定時運行該程式。例如：使用 Windows 內建的「工作排程器」或 Unix-like 的 Cron，皆可達到定時讓程式執行的效果，進而能定時更新 Gist 的內容。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://docs.github.com/en/rest/reference/gists">Gist API</a></p>
</li>
<li><p><a href="https://github.com/octokit/core.js#readme">octokit/core.js</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/35547115">如何在Github获取gist id？</a></p>
</li>
<li><p><a href="/2021/08/17/github_pat/">[GitHub] Please use a personal access token instead.</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/68460308/create-github-gist-using-file-with-gist-api">Create Github gist using file, with Gist API</a></p>
</li>
<li><p><a href="https://medium.com/starbugs/%E5%AF%A6%E4%BD%9C%E9%96%8B%E6%BA%90%E5%B0%8F%E5%B7%A5%E5%85%B7-%E8%88%87-github-actions-%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87-3dd2d70eeb">實作開源小工具，與 Github Actions 的第一次相遇！</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>專案開發筆記</category>
      </categories>
      <tags>
        <tag>core</tag>
        <tag>node</tag>
        <tag>js</tag>
        <tag>github</tag>
        <tag>click</tag>
        <tag>api</tag>
        <tag>firestore</tag>
        <tag>gist</tag>
        <tag>article</tag>
        <tag>octokit</tag>
      </tags>
  </entry>
  <entry>
    <title>Q Learning 自走迷宮</title>
    <url>/2021/11/26/q_learning_maze/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一著名的強化學習演算法為 Q Learning，可以這樣比喻它學習的方式：小孩對世界充滿了好奇並探索時，會觀察父母的表情來判斷當下的行為是好或壞，或者做什麼事會得到糖果或被懲罰，再藉由這些過去的經驗得到更多獎勵。此篇文章藉由 Q Learning 的想法來實現 AI 自走迷宮，透過簡短的程式讓 Q Learning 的學習步驟具象化，非常適合已先自行閱讀 Q Learning 演算法相關文章但頭腦還處於混沌、難以想像 Q Learning 實際運作的讀者。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ul>
<li><p><a href="https://www.youtube.com/watch?v=Cy3JexBq2Rg">Demo 影片</a></p>
  <!-- markdownlint-disable MD033 -->
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Cy3JexBq2Rg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

  <!-- markdownlint-restore MD033 -->
</li>
<li><p><a href="https://github.com/weirenxue/q-learning-maze">Source Code On GitHub</a></p>
</li>
</ul>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Python 3.9.5</li>
<li>pip 21.3.1</li>
<li>numpy 1.21.4</li>
</ul>
<h2 id="建立迷宮地圖"><a href="#建立迷宮地圖" class="headerlink" title="建立迷宮地圖"></a>建立迷宮地圖</h2><p>二維迷宮地圖使用二維陣列來記錄最容易，並定義數值的涵意：-1 為起始點、0 為可行走的路、1 為牆、 2 為終點</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -1 is origin, 0 is road, 1 is wall, 2 is goal </span></span><br><span class="line">maze = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Q-learning-%E8%87%AA%E8%B5%B0%E8%BF%B7%E5%AE%AE%2Fmaze.png?alt=media&amp;token=dba9f522-e9d1-44ea-b2e6-63b982222b1d" alt="二維陣列實際對應的迷宮"><span class="image-caption">二維陣列實際對應的迷宮</span></p>
<h2 id="建立遊戲環境-Environment"><a href="#建立遊戲環境-Environment" class="headerlink" title="建立遊戲環境 (Environment)"></a>建立遊戲環境 (Environment)</h2><p>除迷宮地圖外，還需要一個環境來對我們做的每個動作給予回饋，就如同小孩的動作與父母的回饋 (之於動作與環境回饋)。建立環境前，需先定義狀態 (State)、動作 (Action) 與獎懲機制 (Reward)。</p>
<h3 id="定義狀態"><a href="#定義狀態" class="headerlink" title="定義狀態"></a>定義狀態</h3><p>每一個時間點都會有一個可以描述的狀態，以二維迷宮來說，這個狀態可以定義為 Player 所在的位置 <code>state = (row, column)</code>，若 <code>state</code> 為 <code>(1, 2)</code> 表示 Player 所處狀態為 <code>row = 1</code> 且 <code>column = 2</code>。</p>
<h3 id="定義動作"><a href="#定義動作" class="headerlink" title="定義動作"></a>定義動作</h3><p>對迷宮來說，只會有四個動作 <code>up</code>、<code>down</code>、<code>left</code>、<code>right</code> 分別代表上、下、左、右</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Determine the result of an action in this state.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNextState</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    row = state[<span class="number">0</span>]</span><br><span class="line">    column = state[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;up&#x27;</span>:</span><br><span class="line">        row -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;down&#x27;</span>:</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">        column -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">        column += <span class="number">1</span></span><br><span class="line">    nextState = (row, column)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Beyond the boundary or hit the wall.</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> column &lt; <span class="number">0</span> <span class="keyword">or</span> maze[row, column] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [state, <span class="literal">False</span>]</span><br><span class="line">        <span class="comment"># Goal</span></span><br><span class="line">        <span class="keyword">elif</span> maze[row, column] == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [nextState, <span class="literal">True</span>]</span><br><span class="line">        <span class="comment"># Forward</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nextState, <span class="literal">False</span>]</span><br><span class="line">    <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># Beyond the boundary.</span></span><br><span class="line">        <span class="keyword">return</span> [state, <span class="literal">False</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>up</code>：往上移動，即 <code>row = row - 1</code>。</li>
<li><code>down</code>：往下移動，即 <code>row = row + 1</code>。</li>
<li><code>left</code>：往左移動，即 <code>column = column - 1</code>。</li>
<li><code>right</code>：往右移動，即 <code>column = column + 1</code>。</li>
<li><code>try ... except</code>：根據現在的狀態 (<code>state</code>) 計算出下一個狀態 (<code>nextState</code>)。</li>
</ul>
<h3 id="定義獎懲機制"><a href="#定義獎懲機制" class="headerlink" title="定義獎懲機制"></a>定義獎懲機制</h3><p>環境執行完對應的動作並取得下一個狀態後，即可針對這些資訊來計算對應的獎懲分數</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Execute action.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doAction</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    nextState, result = self.getNextState(state, action)</span><br><span class="line">    <span class="comment"># No move</span></span><br><span class="line">    <span class="keyword">if</span> nextState == state:</span><br><span class="line">        reward = -<span class="number">10</span></span><br><span class="line">    <span class="comment"># Goal</span></span><br><span class="line">    <span class="keyword">elif</span> result:</span><br><span class="line">        reward = <span class="number">100</span></span><br><span class="line">    <span class="comment"># Forward</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        reward = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [reward, nextState, result]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>No move</code>： 碰到牆或是邊界，即執行完動作還停在原地，回饋 <code>-10</code> 分。</li>
<li><code>Forward</code>： 可以移動，但沒有到達終點，回饋 <code>-1</code> 分。</li>
<li><code>Goal</code>：到達終點，回饋 <code>100</code> 分。</li>
</ul>
<h3 id="遊戲環境的使用方法"><a href="#遊戲環境的使用方法" class="headerlink" title="遊戲環境的使用方法"></a>遊戲環境的使用方法</h3><p>實作出環境後，我們便只需跟環境說：「Hi，我現在的狀態是 <code>(1, 2)</code>，我要做的動作是 <code>up</code>，請問得到多少回饋分數 (<code>reward</code>)？下個狀態會是什麼 (<code>nextState</code>)？遊戲結束了嗎 (<code>result</code>)？」</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Give the action to the Environment to execute</span></span><br><span class="line">state = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">action = <span class="string">&#x27;up&#x27;</span></span><br><span class="line">environment = Environment()</span><br><span class="line">reward, nextState, result = environment.doAction(state, action)</span><br></pre></td></tr></table></figure>
<h2 id="建立代理人-Agent"><a href="#建立代理人-Agent" class="headerlink" title="建立代理人 (Agent)"></a>建立代理人 (Agent)</h2><p>要真的實現 AI 玩遊戲之前，需要建立一個代理人，讓代理人代替真人去玩遊戲，換句話說：就是讓 AI 自己 (Agent) 與遊戲環境 (Environment) 去互動。而我們的 Q Learning 就是實作在代理人這端，讓代理人可以根據 Q Table 與當前狀態，來決定下一個要執行的動作是什麼，在過程中不停的透過決策與獎勵來更新手上的 Q Table，最後精通遊戲的玩法，即為 Q Learning 的精髓所在。</p>
<h3 id="建立-Q-Table"><a href="#建立-Q-Table" class="headerlink" title="建立 Q Table"></a>建立 Q Table</h3><p>Q Table 是一個狀態 (state) 與動作 (action) 的對應表，紀錄下每個決策預期可護得的獎勵，我們的狀態是 <code>(row, column)</code> 而動作是 <code>up</code>、<code>down</code>、<code>left</code>、<code>right</code>，因此可以將 Q Table 格式定義如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先定義變量</span></span><br><span class="line">(row, column) 為 Player 所在迷宮的位置</span><br><span class="line">up    := 依過去經驗，在 (row, column) 狀態下執行 up    後，預期可護得的分數</span><br><span class="line">down  := 依過去經驗，在 (row, column) 狀態下執行 down  後，預期可護得的分數</span><br><span class="line">left  := 依過去經驗，在 (row, column) 狀態下執行 left  後，預期可護得的分數</span><br><span class="line">right := 依過去經驗，在 (row, column) 狀態下執行 right 後，預期可護得的分數</span><br><span class="line"></span><br><span class="line"><span class="comment"># Q Table 為</span></span><br><span class="line">Q(row, column) := [up, down, left, right]</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>Q Table 格式不是只能使用陣列的型式表示，只要資料結構能滿足記錄 state 和 action 的對應，都是很好的！</p>
          </div>
<p>因為剛開始 AI 對環境還不了解，每個狀態、每個動作對 AI 來說都是一樣的，因此將 Q Table 中所有的分數初始化為 0</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initQTable</span>(<span class="params">self</span>):</span><br><span class="line">    Q = np.zeros(self.maze.shape).tolist()</span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(Q):</span><br><span class="line">        <span class="keyword">for</span> j, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            Q[i][j] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] <span class="comment"># up, down, left, right</span></span><br><span class="line">    self.QTable = np.array(Q, dtype=<span class="string">&#x27;f&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="選擇動作"><a href="#選擇動作" class="headerlink" title="選擇動作"></a>選擇動作</h3><p>Q Table 代表以往決策的經驗，因此 AI 可以使用當前的狀態去查表得知應該要執行什麼動作，才有可能獲得較高的分數</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getAction</span>(<span class="params">self, eGreddy=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; eGreddy:</span><br><span class="line">        <span class="keyword">return</span> random.choice(self.actionList)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Qsa = self.QTable[self.state].tolist()</span><br><span class="line">        <span class="keyword">return</span> self.actionList[Qsa.index(<span class="built_in">max</span>(Qsa))]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eGreddy</code>：為一機率值，若 <code>random.random() &gt; eGreddy</code> 成立則不參考 Q Table，隨機選一個動作做為決策，這項機制是防止代理人進入有可能出現的無窮迴圈。</li>
</ul>
<h3 id="更新-Q-Table"><a href="#更新-Q-Table" class="headerlink" title="更新 Q Table"></a>更新 Q Table</h3><p>這裡即為 Q Learning 演算法的核心，更新 Q Table</p>
<script type="math/tex; mode=display">Q(s, a) ← Q(s, a) + \alpha[r + \gamma max_{a'}Q(s', a') - Q(s, a)]</script><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">updateQTable</span>(<span class="params">self, action, nextState, reward, lr=<span class="number">0.7</span>, gamma=<span class="number">0.9</span></span>):</span><br><span class="line">    Qs = self.QTable[self.state]</span><br><span class="line">    Qsa = Qs[self.actionDict[action]]</span><br><span class="line">    Qs[self.actionDict[action]] = (<span class="number">1</span> - lr) * Qsa + lr * (reward + gamma *(self.getNextMaxQ(nextState)))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Qsa</code> 對應公式為 $Q(s, a)$</li>
<li><code>lr</code> 對應公式為 $\alpha$</li>
<li><code>reward</code> 對應公式為 $r$</li>
<li><code>gamma</code> 對應公式為 $\gamma$</li>
<li><code>getNextMaxQ(nextState)</code> 對應公式為 $max_{a&#39;}Q(s&#39;, a&#39;)$</li>
</ul>
<h2 id="代理人與遊戲環境互動"><a href="#代理人與遊戲環境互動" class="headerlink" title="代理人與遊戲環境互動"></a>代理人與遊戲環境互動</h2><p>使用 <code>while True</code> 讓代理人待在玩遊戲的迴圈內，直至到達終點 <code>if result</code>，詳細說明可參考程式內註解</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">initState = (np.where(maze==-<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>], np.where(maze==-<span class="number">1</span>)[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># Create an Agent</span></span><br><span class="line">agent = Agent(maze, initState)</span><br><span class="line"><span class="comment"># Create a game Environment</span></span><br><span class="line">environment = Environment()</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">    agent.state = initState</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Get the next step from the Agent</span></span><br><span class="line">        action = agent.getAction(<span class="number">0.9</span>)</span><br><span class="line">        <span class="comment"># Give the action to the Environment to execute</span></span><br><span class="line">        reward, nextState, result = environment.doAction(agent.state, action)</span><br><span class="line">        <span class="comment"># Update Q Table based on Environmnet&#x27;s response</span></span><br><span class="line">        agent.updateQTable(action, nextState, reward)</span><br><span class="line">        <span class="comment"># Agent&#x27;s state changes</span></span><br><span class="line">        agent.state = nextState</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27; <span class="subst">&#123;j+<span class="number">1</span>:2d&#125;</span> : <span class="subst">&#123;i&#125;</span> steps to the goal.&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>強化學習能從無任何資訊去學出一套規則，就像人從小就會觀察這個世界給我們的回饋，不論這樣的回饋是來自父母、朋友、同學、師長、甚至是陌生人，都會對我們人生中的決策產生一定的影響。每個人手裡都握有一個 Q Table，也都正在努力更新、優化這張表、盡可能地嘗試各種不一樣的機會，都是希望能透過現在的經驗，引導未來的自己邁向心中的那個理想。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://mofanpy.com/tutorials/machine-learning/reinforcement-learning/intro-q-learning/">莫烦 - 什么是 Q Leaning</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/343668723">强化学习之迷宫Q-Learning实践笔记——入门篇</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>專案開發筆記</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>environment</tag>
        <tag>q learning</tag>
        <tag>maze</tag>
        <tag>tkinter</tag>
        <tag>reinforcement</tag>
        <tag>agent</tag>
        <tag>reward</tag>
      </tags>
  </entry>
  <entry>
    <title>全民來找碴 - YOLOv4 戴口罩檢測</title>
    <url>/2021/06/10/YOLOv4_On_Face_Mask_Detection/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>至五月以來，疫情爆發升級成三級警戒，戴口罩已成為日常生活不可或缺的一部分。然而，還是時常在新聞上看到不配合戴口罩的名眾，想成為防疫破口，為了監視這些人的行為還需要額外人力去支援。剛好，在課堂上學到如何用 CNN 網路模型來做圖片辨識，因此以時事為主題，學習為主旨來做這份期末報告。</p>
<p>我們從國際上著名的數據庫 Kaggle 平台取得想要的資料集 Face Mask Detection，裡面有853張照片、三種物件，分別為戴口罩的人頭、沒戴口罩的人頭、口罩戴的不完全的人頭。並使用 YOLOv4 (You Only Look Once) 物件辨識演算法來偵測戴口罩的人。最後的訓練成效 mAP 為 79%，同時為了能公開讓大家一同使用，將結果透過 Line 平台的 Line Bot 系統整合 YOLOv4 訓練結果，只需直接上傳圖片就可以即時得到回饋。</p>
<h2 id="此篇文章使用方法"><a href="#此篇文章使用方法" class="headerlink" title="此篇文章使用方法"></a>此篇文章使用方法</h2><ol>
<li><p>開發環境為 <code>Ubuntu 16.04 LTS</code> 桌面版本，並且每個路徑都以絕對路徑來呈現，盡量使所有路徑透明化，避免讀者混淆。因此若要照著本文提供的程式運行的話，路徑中的 <code>user</code> 需改為登入環境的帳號名稱。</p>
</li>
<li><p>作者不講清楚目錄結構常常是讀者的一個痛點，因此本文在每個段落都會顯示出目錄結構給讀者參考，建議讀者經常比對自己的目錄結構是否與本文相同，不相同的話容易出現意想不到的錯誤。</p>
</li>
</ol>
<h2 id="Kaggle"><a href="#Kaggle" class="headerlink" title="Kaggle"></a>Kaggle</h2><h3 id="Kaggle-是什麼？"><a href="#Kaggle-是什麼？" class="headerlink" title="Kaggle 是什麼？"></a>Kaggle 是什麼？</h3><p>Kaggle 是一個數據建模和數據分析競賽平台。企業和研究者可在其上發布數據，統計學者和數據可在其上進行競賽以產生最好的模型。可以分為</p>
<ol>
<li>Competitions競賽<br> Kaggle 的比賽類型按照獎勵內容可以分成3種<ol>
<li>提供獎金的 Featured 類。</li>
<li>提供實習、面試機會的 Recruitment 類。</li>
<li>純粹作為練手的 Playground 類。</li>
</ol>
</li>
<li>Datasets 數據集<br> 利用 Kaggle 的數據集，通過簡單的 <code>Dig in → Build → Connect</code> 的步驟，就可以自己挖掘、分析公共數據集的內容。<ol>
<li><code>Dig in</code>：直接在 Kaggle 上使用其提供的交互式工具來進行數據分析，支持 <strong>Python、Julia、R Markdown、SQLite</strong> 等語言，Kaggle 通過相應的 Docker 容器來編譯執行腳本。</li>
<li><code>Build</code>：網頁版工具上進行數據分析處理之後，可以發布自己的數據 insights，使用 Kaggle Kernels 來 coding。</li>
<li><code>Connect</code>：可以很方便的查看其他人公開的 Kaggle Kernels，或者在論壇中諮詢對應數據集的相關問題。</li>
</ol>
</li>
<li>Kernel 內核<ul>
<li>以前叫做 Scripts，現在改名叫 Kernels 了。Kernels 提供了數據分析所需的環境、數據集、代碼和輸出樣式（比如 Python Notebook），Kaggle 的目的是要使得 Kernels 成為數據分析的核心，他們想將 Kernels 打造為一個能實現並分享所有數據科學工作的平台，包括與本地工具的結合（Kernels 現在提供的環境庫並沒有辦法做到包羅萬象）、團隊間的私有合作空間等等。</li>
<li>之前 Datasets 里面的網頁版工具就是調用了 Kaggle 的 Kernels 平台，其一大好處就在於不需要將數據集下載在電腦，Kernels 中已經預先載入了龐大的數據集和基本的數據處理環境資料庫（甚至都不需要在本地配環境！）。這點很棒，畢竟龐大的數據要下載下來在網絡條件不允許的情況下還是相當耗費時間，在本地配好一系列的數據處理環境也不容易，Kernels 借助 Docker 鏡像解決了這一問題。（類似的數據上雲的方式開始越來越流行）</li>
</ul>
</li>
</ol>
<h3 id="Kaggle-優點"><a href="#Kaggle-優點" class="headerlink" title="Kaggle 優點"></a>Kaggle 優點</h3><ol>
<li>真實的數據：在自己學習數據分析的過程中，很多時候是苦於沒有數據，很多書或課程的數據都是無法參考，數據量小，而真實世界的數據往往都是大量，到處充滿了缺失和不足，實際的數據分析工作中。</li>
<li>真實的問題：在 Kaggle 上發布的競賽題目，一般都是企業或政府組織中真實面臨的問題。實際的數據分析工作都是從實際問題出發，選擇解決辦法的時候要考慮到各種因素，沒有絕對的對與錯，都是要根據實際問題，具體問題具體分析。</li>
<li>及時的反饋：而在 Kaggle 上，只要提交了算法結果，就可以在 Leader board 上看到自己的排名和成績，你可以不斷改進，如果一次改進可以提高排名。</li>
<li>線上的討論：每給 Kaggle 競賽題目都配有一個論壇，參賽者在賽中和賽後可以相互討論，這讓學習不再孤單，可以在討論中吸取別人的想法，也可以為他人提供指導。</li>
</ol>
<h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><h3 id="YOLO-簡介"><a href="#YOLO-簡介" class="headerlink" title="YOLO 簡介"></a>YOLO 簡介</h3><p>YOLO (You Only Look Once) 是一種影像物件辨識演算法，為 One stage 的物件偵測方法，只需使用一個 CNN 架構就能判斷圖片內的物體位置與類別。相對於此種物件偵測的是 Two stage (例如 R-CNN)，該演算法必須先偵測出物件，再對每個物件個別做 CNN 運算判斷物件類別，因此 YOLO 相較可以提升辨識速度。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FOne_stage.png?alt=media&amp;token=5604d37d-593a-4201-8d97-d3258fe3b364" alt="One Stage 示意圖"><span class="image-caption">One Stage 示意圖</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FTow_stage.png?alt=media&amp;token=ae5b0248-a0a8-4ad2-b6eb-611d157939ab" alt="Two Stage 示意圖"><span class="image-caption">Two Stage 示意圖</span></p>
<p>YOLO 作法就是將輸入的影像切割成 S*S的網格，若物體的中心若在某網格內，則該網格負責檢測該物體。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FYOLO_alg.png?alt=media&amp;token=380f2e17-6342-4bb5-b610-67345c54395e" alt="YOLO 運作原理"><span class="image-caption">YOLO 運作原理</span></p>
<p>在訓練時，每個網格會預測出 B 個 bounding boxes，每個 bounding box 對應 5 個預測結果</p>
<ol>
<li><strong>bounding box</strong> 的中心點座標$(x,y)$與寬高$(w,h)$</li>
<li><p>信心評分代表 <strong>bounding box</strong> 與 <strong>Ground Truth</strong> 的 <strong>IoU</strong> 值</p>
<script type="math/tex; mode=display">confidence=Pr(Object)\cdot IoU^{truth}_{pred}</script><p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FIoU.png?alt=media&amp;token=911ad05e-daf2-44f0-aae9-2876549e9457" alt="Intersection over Union"><span class="image-caption">Intersection over Union</span></p>
</li>
</ol>
<h3 id="Why-YOLOv4"><a href="#Why-YOLOv4" class="headerlink" title="Why YOLOv4"></a>Why YOLOv4</h3><ol>
<li>YOLOv4 在 YOLOv3 各個部分做改進，在同樣的速率(FPS)提升近 12% AP，<br> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FYOLO_performance.png?alt=media&amp;token=67391dae-9f03-4796-a2d1-c295525a897d" alt="YOLOv4 Performance"><span class="image-caption">YOLOv4 Performance</span></li>
<li>YOLOv4 貢獻有三[4]<ol>
<li>此高效有力的物件模型，使用 1080Ti 或 2080Ti 就能進行訓練。</li>
<li>驗證最新的 Bag-of-Freebies 與 Bag-of-Specials 方法在物件偵測模型訓練中的影響。</li>
<li>微調最新的的方法例如 CBN、PAN、SAM，使其在單 GPU 訓練中更有效率。</li>
</ol>
</li>
<li>YOLOv4 有共有三名作者，一名為俄羅斯人，另外兩名為台灣中研院研究員，身為台灣人當然要挺自己人研發的模型。<br> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FYOLOv4_author.png?alt=media&amp;token=4031177f-e360-4cb5-ad10-c7c0280efcca" alt="YOLOv4 Authors"><span class="image-caption">YOLOv4 Authors</span></li>
</ol>
<h3 id="YOLOv4-結構-4"><a href="#YOLOv4-結構-4" class="headerlink" title="YOLOv4 結構[4]"></a>YOLOv4 結構[4]</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FYOLOv4_structure.png?alt=media&amp;token=a9273009-ff6b-4add-a90d-7b3d25e36ec4" alt="YOLOv4 Structure"><span class="image-caption">YOLOv4 Structure</span></p>
<p>Backborn：對 ImageNet 做預訓練。</p>
<p>Neck：在head 與backborn 之間的 layers，通常用來收集不同級的特徵。</p>
<p>Head：預測類別與 bounding box。</p>
<p>YOLOv4 各部分組成如下：</p>
<ul>
<li>Backbone: CSPDarknet53 [81]</li>
<li>Neck: SPP [25], PAN [49]</li>
<li>Head: YOLOv3 [63]</li>
</ul>
<h2 id="使用-YOLOv4"><a href="#使用-YOLOv4" class="headerlink" title="使用 YOLOv4"></a>使用 YOLOv4</h2><h3 id="資料集處理"><a href="#資料集處理" class="headerlink" title="資料集處理"></a>資料集處理</h3><p>選用 Kaggle 的 <a href="https://www.kaggle.com/andrewmvd/face-mask-detection">Face Mask Detection</a> 資料集。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FFace_mask_detection_cover.png?alt=media&amp;token=0ceee8a8-25ad-4c1b-9b1a-eef877eae7dd" alt="Face Mask Detection Cover"><span class="image-caption">Face Mask Detection Cover</span></p>
<p>至該網站下載並解壓縮到 <code>kaggle_face_mask</code> 目錄下，目錄結構如下，共有 853 張照片(<code>*.png</code>)/853 標籤檔(<code>*.xml</code>)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/user/kaggle_face_mask</span><br><span class="line">├─annotations</span><br><span class="line">│ ├─maksssksksss0.xml</span><br><span class="line">│ ├─maksssksksss1.xml</span><br><span class="line">│ ├─...</span><br><span class="line">│ ├─...</span><br><span class="line">│ ├─...</span><br><span class="line">│ └─maksssksksss852.xml</span><br><span class="line">└─images</span><br><span class="line">  ├─maksssksksss0.png</span><br><span class="line">  ├─maksssksksss1.png</span><br><span class="line">  ├─...</span><br><span class="line">  ├─...</span><br><span class="line">  ├─...</span><br><span class="line">  └─maksssksksss852.png</span><br></pre></td></tr></table></figure>
<p>標籤為 PASCAL VOC 格式</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FPascal_voc_%E7%A4%BA%E6%84%8F%E5%9C%96.png?alt=media&amp;token=b8ca2c5e-825a-4dc2-bd4e-d56cd1d5a3cc" alt="PASCAL VOC 解讀示意圖"><span class="image-caption">PASCAL VOC 解讀示意圖</span></p>
<h4 id="轉換-PASCAL-VOC-格式為-YOLO-格式"><a href="#轉換-PASCAL-VOC-格式為-YOLO-格式" class="headerlink" title="轉換 PASCAL VOC 格式為 YOLO 格式"></a>轉換 PASCAL VOC 格式為 YOLO 格式</h4><p>YOLO 的標籤檔為 <code>txt</code> 檔，並與圖檔放在同一名稱放同一目錄下。格式如下，若有多個物件，就記錄多行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">classId xCenter yCenter bndBoxW bndBoxH</span><br></pre></td></tr></table></figure>
<p>以下為換算公式，其中 $w$ 與 $h$ 為圖片本身的寬與長。</p>
<script type="math/tex; mode=display">x_{center}=\frac{x_{min}+x_{max}}{2}\frac{1}{w}</script><script type="math/tex; mode=display">y_{center}=\frac{y_{min}+y_{max}}{2}\frac{1}{h}</script><script type="math/tex; mode=display">bndBoxW=\frac{x_{max}-x_{min}}{w}</script><script type="math/tex; mode=display">bndBoxH=\frac{y_{max}-y_{min}}{h}</script><p>以下舉 <code>maksssksksss0.png</code> 為範例</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FPASCAL_VOL_xml.png?alt=media&amp;token=54ecd746-96e9-4bb2-8d56-62a597be8563" alt="maksssksksss0.png 的 PASCAL VOC 標籤"><span class="image-caption">maksssksksss0.png 的 PASCAL VOC 標籤</span></p>
<p>將該 <code>VOC</code> 轉為 <code>YOLO</code> 應如下，其中定義 <code>classId=0 為 with_mask</code>、 <code>classId=1 為 without_mask</code>、<code>classId=2 為 mask_weared_incorrect</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 0.18359375 0.337431693989071 0.05859375 0.10109289617486339</span><br><span class="line">0 0.4013671875 0.3333333333333333 0.080078125 0.12021857923497267</span><br><span class="line">1 0.6689453125 0.3155737704918033 0.068359375 0.13934426229508196</span><br></pre></td></tr></table></figure>
<p>透過以下 <code>Python</code> 程式將 <code>VOC</code> 轉為 <code>YOLO</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">rootFolder = <span class="string">r&#x27;/home/user/&#x27;</span>   <span class="comment"># 修改此處符合目錄結構</span></span><br><span class="line">annotations = os.path.join(rootFolder, <span class="string">r&#x27;kaggle_face_mask/annotations&#x27;</span>)</span><br><span class="line">images = os.path.join(rootFolder, <span class="string">r&#x27;kaggle_face_mask/images&#x27;</span>)</span><br><span class="line">destination = os.path.join(rootFolder, <span class="string">r&#x27;yolo_data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(destination):</span><br><span class="line">    os.mkdir(destination)</span><br><span class="line"></span><br><span class="line">className = [<span class="string">&#x27;with_mask&#x27;</span>, <span class="string">&#x27;without_mask&#x27;</span>, <span class="string">&#x27;mask_weared_incorrect&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xmlFile <span class="keyword">in</span> os.listdir(annotations):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(annotations, xmlFile), <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> voc:</span><br><span class="line">        bsObj = BeautifulSoup(voc.read(), <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        picFilename = bsObj.select_one(<span class="string">&#x27;filename&#x27;</span>).get_text()</span><br><span class="line">        picW = bsObj.select_one(<span class="string">&#x27;size width&#x27;</span>).get_text()</span><br><span class="line">        picH = bsObj.select_one(<span class="string">&#x27;size height&#x27;</span>).get_text()</span><br><span class="line">        </span><br><span class="line">        objectAttrs = []</span><br><span class="line">        <span class="keyword">for</span> bndBox <span class="keyword">in</span> bsObj.select(<span class="string">&#x27;object&#x27;</span>):</span><br><span class="line">            name = bndBox.select_one(<span class="string">&#x27;name&#x27;</span>).get_text()</span><br><span class="line">            xmin = bndBox.select_one(<span class="string">&#x27;xmin&#x27;</span>).get_text()</span><br><span class="line">            xmax = bndBox.select_one(<span class="string">&#x27;xmax&#x27;</span>).get_text()</span><br><span class="line">            ymin = bndBox.select_one(<span class="string">&#x27;ymin&#x27;</span>).get_text()</span><br><span class="line">            ymax = bndBox.select_one(<span class="string">&#x27;ymax&#x27;</span>).get_text()</span><br><span class="line">            </span><br><span class="line">            classId = className.index(name)</span><br><span class="line">            xcenter = <span class="built_in">eval</span>(<span class="string">f&#x27;(<span class="subst">&#123;xmin&#125;</span>+<span class="subst">&#123;xmax&#125;</span>)/2/<span class="subst">&#123;picW&#125;</span>&#x27;</span>)</span><br><span class="line">            ycenter = <span class="built_in">eval</span>(<span class="string">f&#x27;(<span class="subst">&#123;ymin&#125;</span>+<span class="subst">&#123;ymax&#125;</span>)/2/<span class="subst">&#123;picH&#125;</span>&#x27;</span>)</span><br><span class="line">            bndBoxW = <span class="built_in">eval</span>(<span class="string">f&#x27;(<span class="subst">&#123;xmax&#125;</span>-<span class="subst">&#123;xmin&#125;</span>)/<span class="subst">&#123;picW&#125;</span>&#x27;</span>)</span><br><span class="line">            bndBoxH = <span class="built_in">eval</span>(<span class="string">f&#x27;(<span class="subst">&#123;ymax&#125;</span>-<span class="subst">&#123;ymin&#125;</span>)/<span class="subst">&#123;picH&#125;</span>&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            objectAttrs.append(<span class="string">f&#x27;<span class="subst">&#123;classId&#125;</span> <span class="subst">&#123;xcenter&#125;</span> <span class="subst">&#123;ycenter&#125;</span> <span class="subst">&#123;bndBoxW&#125;</span> <span class="subst">&#123;bndBoxH&#125;</span>&#x27;</span>)</span><br><span class="line">        shutil.copy(os.path.join(images, picFilename), destination)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(destination, os.path.splitext(picFilename)[<span class="number">0</span>]) + <span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> yoloTxt:</span><br><span class="line">            yoloTxt.write(<span class="string">&#x27;\n&#x27;</span>.join(objectAttrs))</span><br></pre></td></tr></table></figure>
<p>現在目錄結構為</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/home/user</span><br><span class="line">├─kaggle_face_mask</span><br><span class="line">│  ├─annotations</span><br><span class="line">│  └─images</span><br><span class="line">└─yolo_data</span><br><span class="line">  ├─maksssksksss0.png</span><br><span class="line">  ├─maksssksksss0.txt</span><br><span class="line">  ├─maksssksksss1.png</span><br><span class="line">  ├─maksssksksss1.txt</span><br><span class="line">  ├─...</span><br><span class="line">  ├─...</span><br><span class="line">  ├─maksssksksss852.png</span><br><span class="line">  └─maksssksksss852.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="分類為-training-data-與-validation-data"><a href="#分類為-training-data-與-validation-data" class="headerlink" title="分類為 training data 與 validation data"></a>分類為 training data 與 validation data</h4><p>選擇 80% 的資料量為 training data、20% 為 validation data</p>
<pre class="mermaid" style="text-align: center;">
            pie
            "Training Data" : 80
"Validation Data" : 20
          </pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">rootFolder = <span class="string">r&#x27;/home/user/&#x27;</span>   <span class="comment"># 修改此處符合目錄結構</span></span><br><span class="line">destination = os.path.join(rootFolder, <span class="string">r&#x27;yolo_data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">files = os.listdir(destination)</span><br><span class="line">numTrainingData = <span class="built_in">int</span>(<span class="built_in">len</span>(files) * <span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(rootFolder, <span class="string">&#x27;train.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files[:numTrainingData]:</span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(filename)[<span class="number">1</span>] != <span class="string">&#x27;.txt&#x27;</span>:            </span><br><span class="line">            outfile.writelines(os.path.join(destination, filename) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(rootFolder, <span class="string">&#x27;val.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files[numTrainingData:]:</span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(filename)[<span class="number">1</span>] != <span class="string">&#x27;.txt&#x27;</span>:            </span><br><span class="line">            outfile.writelines(os.path.join(destination, filename) + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>執行完上方程式後，會出現兩個檔案，<code>train.txt</code> 與 <code>val.txt</code> ，分別記錄 training data 與 validation data 的路徑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/home/user/yolo_data/maksssksksss166.png</span><br><span class="line">/home/user/yolo_data/maksssksksss536.png</span><br><span class="line">/home/user/yolo_data/maksssksksss57.png</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/home/user/yolo_data/maksssksksss17.png</span><br><span class="line">/home/user/yolo_data/maksssksksss10.png</span><br><span class="line">/home/user/yolo_data/maksssksksss490.png</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>現在的目錄結構為</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/home/user</span><br><span class="line">├─kaggle_face_mask</span><br><span class="line">│  ├─annotations</span><br><span class="line">│  └─images</span><br><span class="line">├─yolo_data</span><br><span class="line">├─train.txt</span><br><span class="line">└─val.txt</span><br></pre></td></tr></table></figure>
<h3 id="準備訓練所需設定檔"><a href="#準備訓練所需設定檔" class="headerlink" title="準備訓練所需設定檔"></a>準備訓練所需設定檔</h3><h4 id="安裝-YOLOv4"><a href="#安裝-YOLOv4" class="headerlink" title="安裝 YOLOv4"></a>安裝 YOLOv4</h4><p>先下載原始碼</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AlexeyAB/darknet</span><br></pre></td></tr></table></figure>
<p>修改 darknet 的 Makefile，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/GPU=0/GPU=1/&quot;</span> /home/user/darknet/Makefile</span><br><span class="line">sed -i <span class="string">&quot;s/CUDNN=0/CUDNN=1/&quot;</span> /home/user/darknet/Makefile</span><br><span class="line">sed -i <span class="string">&quot;s/CUDNN_HALF=0/CUDNN_HALF=1/&quot;</span> /home/user/darknet/Makefile</span><br><span class="line">sed -i <span class="string">&quot;s/OPENCV=0/OPENCV=1/&quot;</span> /home/user/darknet/Makefile</span><br></pre></td></tr></table></figure>
<p>編譯 darknet</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user/darknet</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h4 id="建立-cfg-目錄"><a href="#建立-cfg-目錄" class="headerlink" title="建立 cfg 目錄"></a>建立 cfg 目錄</h4><p>創建目錄，並且移動 <code>train.txt</code> 與 <code>val.txt</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/user/mask_detection/cfg/weights</span><br><span class="line">mv /home/user/train.txt /home/user/val.txt /home/user/mask_detection/cfg/</span><br></pre></td></tr></table></figure>
<p>在 cfg 目錄中創建以下兩個檔案，</p>
<p><code>mask.data</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">classes = 3</span><br><span class="line">train = /home/user/mask_detection/cfg/train.txt</span><br><span class="line">valid = /home/user/mask_detection/cfg/val.txt</span><br><span class="line">names = /home/user/mask_detection/cfg/mask.names</span><br><span class="line">backup = /home/user/mask_detection/cfg/weights/</span><br></pre></td></tr></table></figure>
<p><code>mask.names</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">with_mask</span><br><span class="line">without_mask</span><br><span class="line">mask_weared_incorrect</span><br></pre></td></tr></table></figure>
<ul>
<li><code>*.data</code>：記錄類別數量(<code>classes</code>)、train.txt 的位置(<code>train</code>)、val.txt 的位置(<code>valid</code>)、mask.names 檔案位置(<code>names</code>)、weights 輸出的路徑 (<code>backup</code>)。</li>
<li><code>*.names</code>：記錄各類別名稱，第一行名稱對應到 <code>classId=0</code>，以此類推。</li>
</ul>
<h4 id="複製-yolov4-tiny-custom-cfg-到-cfg-目錄下"><a href="#複製-yolov4-tiny-custom-cfg-到-cfg-目錄下" class="headerlink" title="複製 yolov4-tiny-custom.cfg 到 cfg 目錄下"></a>複製 <code>yolov4-tiny-custom.cfg</code> 到 <code>cfg</code> 目錄下</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/user/darknet/cfg/yolov4-tiny-custom.cfg /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br></pre></td></tr></table></figure>
<p>修改內容，更改<code>filters=24</code>($filters=(classes + 5) * 3$)、<code>classes=3</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;212s/255/24/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br><span class="line">sed -i <span class="string">&#x27;220s/80/3/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br><span class="line">sed -i <span class="string">&#x27;263s/255/24/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br><span class="line">sed -i <span class="string">&#x27;269s/80/3/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br></pre></td></tr></table></figure>
<p>執行以下指令，計算 `anchors</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/darknet detector calc_anchors /home/user/mask_detection/cfg/mask.data -num_of_clusters 6 -width 416 -height 416 -showpause</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anchors =   8, 15,  16, 28,  25, 42,  38, 64,  66, 99, 136,151</span><br></pre></td></tr></table></figure>
<p>修改 <code>yolov4-tiny-custom.cfg</code> 內容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;219s/10,14,  23,27,  37,58,  81,82,  135,169,  344,319/8, 15,  16, 28,  25, 42,  38, 64,  66, 99, 136,151/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br><span class="line">sed -i <span class="string">&#x27;268s/10,14,  23,27,  37,58,  81,82,  135,169,  344,319/8, 15,  16, 28,  25, 42,  38, 64,  66, 99, 136,151/&#x27;</span> /home/user/mask_detection/cfg/yolov4-tiny-obj.cfg</span><br></pre></td></tr></table></figure>
<h4 id="下載官方已經訓練好的-weights"><a href="#下載官方已經訓練好的-weights" class="headerlink" title="下載官方已經訓練好的 weights"></a>下載官方已經訓練好的 weights</h4><p>下載 <a href="https://github.com/AlexeyAB/darknet/releases/download/darknet_yolo_v4_pre/yolov4-tiny.conv.29">yolov4-tiny.conv.29</a> 後放到 <code>cfg</code> 下</p>
<p>現在的目錄結構為</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/user</span><br><span class="line">├─darknet</span><br><span class="line">├─kaggle_face_mask</span><br><span class="line">│  ├─annotations</span><br><span class="line">│  └─images</span><br><span class="line">├─mask_detection/cfg</span><br><span class="line">│  ├─mask.data</span><br><span class="line">│  ├─mask.names</span><br><span class="line">│  ├─train.txt</span><br><span class="line">│  ├─val.txt</span><br><span class="line">│  ├─yolov4-tiny-obj.cfg</span><br><span class="line">│  └─yolov4-tiny.conv.29</span><br><span class="line">└─yolo_data</span><br><span class="line">  ├─maksssksksss0.png</span><br><span class="line">  ├─maksssksksss0.txt</span><br><span class="line">  ├─maksssksksss1.png</span><br><span class="line">  ├─maksssksksss1.txt</span><br><span class="line">  ├─...</span><br><span class="line">  ├─...</span><br><span class="line">  ├─maksssksksss852.png</span><br><span class="line">  └─maksssksksss852.txt</span><br></pre></td></tr></table></figure>
<h3 id="訓練模型"><a href="#訓練模型" class="headerlink" title="訓練模型"></a>訓練模型</h3><h4 id="訓練"><a href="#訓練" class="headerlink" title="訓練"></a>訓練</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user/darknet</span><br><span class="line">./darknet detector train ../mask_detection/cfg/mask.data ../mask_detection/cfg/yolov4-tiny-obj.cfg ../mask_detection/cfg/weights/yolov4-tiny.conv.29 -map -gpus 0,1</span><br></pre></td></tr></table></figure>
<ul>
<li>darknet 指令格式：<code>darknet detector [動作] [.data] [.cfg] [weights檔] [options]</code></li>
<li>訓練的 weights 會存在 <code>/home/user/mask_detection/cfg/weights/</code></li>
<li><code>-gpus</code>：可使用多 GPU，後面數字為 GPU 代號，執行指令 <code>nvidia-smi</code> 即可查看代號。</li>
<li><code>-dont_show</code>：過程中不要展示 loss 圖片。</li>
<li><code>-map</code>：顯示 mAP。</li>
<li><p>產出的 <code>weights</code></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/user/mask_detection/cfg/weights</span><br><span class="line">├─yolov4-tiny-obj_final.weights</span><br><span class="line">├─yolov4-tiny-obj_last.weights</span><br><span class="line">├─yolov4-tiny-obj_500000.weights</span><br><span class="line">├─yolov4-tiny-obj_490000.weights</span><br><span class="line">├─yolov4-tiny-obj_480000.weights</span><br><span class="line">├─...</span><br><span class="line">├─...</span><br><span class="line">├─...</span><br><span class="line">├─yolov4-tiny-obj_20000.weights</span><br><span class="line">└─yolov4-tiny-obj_10000.weights</span><br></pre></td></tr></table></figure>
</li>
<li><p>mAP vs loss</p>
<p>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2FLossVsAcc.png?alt=media&amp;token=4369a5f0-c9e9-47b2-b122-17112f485b1c" alt="mAP vs loss"><span class="image-caption">mAP vs loss</span></p>
</li>
</ul>
<h4 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h4><ul>
<li><p>先修改 <code>cfg</code> 檔</p>
<p>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2Ftest_configure.png?alt=media&amp;token=4dcc8196-ca36-41b3-b142-518cada814fc" alt="Test configure"><span class="image-caption">Test configure</span></p>
</li>
<li><p>測試圖片</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user/darknet</span><br><span class="line">./darknet detector <span class="built_in">test</span> ../mask_detection/cfg/mask.data ../mask_detection/cfg/yolov4-tiny-obj.cfg ../mask_detection/cfg/weights/yolov4-tiny-obj_final.weights &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>  測試完會產出圖檔再 darknet 目錄下 <code>/home/user/darknet/predictions.jpg</code></p>
<p>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2Ftest1.png?alt=media&amp;token=1aa24dda-bff5-4ae2-9a66-15f4c670445e" alt="測試1"><span class="image-caption">測試1</span></p>
<p>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2Ftest2.png?alt=media&amp;token=593436ba-d866-47ac-ac27-8d3d077f4064" alt="測試2"><span class="image-caption">測試2</span></p>
</li>
<li><p>測試影片</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user/darknet</span><br><span class="line">./darknet detector demo ../mask_detection/cfg/mask.data ../mask_detection/cfg/yolov4-tiny-obj.cfg ../mask_detection/cfg/weights/yolov4-tiny-obj_final.weights &lt;video_filename&gt; -out_filename &lt;output_filename.avi&gt;</span><br></pre></td></tr></table></figure>
  <!-- markdownlint-disable MD033 -->
  <iframe width="560" height="315" src="https://www.youtube.com/embed/4qLqwfmG9Vo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

  <!-- markdownlint-restore MD033 -->
</li>
</ul>
<h2 id="Line-Bot-應用"><a href="#Line-Bot-應用" class="headerlink" title="Line Bot 應用"></a>Line Bot 應用</h2><p>上傳圖片給官方帳號，官方帳號會回覆經過 YOLOv4 的照片</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2Fline_bot_structure.png?alt=media&amp;token=ff533353-2119-4ef4-848a-1364266c356b" alt="Line Bot 運作原理"><span class="image-caption">Line Bot 運作原理</span></p>
<h3 id="Demo-影片"><a href="#Demo-影片" class="headerlink" title="Demo 影片"></a>Demo 影片</h3><!-- markdownlint-disable MD033 -->
<iframe width="560" height="315" src="https://www.youtube.com/embed/Lw8W-kNHN8Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<!-- markdownlint-restore MD033 -->
<h3 id="Line-Bot-QR-Code"><a href="#Line-Bot-QR-Code" class="headerlink" title="Line Bot QR Code"></a>Line Bot QR Code</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/YOLOv4%2Fline_bot_QRCode.png?alt=media&amp;token=7bc6c4e7-1a90-437a-919a-11d3fe04cc13" alt="Line Bot QR Code"><span class="image-caption">Line Bot QR Code</span></p>
<h3 id="將-YOLOv4-整合在應用程式中的核心程式碼"><a href="#將-YOLOv4-整合在應用程式中的核心程式碼" class="headerlink" title="將 YOLOv4 整合在應用程式中的核心程式碼"></a>將 YOLOv4 整合在應用程式中的核心程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> darknet <span class="keyword">import</span> darknet</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cfgPath = <span class="string">&quot;/home/user/yolo/yolov4-tiny-obj.cfg&quot;</span></span><br><span class="line">dataPath = <span class="string">&quot;/home/user/yolo/mask.data&quot;</span></span><br><span class="line">weightsPath = <span class="string">&quot;/home/user/yolo/yolov4-tiny-obj_final.weights&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drowBoxes</span>(<span class="params">picPath, outputPath</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        network, class_names, _ = darknet.load_network(cfgPath, dataPath, weightsPath)</span><br><span class="line">        img = darknet.load_image(<span class="built_in">str</span>.encode(picPath), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        r = darknet.detect_image(network, class_names, img)</span><br><span class="line">        colors = &#123;</span><br><span class="line">          class_names[<span class="number">0</span>]: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),</span><br><span class="line">          class_names[<span class="number">1</span>]: (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">          class_names[<span class="number">2</span>]: (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        img = cv2.imread(picPath)</span><br><span class="line">        img = darknet.draw_boxes(r, img, colors)</span><br><span class="line">        cv2.imwrite(outputPath, img)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(drowBoxes(<span class="string">&quot;/home/user/yolo/S__8183985.jpg&quot;</span>, <span class="string">&quot;/home/user/yolo/test.jpg&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol>
<li><p><a href="https://chih-sheng-huang821.medium.com/%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E4%BB%80%E9%BA%BC%E6%98%AFone-stage-%E4%BB%80%E9%BA%BC%E6%98%AFtwo-stage-%E7%89%A9%E4%BB%B6%E5%81%B5%E6%B8%AC-fc3ce505390f">深度學習-什麼是one stage，什麼是two stage 物件偵測</a></p>
</li>
<li><p><a href="https://www.itread01.com/content/1544112970.html">YOLO背景介紹</a></p>
</li>
<li><p><a href="https://codingnote.cc/zh-tw/p/183719/">YOLO v3演算法介紹</a></p>
</li>
<li><p><a href="https://arxiv.org/pdf/2004.10934.pdf">YOLOv4: Optimal Speed and Accuracy of Object Detection</a></p>
</li>
<li><p><a href="https://hackmd.io/@shaoeChen/SJXmp66KG?type=view#3-8Anchor-boxes">Anchor boxes</a></p>
</li>
<li><p><a href="https://medium.com/ching-i/yolo-c49f70241aa7">YOLOv4 訓練教學</a></p>
</li>
</ol>
<h2 id="問題排除"><a href="#問題排除" class="headerlink" title="問題排除"></a>問題排除</h2><h3 id="編譯-darknet-時可能遇到的問題"><a href="#編譯-darknet-時可能遇到的問題" class="headerlink" title="編譯 darknet 時可能遇到的問題"></a>編譯 darknet 時可能遇到的問題</h3><ol>
<li><code>/bin/sh: 1: nvcc: not found</code><br> 將 <code>Makefile</code> 的 <code>NVCC=nvcc</code> 改為 <code>NVCC=/usr/local/cuda-10.0/bin/nvcc</code>，此路徑因環境而異。</li>
</ol>
<h3 id="訓練時可能遇到的問題"><a href="#訓練時可能遇到的問題" class="headerlink" title="訓練時可能遇到的問題"></a>訓練時可能遇到的問題</h3><ol>
<li>Out of memory<br> 嘗試更改改 <code>cfg</code> 檔案中的 <code>subdivision</code>，YOLO 一次會讀取 <code>num(trainingData)/batch/subdivision</code> 份資料到記憶體中，因此若記憶體不夠，則調整 <code>subdivision</code> 試試！</li>
</ol>
<h3 id="其他問題"><a href="#其他問題" class="headerlink" title="其他問題"></a>其他問題</h3><p>歡迎留言發問交流。</p>
]]></content>
      <categories>
        <category>專案開發筆記</category>
      </categories>
      <tags>
        <tag>yolov4</tag>
        <tag>kaggle</tag>
        <tag>object detection</tag>
        <tag>mask</tag>
      </tags>
  </entry>
  <entry>
    <title>自動每日登入 iT邦幫忙 取得活動點數</title>
    <url>/2021/06/27/ithelp_auto_login/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>許多論壇都擁有活動點數制度，「iT邦幫忙」也不意外的擁有這項功能，其中有一項是每天登入可以加 2 點活動點數，但不知道是 Bug 還是故意的，竟然需要先登出再登入，有了登入的動作才會計算當天登入的活動點數，很不符合常理。</p>
<p>因此利用爬蟲技能寫了一個專案，每天到指定時間會自動完成登入動作，讓我就算沒有登入這個動作，也可以得到活動點數，雖說這個點數量不多，但就是想要抵抗這個 Bug。</p>
<p>詳細登入問題也有人提請官方修正，可參考 <a href="https://ithelp.ithome.com.tw/questions/10203315">關於IT邦登入時點數的問題</a>。</p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ul>
<li><a href="https://github.com/weirenxue/ithelp-login-script">GitHub</a></li>
<li>實際成效<br>  <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fresult.png?alt=media&amp;token=7a24e416-b438-41ef-a0fa-df95233e5083" alt="成果圖"><span class="image-caption">成果圖</span></li>
</ul>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
<li>python 3.8.5</li>
<li>beautifulsoup4 4.9.3</li>
<li>requests 2.25.1</li>
</ul>
<h2 id="環節觀察"><a href="#環節觀察" class="headerlink" title="環節觀察"></a>環節觀察</h2><p>在動手爬蟲之前，必須先觀察在登入計算活動點數時，會經過哪些步驟與所需資訊，觀察時請記得使用開發人員工具 (F12) 來查看資訊流動。</p>
<h3 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h3><p>第一步至 <a href="https://member.ithome.com.tw/login">iThome會員登入頁面</a> 任意輸入一組帳號，按下登入按鈕然後查看封包，會看到有三個欄位分別為 <code>_token</code>、<code>account</code> 還有 <code>password</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Flogin_token_field.png?alt=media&amp;token=8671a0cd-8f92-4cc9-8a54-44ca3ee4b6c0" alt="登入所需欄位"><span class="image-caption">登入所需欄位</span></p>
<p><code>account</code> 與 <code>password</code> 我們理解，但是 <code>_token</code> 的值從何而來呢？到開發人員工具的 <code>Elements</code> 頁籤搜尋 <code>_token</code>，就可以找到它所在位置，原來是在登入表單內的一個隱藏欄位 (hidden input)！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2F_token_position.png?alt=media&amp;token=da926d26-662f-4bed-8272-d40b1cf5d306" alt="_token 的位置"><span class="image-caption">_token 的位置</span></p>
<h4 id="實作登入功能"><a href="#實作登入功能" class="headerlink" title="實作登入功能"></a>實作登入功能</h4><p>知道登入需要甚麼資訊，且資訊在哪裡可以取得，就可以開始規劃要如何利用爬蟲來做登入功能。</p>
<ol>
<li>先取得 <code>_token</code> 欄位的值。</li>
<li>將 <code>_token</code>、<code>account</code> 與 <code>password</code> 一起 <code>POST</code> 到 <code>https://member.ithome.com.tw/login</code></li>
</ol>
<p>需要注意的是，這些過程中的 <code>Cookie</code> 需要被維護，也就是每個 Request 都必須是同一個 <code>Session</code>，否則 <code>_token</code> 值無效。強大的 <code>requests</code> 套件已經幫我們準備好 <code>Session</code> 物件來處理這些事情，讓我們不用手動轉移 <code>Cookie</code> 到不同的 request 之中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 從 sAccount.json 檔案讀取帳密資料</span></span><br><span class="line">s_account = json.load(<span class="built_in">open</span>(<span class="string">&quot;./sAccount.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改 User-Agent 標頭以免被阻擋</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 製作 Payload，有三個欄位分別為 _token、account 與 password</span></span><br><span class="line">loginPayload = &#123;<span class="string">&#x27;account&#x27;</span>: s_account[<span class="string">&#x27;account&#x27;</span>], <span class="string">&#x27;password&#x27;</span>: s_account[<span class="string">&#x27;password&#x27;</span>], <span class="string">&#x27;_token&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 建立一個 Session 物件幫我們維護 Coookie 的運行</span></span><br><span class="line">sess = requests.Session()</span><br><span class="line"><span class="comment"># 將 User-Agent 標頭修改為我們所給的值</span></span><br><span class="line">sess.headers.update(headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先取得 _token 值</span></span><br><span class="line">url = <span class="string">&quot;https://member.ithome.com.tw/login&quot;</span></span><br><span class="line">response = sess.get(url)</span><br><span class="line">bsObj = bs(response.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">loginToken = bsObj.find(<span class="string">&#x27;input&#x27;</span>, &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;_token&#x27;</span>&#125;).attrs[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line"><span class="comment"># 把 _token 值存到我們之前建立的 Payload 內</span></span><br><span class="line">loginPayload[<span class="string">&#x27;_token&#x27;</span>] = loginToken</span><br><span class="line"></span><br><span class="line"><span class="comment"># 對登入頁面 POST 一次，就可以順利登入囉</span></span><br><span class="line">url = <span class="string">&quot;https://member.ithome.com.tw/login&quot;</span></span><br><span class="line">response = sess.post(url, data=loginPayload)</span><br></pre></td></tr></table></figure>
<p><code>sAccount.json</code> 內容如下，只需填入對應的帳號密碼</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>到這裡，登入功能已經完成了。但假如真的去運行這個程式碼，你會發現雖然成功登入，可是並沒有取得想要的到的每日登入活動點數，這個是因為登入與取得點數的功能是分開運行的。</p>
<h3 id="每日登入活動點數"><a href="#每日登入活動點數" class="headerlink" title="每日登入活動點數"></a>每日登入活動點數</h3><p>再讓我們觀察一下取得活動點數的關鍵在哪裡。先進入 <a href="https://ithelp.ithome.com.tw/">iT邦幫忙</a>，再點擊登入按鈕，這次需要輸入正確的帳號密碼，並且觀察開發人員工具中的封包，將會看到其實在成功登入後，從 <a href="https://member.ithome.com.tw/login">會員中心</a> 跳轉回 <a href="https://ithelp.ithome.com.tw/">iT邦幫忙</a> 之前還有其他封包被傳送，可以猜測這些封包就是用來激活每日登入的條件</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Flogin_point.png?alt=media&amp;token=731a5c99-9258-49ca-b4ee-69a08b4dead5" alt="每日登入關鍵封包"><span class="image-caption">每日登入關鍵封包</span></p>
<p>也就是說當我們的爬蟲成功登入後，需要發出 <code>GET https://member.ithome.com.tw/oauth/authorize?client_id=ithelp&amp;redirect_uri=https://ithelp.ithome.com.tw/users/callback&amp;response_type=code</code> 請求，來取得這天的每日登入活動點數。</p>
<h4 id="實作取得點數功能"><a href="#實作取得點數功能" class="headerlink" title="實作取得點數功能"></a>實作取得點數功能</h4><p>這是最簡單的部分，只需要在登入之後加上下面兩行程式，就可以達到效果了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;https://member.ithome.com.tw/oauth/authorize?client_id=ithelp&amp;redirect_uri=https://ithelp.ithome.com.tw/users/callback&amp;response_type=code&quot;</span></span><br><span class="line">response = sess.get(url)</span><br></pre></td></tr></table></figure>
<p>到這裡，概念與實作講解完畢，當然除登入並取得點數外，還可以加一些功能例如確認是否真的登入或者是是否有錯誤發生的判斷。</p>
<p>可以到我的 GitHub 上參考 <a href="https://github.com/weirenxue/ithelp-login-script/blob/b693c7eb020f0498222b5bfd34be587c0338c24e/ithelp/login.py#L7-L18">完整原始碼</a>。</p>
<h2 id="每日自動登入"><a href="#每日自動登入" class="headerlink" title="每日自動登入"></a>每日自動登入</h2><p>將腳本寫好，就可以來讓它納入我的排程內啦！我使用的作業系統是 Windows 10，使用內建的排程系統就可以完成，這裡來說說如何設定排程每天自動登入</p>
<h3 id="啟動檔-bat"><a href="#啟動檔-bat" class="headerlink" title="啟動檔 bat"></a>啟動檔 bat</h3><p>要用排程之前，最好的習慣是將啟動腳本寫成 bat 檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d %~dp0</span><br><span class="line">python <span class="string">&quot;%~dp0login.py&quot;</span> &gt;&gt; <span class="string">&quot;%~dp0log.log&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>%~dp0</code>：bat 檔案所在目錄的絕對路徑。</li>
</ul>
<h3 id="創建排程"><a href="#創建排程" class="headerlink" title="創建排程"></a>創建排程</h3><p>開啟 <code>Task Schedular</code>，並建立一個排程 <code>Action -&gt; Create Task...</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fcreate_task_scheduler.png?alt=media&amp;token=e2220412-cd15-49d8-aaa2-72e2a37de2c4" alt="建立排程"><span class="image-caption">建立排程</span></p>
<p>設定排程的時間點 (每天下午 3:36) 與要執行的 bat 檔案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fschedul_schedular.png?alt=media&amp;token=d768c1c0-ba3b-4d5d-8a77-7acb7274457d" alt="設定排程"><span class="image-caption">設定排程</span></p>
<h3 id="測試排程"><a href="#測試排程" class="headerlink" title="測試排程"></a>測試排程</h3><p>設定完之後，在排程清單中找到剛剛建立的排程，<code>點擊右鍵 -&gt; Run</code> 讓它實際運作一次來當作測試，若有正常運作可以在與 bat 檔案相同目錄下找到 <code>log.log</code> 檔，若 log 無問題並有顯示登入成功，表示排程可以正常運作囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Ftest_schedular.png?alt=media&amp;token=2a35d3d6-1d93-461d-8a4a-0122493326c7" alt="測試排程與 log 檔"><span class="image-caption">測試排程與 log 檔</span></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這個是我在 <code>2021/04/08</code> 時開發的一個小專案，早在 2020 初次加入 iT邦幫忙 這個大家庭時就發現這個 Bug，雖然當時也有看到有人反應此問題，但都沒有下文，因此在較空閒時完成這個一直未了的小心願。最一開始的初衷只是想要解決這個生活小煩惱，同時以學習的態度來開發這個專案。</p>
<p>然而這個 Bug 在 <code>2021/05/12</code> 時小財神宣布已經根除 (<a href="https://ithelp.ithome.com.tw/questions/10203315">關於IT邦登入時點數的問題</a>)，真是皆大歡喜。得知這個訊息的第一個想法是這個專案好像沒有用了，但其實我們還是一樣可以繼續排程，若是哪天較忙忘記瀏覽論壇，可讓爬蟲代替我們每天取得點數。</p>
<h2 id="2022-02-22-更新"><a href="#2022-02-22-更新" class="headerlink" title="2022/02/22 更新"></a>2022/02/22 更新</h2><p>已將<a href="https://github.com/weirenxue/ithelp-login-script">專案</a>修改為能夠透過 <a href="https://github.com/features/actions">GitHub Action</a> 自動排程，因此讀者只需要直接 Fork 此專案，並添加對應的 <code>secrets</code> 環境變數，即可使用此專案的自動登入功能！接下來將補充說明如何使用 Fork 並透過 Action 排程與運行此專案。</p>
<h3 id="Fork-且執行-Workflow"><a href="#Fork-且執行-Workflow" class="headerlink" title="Fork 且執行 Workflow"></a>Fork 且執行 Workflow</h3><ol>
<li><p>在<a href="https://github.com/weirenxue/ithelp-login-script">專案</a>頁面中點擊 <code>Fork</code>，看到 <code>forked from weirenxue/ithelp-login-script</code> 即為 Fork 成功！</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Ffork_project.png?alt=media&amp;token=b6269127-446b-4016-8f53-bb3b10e51cc4" alt="Fork iThelp 自動登入專案"><span class="image-caption">Fork iThelp 自動登入專案</span></p>
</li>
<li><p>將 iThelp 帳號密碼加入 <code>secrets</code> 環境變數，變數名稱需要完全相同 (注：任何存在 <code>secrets</code> 環境變數中的數值都是加密過的，因此可以放心輸入)</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fadd_secrets.png?alt=media&amp;token=b3f627bf-618e-4fa0-8a67-f61fb3da7aae" alt="新增 Secrets 環境變數"><span class="image-caption">新增 Secrets 環境變數</span></p>
</li>
<li><p>因為此專案來源為 Fork，GitHub 預設關閉透過 Fork 而來的 Repo 其 Action 功能與 Workflow，因此需要手動啟用</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fenable_action.png?alt=media&amp;token=1de90567-ddf0-48b6-94de-ed50807e0ef0" alt="啟用 GitHub Action"><span class="image-caption">啟用 GitHub Action</span></p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fenable_workflow.png?alt=media&amp;token=d1f5e1d8-78ac-4a10-b84d-6d587e25ddad" alt="啟用 Workflow"><span class="image-caption">啟用 Workflow</span></p>
</li>
<li><p>最後只需要手動執行 Workflow 即可測試是否能正常地自動登入 iThelp 論壇</p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fmanually_run_workflow.png?alt=media&amp;token=69136407-2c32-4932-8bba-75f6a96350c0" alt="手動啟動 Workflow"><span class="image-caption">手動啟動 Workflow</span></p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Fworkflow_success.png?alt=media&amp;token=85deb4e7-e5b1-4dba-8464-b6895870668a" alt="Workflow 執行完成"><span class="image-caption">Workflow 執行完成</span></p>
<p> <img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%87%AA%E5%8B%95%E6%AF%8F%E6%97%A5%E7%99%BB%E5%85%A5-iT%E9%82%A6%E5%B9%AB%E5%BF%99-%E5%8F%96%E5%BE%97%E6%B4%BB%E5%8B%95%E9%BB%9E%E6%95%B8%2Flogin_successful.png?alt=media&amp;token=2e773e5c-41d4-48bb-9d17-ab115075b8b3" alt="確認自動登入成功"><span class="image-caption">確認自動登入成功</span></p>
</li>
</ol>
<h3 id="排程-Workflow"><a href="#排程-Workflow" class="headerlink" title="排程 Workflow"></a>排程 Workflow</h3><p>Workflow 可以透過 <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">GitHub Action schedule</a> 來描述何時該執行，即排程的做法。當指定的時間到來，則可以直接在 GitHub 上運行，不用額外開機器去執行，非常方便！</p>
<p>目前專案的排程設定可以在 <code>.github/workflows/main.yml</code> 中找到，預設為每日的 12 點執行此 Workflow</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">schedule:</span><br><span class="line">  - cron: <span class="string">&quot;0 12 * * *&quot;</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>這裡指的是 UTC+0 的時間，所以 GitHub Action 12 點 (UTC+0) 對應到台灣時間為晚上 8 點 (UTC+8)。</p>
          </div>
<p>若讀者想要自定義排程時間，這裡提供相對應的時間說明供讀者參考，讀者可以在 Fork 後的專案自行更改！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">┌───────────── minute (0 - 59)</span><br><span class="line">│ ┌───────────── hour (0 - 23)</span><br><span class="line">│ │ ┌───────────── day of the month (1 - 31)</span><br><span class="line">│ │ │ ┌───────────── month (1 - 12 or JAN-DEC)</span><br><span class="line">│ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT)</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ │</span><br><span class="line">│ │ │ │ │</span><br><span class="line">* * * * *</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>專案開發筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>github</tag>
        <tag>action</tag>
        <tag>ithelp</tag>
        <tag>login</tag>
        <tag>auto</tag>
        <tag>credit</tag>
        <tag>crawl</tag>
        <tag>task</tag>
        <tag>schedular</tag>
        <tag>schedule</tag>
        <tag>cron</tag>
        <tag>workflow</tag>
        <tag>secrets</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>讀 Paper 懶人器</title>
    <url>/2021/06/14/read_paper_lazier/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Paper 通常以英文流通最為廣泛，在閱讀時總是會搭配 google translate 查找不懂的語句或單字，但在複製整個語句或整段原文時，不應該存在的換行也會被複製進來。導致在輸入進 google translate 翻譯之前需要手動去掉換行。剛開始可能會覺得還好，但用到後來會發現這是非常浪費時間與惱人的事。</p>
<p>除此之外，有時候翻譯出來的中文慣用語會是中國大陸的慣用語，而不是台灣的慣用語，例如：server 在台灣會翻為「伺服器」而非「服務器」、macro 在台灣會翻為「巨集」而非「宏」。</p>
<p>因此我開發一個應用程式，為了解決這些困擾之處，其功能為當我們複製某段文章時，可以自動去掉換行，並且進行翻譯、替換某些自訂文字，再使用 <code>Ctrl-V</code> 貼上時，已經是翻譯與替換後的結果！絕對是碩士、博士們讀 Paper 的一個利器。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fdemo_cover.png?alt=media&amp;token=e650fd4d-4bd0-43e7-bc1c-e14ac3840132" alt="應用程式畫面展示"><span class="image-caption">應用程式畫面展示</span></p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><ul>
<li><a href="https://youtu.be/aHq7Z5r3jDs">此專案介紹影片</a></li>
<li><a href="https://github.com/weirenxue/read-paper-lazier">GitHub</a></li>
<li><a href="https://www.youtube.com/watch?v=vX0utNYPfGs">使用教學影片</a></li>
</ul>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>python 3.8.5</li>
<li>pip 21.1.2</li>
<li>google-cloud-translate 3.2.0</li>
<li>pyperclip 1.8.2</li>
</ul>
<h2 id="概念流程圖"><a href="#概念流程圖" class="headerlink" title="概念流程圖"></a>概念流程圖</h2><p>寫程式之前紙上談兵是一個好習慣，先將流程圖畫下來，思考整個過程是否具有邏輯錯誤，一改再改，最後成為定案。下圖即為此專案的主功能流程圖，我們主要需要做的事情與順序為</p>
<ol>
<li>監聽 Copy 事件</li>
<li>得到剪貼板中的文字</li>
<li>去掉所有換行字元</li>
<li>將其翻譯成中文</li>
<li>翻譯後的文字替換特定文字</li>
<li>輸出最後文字至剪貼板</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fmainfunction.png?alt=media&amp;token=c0dddc3b-e058-499e-b66d-e9f411086965" alt="主功能流程圖"><span class="image-caption">主功能流程圖</span></p>
<h2 id="各個擊破"><a href="#各個擊破" class="headerlink" title="各個擊破"></a>各個擊破</h2><h3 id="監聽-Copy-事件"><a href="#監聽-Copy-事件" class="headerlink" title="監聽 Copy 事件"></a>監聽 Copy 事件</h3><p>在 <code>Python</code> 之中內沒有內建可以監聽 Copy 事件發生的函數，因此只能自己造輪子，我採用的方法是，比對現在剪貼板中的值與上一個狀態的值是否相同，若不同代表 Copy 事件發生</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hook</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.run = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copyHook</span>(<span class="params">self, callback</span>):</span><br><span class="line">        self.run = <span class="literal">True</span></span><br><span class="line">        self.runHook(<span class="keyword">lambda</span> : self._copyHook(callback))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_copyHook</span>(<span class="params">self, callback</span>):</span><br><span class="line">        <span class="comment"># 清除剪貼板</span></span><br><span class="line">        copiedText = <span class="string">&quot;&quot;</span></span><br><span class="line">        pyperclip.copy(copiedText)</span><br><span class="line">        <span class="keyword">while</span> self.run:</span><br><span class="line">            <span class="comment"># 複製事件是否發生</span></span><br><span class="line">            tmp_value = pyperclip.paste()</span><br><span class="line">            <span class="keyword">if</span> tmp_value != copiedText <span class="keyword">and</span> tmp_value != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                <span class="comment"># 複製事件發生，對剪貼板中的文字進行處理</span></span><br><span class="line">                copiedText = callback(tmp_value)</span><br><span class="line">                <span class="comment"># 將處理後的文字輸出至剪貼板</span></span><br><span class="line">                pyperclip.copy(copiedText)</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runHook</span>(<span class="params">self, functionHandle</span>):</span><br><span class="line">        t = threading.Thread(target=functionHandle)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        self.run = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyHookCallback</span>(<span class="params">copiedText</span>):</span><br><span class="line">    <span class="built_in">print</span>(copiedText)</span><br><span class="line">    <span class="keyword">return</span> copiedText</span><br><span class="line"></span><br><span class="line">h = Hook()</span><br><span class="line">h.copyHook(copyHookCallback)</span><br></pre></td></tr></table></figure>
<p>執行後，任意複製文字，都會原封不動地輸出在 Console 底下，由此可以確認監聽 Copy 事件功能已經完備。</p>
<h4 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h4><p>這裡使用了一個小技巧，可以將一個 <code>Callback Function</code> 當作參數傳給 <code>Hook.copyHook</code>，當 Copy 事件發生時，會呼叫該函數並把剪貼板的文字傳入，在函數內可以對文字做任何想做的事，最後回傳想要輸出在剪貼板的文字。</p>
<p>這裡實際應用該函數來達到我們想要的效果，也就是去除換行、翻譯為中文、替換文字。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cancelCRLF</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translation</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replaceText</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyHookCallback</span>(<span class="params">copiedText</span>):</span><br><span class="line">    <span class="comment"># 去除換行</span></span><br><span class="line">    noCRLF = cancelCRLF(copiedText)</span><br><span class="line">    <span class="comment"># 翻譯成中文</span></span><br><span class="line">    translated = translation(noCRLF)</span><br><span class="line">    <span class="comment"># 替換特定文字</span></span><br><span class="line">    replaced = replaceText(translated)</span><br><span class="line">    <span class="keyword">return</span> replaced</span><br></pre></td></tr></table></figure>
<h3 id="去除換行"><a href="#去除換行" class="headerlink" title="去除換行"></a>去除換行</h3><p>這功能相對簡單，因為只需要將 <code>\r</code>、<code>\r\n</code>、<code>\n</code> 等去掉即可，剛好 Python 有一個內建的函式 <code>splitlines</code> 可以協助我們去除換行符號</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cancelCRLF</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(text.splitlines())</span><br></pre></td></tr></table></figure>
<h3 id="翻譯為中文"><a href="#翻譯為中文" class="headerlink" title="翻譯為中文"></a>翻譯為中文</h3><p>在翻譯為中文這裡可以有兩種做法</p>
<ol>
<li>使用 <code>selenium</code> 開啟 <a href="https://translate.google.com/?hl=zh-TW">Google Translate</a>，將文字貼進左邊的原文窗格內，等待翻譯好之後再從右邊翻譯窗格拿到翻譯後的結果。但這樣的缺點是使用者需要另外下載 <code>selenium driver</code>。</li>
<li>使用 Google Cloud Translate API 服務，以 API 的方式來做整合，較不會有環境問題，因此我採用這種作法。</li>
</ol>
<h4 id="Google-Cloud-Translate-API"><a href="#Google-Cloud-Translate-API" class="headerlink" title="Google Cloud Translate API"></a>Google Cloud Translate API</h4><p>想要使用這項服務，需先申請 GCP (Google Cloud Platform) 帳號，再依照下方步驟來取得 API Key</p>
<p>啟用 Google Cloud Translation API</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fenable_translation_api.png?alt=media&amp;token=6ccd3502-bb96-404a-a002-96ae3bb6edf2" alt="啟用 Google Cloud Translation API 步驟"><span class="image-caption">啟用 Google Cloud Translation API 步驟</span></p>
<p>啟用之後需要幾個步驟取得 API Key</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fcreate_credentials.png?alt=media&amp;token=b6e3cbb9-f26a-444c-9b70-2111cc81588e" alt="建立 Credential"><span class="image-caption">建立 Credential</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Ffill_form.png?alt=media&amp;token=74357faf-00b5-441d-8d4b-033b084e1226" alt="填寫表單資訊"><span class="image-caption">填寫表單資訊</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fmanage_api_key.png?alt=media&amp;token=af719d95-8285-4b3a-9551-885db206cf26" alt="進入管理金鑰介面"><span class="image-caption">進入管理金鑰介面</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E8%AE%80-Paper-%E6%87%B6%E4%BA%BA%E5%99%A8%2Fsave_api_key.png?alt=media&amp;token=2fb2c867-bd64-479d-95a6-f96382add50e" alt="儲存 API Key"><span class="image-caption">儲存 API Key</span></p>
<h4 id="Translate-API-使用"><a href="#Translate-API-使用" class="headerlink" title="Translate API 使用"></a>Translate API 使用</h4><p>費勁千辛萬苦申請到 API Key 之後就可以馬上整合到應用程式裡啦！其中 <code>apiKeyJson</code> 是 API Key 的絕對路徑</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google.cloud <span class="keyword">import</span> translate_v2 <span class="keyword">as</span> translate</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translation</span>(<span class="params">text</span>):</span><br><span class="line">    translate_client = translate.Client.from_service_account_json(apiKeyJson)</span><br><span class="line">    target = <span class="string">&#x27;zh-TW&#x27;</span> <span class="comment"># 翻譯為中文</span></span><br><span class="line">    translation = translate_client.translate(text, target_language=target)</span><br><span class="line">    <span class="keyword">return</span> translation[<span class="string">&#x27;translatedText&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="替換文字"><a href="#替換文字" class="headerlink" title="替換文字"></a>替換文字</h3><p>替換文字很簡單，只需把介面中 <code>Regex Entry</code> 與對應的 <code>Replace With Entry</code> 一一替換即可，<code>replaceMap</code> 儲存了所有對應 <code>[&#123;&#39;regexEntry&#39;: tk.Entry(), &#39;replaceWithEntry&#39;: tk.Entry()&#125;, ...]</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replaceText</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> replaceMap:</span><br><span class="line">        regex = element[<span class="string">&#x27;regexEntry&#x27;</span>].get()</span><br><span class="line">        replaceWith = element[<span class="string">&#x27;replaceWithEntry&#x27;</span>].get()</span><br><span class="line">        <span class="keyword">if</span> regex == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        text = re.sub(regex, replaceWith, text)</span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>到目前為止，功能基本上都已經實現，剩下的只有 GUI 呈現的部份，這部分不在此篇文章強調的重點內，可以直接參考 <a href="https://github.com/weirenxue/read-paper-lazier">GitHub</a>。最後附上使用影片教大家如何秒變懶人</p>
<!-- markdownlint-disable MD033 -->
<iframe width="560" height="315" src="https://www.youtube.com/embed/vX0utNYPfGs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<!-- markdownlint-restore MD033 -->
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/14685999/trigger-an-event-when-clipboard-content-changes">Trigger an event when clipboard content changes</a></p>
</li>
<li><p><a href="https://www.appcoda.com.tw/google-translation-api/">利用 Google Translation API 添加即時翻譯功能　讓你的 App 更加升級！</a></p>
</li>
<li><p><a href="https://moon-half.info/p/3332">使用 Google Cloud Translate API</a></p>
</li>
<li><p><a href="https://cloud.google.com/docs/authentication/production#passing_code">Authenticating as a service account</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>專案開發筆記</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>api</tag>
        <tag>paper</tag>
        <tag>lazier</tag>
        <tag>google</tag>
        <tag>cloud</tag>
        <tag>translate</tag>
        <tag>copy</tag>
        <tag>listener</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title>[FTP] CentOS 7 安裝 vsftpd 省去實體與虛擬機之間傳輸設定</title>
    <url>/2021/06/19/ftp_centos_vsftpd/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發時免不了會使用到虛擬機的可能性，而在虛擬機與主機之間做檔案轉移時總會遇到奇奇怪怪的問題，先不論是否是虛擬機的問題，但總是會再這無關緊要的問題上浪費掉許多寶貴時間，因此研究如何架設 FTP，讓主機直接上傳檔案到 FTP 伺服器，再從虛擬機中下載，避免檔案轉移遇到的麻煩！</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 7.9</li>
</ul>
<h2 id="安裝-vsftpd"><a href="#安裝-vsftpd" class="headerlink" title="安裝 vsftpd"></a>安裝 vsftpd</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo yum install -y vsftpd</span><br></pre></td></tr></table></figure>
<p>修改設定檔 (<code>/etc/vsftpd/vsftpd.conf</code>)，因為目標只是要讓 VM 可以讀取我們 Host 想傳的檔案，因此只需要將 FTP server 掛在區域網路內，這樣匿名登入是可以接受的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改以下設定值</span></span><br><span class="line">anonymous_enable=YES    <span class="comment"># 允許匿名登入</span></span><br><span class="line">local_enable=NO         <span class="comment"># 不允許實體使用者登入</span></span><br><span class="line">write_enable=YES        <span class="comment"># 可寫入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增以下設定值</span></span><br><span class="line">pasv_enable=YES     <span class="comment"># 使用被動式連線，避免客戶端還需另外設定防火牆</span></span><br><span class="line">pasv_min_port=60101 <span class="comment"># 被動式連線的 FTP Data Port 設定為 60101 ~ 60110</span></span><br><span class="line">pasv_max_port=60110</span><br><span class="line"></span><br><span class="line">no_anon_password=YES        <span class="comment"># 匿名使用者不用輸入密碼</span></span><br><span class="line"></span><br><span class="line">anon_other_write_enable=YES <span class="comment"># 匿名使用者權限設定</span></span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line"></span><br><span class="line">anon_umask=022      <span class="comment"># 匿名使用者上傳的檔案的預設權限</span></span><br><span class="line">                    <span class="comment"># user 與 other 需有 r 權限才可以被匿名使用者下載</span></span><br><span class="line">                    <span class="comment"># 此設定值預設為 077</span></span><br></pre></td></tr></table></figure>
<p>啟用 vsftpd</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> vsftpd</span><br><span class="line">[user@localhost ~]$ sudo systemctl start vsftpd</span><br></pre></td></tr></table></figure>
<h2 id="設定防火牆"><a href="#設定防火牆" class="headerlink" title="設定防火牆"></a>設定防火牆</h2><p>在 CentOS 中幾乎所有的 Port 預設對外服務都是關閉的，無法由外部連入，因此需要另外設定才能開放給其他主機連線，FTP 有兩種 Port 需要設定</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo firewall-cmd --permanent --add-port=21/tcp           <span class="comment"># Command Port</span></span><br><span class="line">[user@localhost ~]$ sudo firewall-cmd --permanent --add-port=60101-60110/tcp  <span class="comment"># Data Port</span></span><br><span class="line">[user@localhost ~]$ sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h2 id="設定-SELinux"><a href="#設定-SELinux" class="headerlink" title="設定 SELinux"></a>設定 SELinux</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo setsebool -P ftpd_connect_all_unreserved=1 <span class="comment"># 設定這個才能使用 ls/dir 指令，否則出現 425 錯誤</span></span><br><span class="line">[user@localhost ~]$ sudo setsebool -P ftpd_full_access=1 <span class="comment"># 設定這個才能上傳、修改檔名、刪除</span></span><br></pre></td></tr></table></figure>
<h2 id="創建目錄"><a href="#創建目錄" class="headerlink" title="創建目錄"></a>創建目錄</h2><p>以 <code>anonymous</code> 登入後是以 ftp 角色進行操作的，因此需另外創建匿名使用者可以上傳與下載檔案的目錄</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo <span class="built_in">mkdir</span> /var/ftp/upload_anonymous</span><br><span class="line">[user@localhost ~]$ sudo <span class="built_in">chown</span> ftp:ftp /var/ftp/upload_anonymous/</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此萬事俱全，可以開始使用 ftp 了，匿名使用者被限制只能在 <code>upload_anonymous</code> 目錄中上傳或下載檔案！</p>
]]></content>
      <categories>
        <category>伺服器架設筆記</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>file</tag>
        <tag>copy</tag>
        <tag>7.9</tag>
        <tag>vsftpd</tag>
        <tag>ftp</tag>
        <tag>425</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>[MQTT] CentOS 7 安裝 Mosquitto 並使用帳密驗證</title>
    <url>/2021/06/19/mqtt_centos_7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 IoT 領域第一個碰到的傳輸協定應該會是 http，再深入一點則是 MQTT，MQTT 是一個非常輕便的傳輸協定，沒有像是 http header 的東西，可以節省相當的流量！實現 MQTT 傳輸協定最有名的軟體應該莫過於 Mosquitto，網路上有許多 Mosquitto 的說明，這裡只紀錄如何架設與測試。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 7.9</li>
</ul>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>Mosquitto 預設是不在安裝套件內的，因此需要先安裝 Extra Packages for Enterprise Linux (EPEL)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo yum install -y epel-release</span><br></pre></td></tr></table></figure>
<p>安裝 Mosquitto 並啟動服務</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo yum install -y mosquitto</span><br><span class="line">[user@localhost ~]$ sudo systemctl <span class="built_in">enable</span> mosquitto   <span class="comment"># 讓 Mosquitto 重開機會自動啟動</span></span><br><span class="line">[user@localhost ~]$ sudo systemctl start mosquitto    <span class="comment"># 現在馬上啟動 Mosquitto</span></span><br></pre></td></tr></table></figure>
<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>開啟一個新的 Terminal (在此稱 tty1)，輸入指令來訂閱主題</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mosquitto_sub -h localhost -t Try/MQTT/CentOS7</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mosquitto_sub</code>：訂閱主題。</li>
<li><code>-h</code>：指定 MQTT Broker 的 IP 或 FQDN。</li>
<li><code>-t</code>：指定訂閱的主題名稱。</li>
</ul>
<p>開啟另一個新的 Terminal (在此稱 tty2)，輸入指令來發布主題</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mosquitto_pub -h localhost -t Try/MQTT/CentOS7 -m <span class="string">&quot;Test Message&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>mosquitto_pub</code>：發布主題。</li>
<li><code>-h</code>：指定 MQTT Broker 的 IP 或 FQDN。</li>
<li><code>-t</code>：指定發布的主題。</li>
<li><code>-m</code>：發布的訊息。</li>
</ul>
<p>這時在 tty1 應該就能看到 <code>Test Message</code> 的訊息，此時代表 Mosquitto 安裝完成且可以正常運行！測試完畢後，可以關閉 tty1 與 tty2。</p>
<h2 id="建立使用者帳號"><a href="#建立使用者帳號" class="headerlink" title="建立使用者帳號"></a>建立使用者帳號</h2><p>創建帳號</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo mosquitto_passwd -c /etc/mosquitto/passwd test_account</span><br><span class="line">Password:           <span class="comment"># 輸入 test_account 的密碼</span></span><br><span class="line">Reenter password:   <span class="comment"># 再次輸入 test_account 的密碼</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：執行指令的同時建立一個帳密檔。</li>
<li><code>/etc/mosquitto/passwd</code>：為帳密檔位置。</li>
<li><code>test_account</code>：為所要新增的帳號，可以自行更改。</li>
</ul>
<p>修改 Mosquitto 設定檔 (<code>/etc/mosquitto/mosquitto.conf</code>)，加入以下兩行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">allow_anonymous <span class="literal">false</span>               <span class="comment"># 不可匿名登入，一定要輸入帳密</span></span><br><span class="line">password_file /etc/mosquitto/passwd <span class="comment"># 讓 Mosquitto 知道帳密檔在哪裡</span></span><br></pre></td></tr></table></figure>
<p>重啟 Mosquitto 服務</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo systemctl restart mosquitto</span><br></pre></td></tr></table></figure>
<h3 id="使用者帳號測試"><a href="#使用者帳號測試" class="headerlink" title="使用者帳號測試"></a>使用者帳號測試</h3><p>開啟一個新的 Terminal (在此稱 tty1)，使用指令來訂閱主題。但由於我們已經設定為不可匿名登入，可以預想到的是會無法正常運作，因為沒有授權 (也就是沒有輸入帳號)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mosquitto_sub -h localhost -t Try/MQTT/CentOS7</span><br><span class="line">Connection error: Connection Refused: not authorised.</span><br></pre></td></tr></table></figure>
<p>tty1 中的指令更改如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mosquitto_sub -h localhost -t Try/MQTT/CentOS7 -u test_account -P 1234</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>：指定使用者帳號。</li>
<li><code>-P</code>：指定密碼，注意是大寫 P。</li>
</ul>
<p>開啟另一個新的 Terminal (在此稱 tty2)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ mosquitto_pub -h localhost -t Try/MQTT/CentOS7 -m <span class="string">&quot;Test Message&quot;</span> -u test_account -P 1234 </span><br></pre></td></tr></table></figure>
<p>這時在 tty1 應該就能看到 <code>Test Message</code> 的訊息，此時代表帳號密碼機制設定完成並且有正常運作！</p>
<h2 id="設定防火牆"><a href="#設定防火牆" class="headerlink" title="設定防火牆"></a>設定防火牆</h2><p>在 CentOS 中幾乎所有的 Port 預設對外服務都是關閉的，無法由外部連入，因此需要另外設定才能開放給其他主機連線，MQTT 預設的 Port 為 1883</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo firewall-cmd --permanent --add-port=1883/tcp</span><br><span class="line">success</span><br><span class="line">[user@localhost ~]$ sudo firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>伺服器架設筆記</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>firewall</tag>
        <tag>user</tag>
        <tag>7.9</tag>
        <tag>mqtt</tag>
        <tag>mosquitto</tag>
        <tag>authorise</tag>
        <tag>account</tag>
      </tags>
  </entry>
  <entry>
    <title>[MQTT] Mosquitto Docker 架設與設定詳細過程</title>
    <url>/2021/07/01/mqtt_mosquitto_docker/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2021/06/19/mqtt_centos_7/">[MQTT] CentOS 7 安裝 Mosquitto 並使用帳密驗證</a> 一文已經介紹如何從 yum 開始一步步地架設 MQTT Broker。這次，我想使用 Docker 來架設 Mosquitto，同時運行 MQTT/MQTTS/WS/WSS 四種通訊協定，順便練習 Docker 的使用方法。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 20.04 LTS</li>
<li>Docker 20.10.2</li>
</ul>
<h2 id="下載官方映像檔"><a href="#下載官方映像檔" class="headerlink" title="下載官方映像檔"></a>下載官方映像檔</h2><p>搜尋官方建立的 mqtt Image 並下載</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker search mqtt -f is-official=<span class="literal">true</span>  <span class="comment"># 搜尋 Image</span></span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL         AUTOMATED</span><br><span class="line">eclipse-mosquitto   Eclipse Mosquitto is an open <span class="built_in">source</span> message …   767                 [OK]</span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo docker pull eclipse-mosquitto   <span class="comment"># 下載指定 Image</span></span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo docker images   <span class="comment"># 列出所有已下載的 Images</span></span><br><span class="line">REPOSITORY          TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">eclipse-mosquitto   latest    7593d452cd8c   2 weeks ago   9.95MB</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-f is-official=true</code>：指定過濾出官方提供的 Image。</li>
</ul>
<h2 id="建立所需目錄與檔案"><a href="#建立所需目錄與檔案" class="headerlink" title="建立所需目錄與檔案"></a>建立所需目錄與檔案</h2><p>Container 關閉之後不會把關閉之前的數據與狀態存下來，恢復到與剛下載好的 Image 一樣乾淨 (其實根本就是一樣的東西啦)，因此在使用 Container 之前，需要先創立一些目錄與檔案，來存放我們想永久儲存的資料與設定</p>
<h3 id="建立目錄"><a href="#建立目錄" class="headerlink" title="建立目錄"></a>建立目錄</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo <span class="built_in">mkdir</span> -p /mosquitto/config  <span class="comment"># 存放設定檔的目錄</span></span><br><span class="line">user@pc:~$ sudo <span class="built_in">mkdir</span> -p /mosquitto/data    <span class="comment"># 存放數據檔的目錄</span></span><br><span class="line">user@pc:~$ sudo <span class="built_in">mkdir</span> -p /mosquitto/log     <span class="comment"># 存放日誌檔的目錄</span></span><br></pre></td></tr></table></figure>
<h3 id="建立檔案"><a href="#建立檔案" class="headerlink" title="建立檔案"></a>建立檔案</h3><p><a href="https://github.com/eclipse/mosquitto/blob/v1.4.10/mosquitto.conf#L262">/mosquitto/config/mosquitto.conf</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line"></span><br><span class="line">allow_anonymous <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">listener 1883</span><br><span class="line">protocol mqtt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>persistence</code>：<code>true</code> 為開啟資料存放在地端，讓通訊更穩定。可參考詳細說明 <a href="https://pagefault.blog/2020/02/05/how-to-set-up-persistent-storage-for-mosquitto-mqtt-broker/">How to set up persistent storage for Mosquitto MQTT broker</a> 。</li>
<li><code>persistence_location</code>：指定資料存放於 <code>/mosquitto/data/</code> 目錄下。</li>
<li><code>log_dest file</code>：Log 會被寫到 <code>/mosquitto/log/mosquitto.log</code> 檔案內。</li>
<li><code>allow_anonymous</code>：在 <a href="https://mosquitto.org/documentation/migrating-to-2-0/">Mosquitto 2.0</a> 之後預設不允許匿名使用者登入，因此要設定此選項為 <code>true</code> 才可匿名登入。</li>
<li><code>listener</code>：掛載服務於 1883 Port。</li>
<li><code>protocol</code>：1883 Port 的服務為 MQTT。</li>
</ul>
<h2 id="運行-MQTT-Container"><a href="#運行-MQTT-Container" class="headerlink" title="運行 MQTT Container"></a>運行 MQTT Container</h2><h3 id="啟動-Container"><a href="#啟動-Container" class="headerlink" title="啟動 Container"></a>啟動 Container</h3><p>啟動 eclipse-mosquitto 的 Image，並查看運行中的 Container 確定有正常運作 (<code>STATUS</code> 沒有異常訊息)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker run -d --name mqtt -p 1883:1883 \</span><br><span class="line">                        -v /mosquitto:/mosquitto -v /mosquitto/data:/mosquitto/data \</span><br><span class="line">                        -v /mosquitto/log:/mosquitto/log eclipse-mosquitto</span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE               COMMAND                  CREATED         STATUS         PORTS                    NAMES</span><br><span class="line">76612c251fa2   eclipse-mosquitto   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   5 minutes ago   Up 2 minutes   0.0.0.0:1883-&gt;1883/tcp   mqtt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：啟動後於後台工作。</li>
<li><code>--name</code>：幫此 Container 取名為 <code>mqtt</code></li>
<li><code>p</code>：Port 映射 <code>host port:container port</code>。</li>
<li><code>v</code>：Volumn 映射 <code>host directory:contrainer directory</code>。</li>
</ul>
<div class="note info">
            <p>到目前為止，初步的設定已經完成，並已讓 Mosquitto Container 運行起來，且沒有出現錯誤訊息。</p>
          </div>
<h3 id="測試-MQTT-Broker"><a href="#測試-MQTT-Broker" class="headerlink" title="測試 MQTT Broker"></a>測試 MQTT Broker</h3><p>若要測試 Broker 功能是否正常，要使用到 <code>mosquitto_sub</code> 與 <code>mosquitto_pub</code> 兩個指令，因此需先安裝 <code>mosquitto-clients</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install mosquitto-clients</span><br></pre></td></tr></table></figure>
<p>開啟一個新的 Terminal (在此稱 tty1)，輸入指令來訂閱主題</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_sub -h localhost -t Try/MQTT/Docker</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mosquitto_sub</code>：訂閱主題。</li>
<li><code>-h</code>：指定 MQTT Broker 的 IP 或 FQDN，此為 <code>localhost</code>。</li>
<li><code>-t</code>：指定訂閱的主題名稱，此為 <code>Try/MQTT/Docker</code>。</li>
</ul>
<p>開啟另一個新的 Terminal (在此稱 tty2)，輸入指令來發布主題</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_pub -h localhost -t Try/MQTT/Docker -m <span class="string">&quot;Test Message&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>mosquitto_pub</code>：發布主題。</li>
<li><code>-h</code>：指定 MQTT Broker 的 IP 或 FQDN，此為 <code>localhost</code>。</li>
<li><code>-t</code>：指定發布的主題，此為 <code>Try/MQTT/Docker</code>。</li>
<li><code>-m</code>：發布的訊息，此為 <code>Test Message</code>。</li>
</ul>
<div class="note info">
            <p>這時在 tty1 應該就能看到 <code>Test Message</code> 的訊息，代表 Mosquitto Container 運行正常且 MQTT Broker 功能可以使用！</p>
          </div>
<h2 id="使用帳密檔"><a href="#使用帳密檔" class="headerlink" title="使用帳密檔"></a>使用帳密檔</h2><h3 id="建立帳密檔"><a href="#建立帳密檔" class="headerlink" title="建立帳密檔"></a>建立帳密檔</h3><p>建立帳密檔需使用到 <a href="https://mosquitto.org/man/mosquitto_passwd-1.html">mosquitto_passwd</a> 指令，因此需先安裝 <code>mosquitto</code>，安裝結束時可能會看到錯誤訊息，這錯誤是因為當 <code>mosquitto</code> 安裝好後預設會自動啟動服務且 Port 為 1883，與我們的 Docker 相衝突，因此不需理會。除此之外，這裡我們只是要拿包含在 <code>mosquitto</code> 的 <code>mosquitto_passwd</code> 指令來使用，所以必須將 <code>mosquitto</code> 的服務關閉，避免占用我們 Docker 要使用的 Port</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install mosquitto</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Job <span class="keyword">for</span> mosquitto.service failed because the control process exited with error code.</span><br><span class="line">See <span class="string">&quot;systemctl status mosquitto.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details. <span class="comment"># 此錯誤可忽略</span></span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo systemctl stop mosquitto.service</span><br><span class="line">user@pc:~$ sudo systemctl <span class="built_in">disable</span> mosquitto.service</span><br></pre></td></tr></table></figure>
<p>安裝好就可以創建帳密檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo mosquitto_passwd -c /mosquitto/config/passwd_file joker <span class="comment"># 要創建的使用者名稱為 joker</span></span><br><span class="line">Password:          <span class="comment"># 1234</span></span><br><span class="line">Reenter password:  <span class="comment"># 1234</span></span><br><span class="line"></span><br><span class="line">user@pc:~$ <span class="built_in">cat</span> /mosquitto/config/passwd_file <span class="comment"># 查看內容</span></span><br><span class="line">joker:$6$9XBw6q7Iq1alMR6w<span class="variable">$576QauwU5YTieVS</span>+PPjrDD3a5UDolccQ0JwArFvcohYQe1XeEIxJlw0vXQCV0sN30+EoipWi1ng39GNHXl/PtQ==</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：將會新建一個帳密檔，會覆蓋現有的檔案。若只是想新增使用者到已經存在的帳密檔，不加此選項即可。</li>
<li><code>/mosquitto/config/passwd_file</code>：帳密檔的絕對路徑。</li>
<li><code>joker</code>：要創建的使用者名稱。</li>
</ul>
<h3 id="讀取帳密檔"><a href="#讀取帳密檔" class="headerlink" title="讀取帳密檔"></a>讀取帳密檔</h3><p>建立好之後，需修改 <code>/mosquitto/config/mosquitto.config</code>，讓 Mosquitto 知道要去讀取帳密檔，並且取消匿名使用者的登入權限 (匿名登入權限依應用情境而定)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line"></span><br><span class="line">allow_anonymous <span class="literal">false</span>   <span class="comment"># 這裡要改，取消匿名使用者的登入權限</span></span><br><span class="line">password_file /mosquitto/config/passwd_file  <span class="comment"># 這裡要加，讓 Mosquitto 知道要去讀取帳密檔</span></span><br><span class="line"></span><br><span class="line">listener 1883</span><br><span class="line">protocol mqtt</span><br></pre></td></tr></table></figure>
<p>重新運行 Container，使 Mosquitto 讀取的設定檔為最新的內容，使用帳號才能發布 (<code>mosquitto_pub</code>) 或訂閱 (<code>mosquitto_sub</code>)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker restart mqtt</span><br></pre></td></tr></table></figure>
<h3 id="測試帳密訂閱與發布"><a href="#測試帳密訂閱與發布" class="headerlink" title="測試帳密訂閱與發布"></a>測試帳密訂閱與發布</h3><p>開啟一個新的 Terminal (在此稱 tty1)，使用指令來訂閱主題。但由於我們已經設定為不可匿名登入，可以預想到的是會無法正常運作，因為沒有授權 (也就是沒有指定帳號)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_sub -h localhost -t Try/MQTT/Docker</span><br><span class="line">Connection error: Connection Refused: not authorised.</span><br></pre></td></tr></table></figure>
<p>tty1 中的指令更改如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_sub -h localhost -t Try/MQTT/Docker -u joker -P 1234</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code>：指定使用者帳號。</li>
<li><code>-P</code>：指定密碼，注意是大寫 P。</li>
</ul>
<p>開啟另一個新的 Terminal (在此稱 tty2)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_pub -h localhost -t Try/MQTT/Docker -m <span class="string">&quot;Test Message&quot;</span> -u joker -P 1234 </span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>這時在 tty1 應該就能看到 <code>Test Message</code> 的訊息，代表帳號密碼機制設定完成並且有正常運作！</p>
          </div>
<h2 id="使用-ACL-檔"><a href="#使用-ACL-檔" class="headerlink" title="使用 ACL 檔"></a>使用 ACL 檔</h2><h3 id="建立-ACL-檔"><a href="#建立-ACL-檔" class="headerlink" title="建立 ACL 檔"></a>建立 ACL 檔</h3><p>ACL (Access Control List) 存取控制表是用來描述一個物件對一串列的存取權限，Mosquitto 同樣也提供這個功能。第一步與帳密檔同樣，創建一個檔案 <code>/mosquitto/config/acl</code>，內容如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user joker</span><br><span class="line">topic readwrite joker/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用者 joker 只可以讀寫符合 pattern 為 <code>joker/#</code> 的 topic，其中 <code>#</code> 為多層級 WildCard 字元 (<code>+</code> 為單一層級)，因此 <code>joker</code>、<code>joker/Try</code> 與 <code>joker/Try/MQTT</code> 都是符合的 topic。</li>
</ul>
<h3 id="讀取-ACL-檔"><a href="#讀取-ACL-檔" class="headerlink" title="讀取 ACL 檔"></a>讀取 ACL 檔</h3><p>修改 <code>/mosquitto/config/mosquitto.config</code>，讓 Mosquitto 知道要去讀取 ACL 檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line"></span><br><span class="line">allow_anonymous <span class="literal">false</span></span><br><span class="line">password_file /mosquitto/config/passwd_file</span><br><span class="line">acl_file /mosquitto/config/acl  <span class="comment"># 加上這行</span></span><br><span class="line"></span><br><span class="line">listener 1883</span><br><span class="line">protocol mqtt</span><br></pre></td></tr></table></figure>
<p>重新運行 Container，使 Mosquitto 讀取的設定檔為最新的內容，知道 ACL 檔案的存在，這時 ACL 功能就正在運行囉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker restart mqtt</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>若嘗試以無權限的 topic (例如：<code>john</code>) 進行發布與訂閱，會發現雖然沒有出現錯誤訊息 (例如：權限不足)，但真的發送不出去，也接收不到的哦！</p>
          </div>
<h2 id="WebSocket-MQTT"><a href="#WebSocket-MQTT" class="headerlink" title="WebSocket MQTT"></a>WebSocket MQTT</h2><h3 id="啟用-WebSocket-MQTT"><a href="#啟用-WebSocket-MQTT" class="headerlink" title="啟用 WebSocket MQTT"></a>啟用 WebSocket MQTT</h3><p>WebSocket 是一種可在單個 TCP 連線上全雙工的通訊協定，只需要交握一次，便能建立永久的連線，進行雙向資料傳輸。對於需要低功耗的 IoT 應用來說，透過 WebSocket 使用 MQTT 的訂閱與發佈可以比傳統單純只使用 MQTT 來的節能，因此知道如何開啟 Mosquitto 的 WebSocket 通訊是必要的。</p>
<p>修改 <code>/mosquitto/config/mosquitto.config</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line"></span><br><span class="line">allow_anonymous <span class="literal">false</span></span><br><span class="line">password_file /mosquitto/config/passwd_file</span><br><span class="line">acl_file /mosquitto/config/acl</span><br><span class="line"></span><br><span class="line">listener 1883</span><br><span class="line">protocol mqtt</span><br><span class="line"></span><br><span class="line">listener 9001       <span class="comment"># 在 Port 9001</span></span><br><span class="line">protocol websockets <span class="comment"># 提供 WebSocket 服務</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一般 MQTT 協定在 1883 Port 服務</li>
<li>WebSocket MQTT 在 9001 Port 服務</li>
</ul>
<p>刪除正在運行的 MQTT Container，並建立一個比原先多綁定 Port 9001 的 Container</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker <span class="built_in">rm</span> -f mqtt</span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo docker run -d --name mqtt -p 1883:1883 -p 9001:9001 \</span><br><span class="line">                        -v /mosquitto:/mosquitto -v /mosquitto/data:/mosquitto/data \</span><br><span class="line">                        -v /mosquitto/log:/mosquitto/log eclipse-mosquitto</span><br><span class="line"></span><br><span class="line">user@pc:~$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE               COMMAND                  CREATED         STATUS         PORTS                                            NAMES</span><br><span class="line">f955f94c7f6e   eclipse-mosquitto   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   4 minutes ago   Up 2 minutes   0.0.0.0:1883-&gt;1883/tcp, 0.0.0.0:9001-&gt;9001/tcp   mqtt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="測試-WebSocket-MQTT"><a href="#測試-WebSocket-MQTT" class="headerlink" title="測試 WebSocket MQTT"></a>測試 WebSocket MQTT</h3><p>WebSocket MQTT 不像 MQTT 可使用 <code>mosquitto_pub</code>/<code>mosquitto_sub</code> 進行測試，因為這兩個指令不支援 WebSocket 通訊協定。這裡要介紹一個 MQTT 開發的好朋友 <a href="https://chrome.google.com/webstore/detail/mqttbox/kaajoficamnjijhkeomgfljpicifbkaf">MQTTBox</a>，MQTTBox 有 Chrome 瀏覽器的擴充套件版本，因此只要有 Chrome 瀏覽器就可以安裝使用！安裝 MQTTBox 並將其開啟，新建一個 MQTT Client，只需填寫 <code>MQTT Client Name</code>、<code>Protocol</code>、<code>Host</code>、<code>Username</code>、<code>Password</code> 五個欄位即可，其中因為我們要測試的是 WS MQTT 協定，因此 Protocol 要選擇 <code>ws</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/MQTT-Mosquitto-Docker-%E6%9E%B6%E8%A8%AD%E8%88%87%E8%A8%AD%E5%AE%9A%E8%A9%B3%E7%B4%B0%E9%81%8E%E7%A8%8B%2Fmqtt_ws.png?alt=media&amp;token=e7ee2d12-6d53-42fe-b5ce-c0482036a8d0" alt="WS MQTT 連線設定"><span class="image-caption">WS MQTT 連線設定</span></p>
<p>建立好並存檔，同時確認畫面上方 Connected 按鈕為綠色的，表示連線正常，這時就可以來發布/訂閱測試啦！在 <code>Topic to publish</code> 與 <code>Topic to subscribe</code> 兩個欄位填寫相同的主題名稱，先訂閱再發布，就會再訂閱區塊中看到發布的訊息囉！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/MQTT-Mosquitto-Docker-%E6%9E%B6%E8%A8%AD%E8%88%87%E8%A8%AD%E5%AE%9A%E8%A9%B3%E7%B4%B0%E9%81%8E%E7%A8%8B%2Fmqtt_ws_pub_test.png?alt=media&amp;token=459ce067-bc62-424b-a159-812195dc5509" alt="WS MQTT 訂閱與發佈測試"><span class="image-caption">WS MQTT 訂閱與發佈測試</span></p>
<div class="note info">
            <p>確認 WS MQTT 可以正常運行！</p>
          </div>
<h2 id="MQTTS-與-WSS"><a href="#MQTTS-與-WSS" class="headerlink" title="MQTTS 與 WSS"></a>MQTTS 與 WSS</h2><p>Mosquitto 有提供 MQTTS 與 WSS 通訊協定，協定名稱中最後一個字母 S 皆代表 SSL，SSL 能使我們的通訊透過加密防止中間人或竊聽攻擊，要使用 SSL 必須先擁有憑證，然而申請一個正式憑證需要較多手續與耗費許多時日。因此在測試環境中我們可以先自簽憑證，測試加上 SSL 後系統是否能正常運作，若之後系統要上線，再替換為正式的憑證即可。</p>
<h3 id="自簽憑證"><a href="#自簽憑證" class="headerlink" title="自簽憑證"></a>自簽憑證</h3><p>詳細步驟與說明可以參考 <a href="/2021/06/15/ssl_self_sign/">[SSL] 自簽憑證過程</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 創建目錄</span></span><br><span class="line">user@pc:~$ <span class="built_in">mkdir</span> root</span><br><span class="line">user@pc:~$ <span class="built_in">mkdir</span> server</span><br><span class="line"></span><br><span class="line"><span class="comment"># CA 產 CA 的自簽憑證</span></span><br><span class="line">user@pc:~$ openssl genrsa -out root/ca.key 4096</span><br><span class="line">user@pc:~$ openssl req -new -x509 -days 365 -subj <span class="string">&quot;/C=TW/CN=&#123;這裡任意&#125;&quot;</span> \</span><br><span class="line">                        -key root/ca.key -out root/ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 簽 Server 憑證</span></span><br><span class="line">user@pc:~$ openssl genrsa -out server/server.key 2048</span><br><span class="line">user@pc:~$ openssl req -new -key server/server.key -subj <span class="string">&quot;/C=TW/CN=&#123;Server IP 或 FQDN&#125;&quot;</span> \</span><br><span class="line">                        -out server/server.csr</span><br><span class="line">user@pc:~$ openssl x509 -req -CAcreateserial -days 30 -sha256 -CA root/ca.crt \</span><br><span class="line">                        -CAkey root/ca.key -<span class="keyword">in</span> server/server.csr -out server/server.crt</span><br></pre></td></tr></table></figure>
<ul>
<li>最最最需要注意的是 CA 的 CN 與 Server 的 CN 不能一樣，否則會出現意想不到的錯誤。</li>
</ul>
<p>將 <code>ca.crt</code>、<code>server.key</code>、<code>server.crt</code> 移至 <code>/mosquitto/config/certs/</code> 目錄下。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 創建目錄</span></span><br><span class="line">user@pc:~$ sudo <span class="built_in">mkdir</span> /mosquitto/config/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移動憑證</span></span><br><span class="line">user@pc:~$ sudo <span class="built_in">cp</span> root/ca.crt /mosquitto/config/certs/</span><br><span class="line">user@pc:~$ sudo <span class="built_in">cp</span> server/server.key /mosquitto/config/certs/</span><br><span class="line">user@pc:~$ sudo <span class="built_in">cp</span> server/server.crt /mosquitto/config/certs/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="啟用-MQTTS-與-WSS"><a href="#啟用-MQTTS-與-WSS" class="headerlink" title="啟用 MQTTS 與 WSS"></a>啟用 MQTTS 與 WSS</h3><p>修改 <code>/mosquitto/config/mosquitto.config</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persistence <span class="literal">true</span></span><br><span class="line">persistence_location /mosquitto/data/</span><br><span class="line">log_dest file /mosquitto/log/mosquitto.log</span><br><span class="line"></span><br><span class="line">allow_anonymous <span class="literal">false</span></span><br><span class="line">password_file /mosquitto/config/passwd_file</span><br><span class="line">acl_file /mosquitto/config/acl</span><br><span class="line"></span><br><span class="line">listener 1883</span><br><span class="line">protocol mqtt</span><br><span class="line"></span><br><span class="line">listener 9001</span><br><span class="line">protocol websockets</span><br><span class="line"></span><br><span class="line">listener 8883                                <span class="comment"># 在 Port 8883</span></span><br><span class="line">protocol mqtt                                <span class="comment"># 服務 MQTTS</span></span><br><span class="line">keyfile /mosquitto/config/certs/server.key   <span class="comment"># Server 的私鑰</span></span><br><span class="line">certfile /mosquitto/config/certs/server.crt  <span class="comment"># Server 的憑證</span></span><br><span class="line">cafile /mosquitto/config/certs/ca.crt        <span class="comment"># CA 的憑證，若不驗證 client 可以不指定 cafile</span></span><br><span class="line"></span><br><span class="line">listener 8884                                <span class="comment"># 在 Port 8884</span></span><br><span class="line">protocol websockets                          <span class="comment"># 服務 WSS MQTT</span></span><br><span class="line">keyfile /mosquitto/config/certs/server.key   <span class="comment"># Server 的私鑰</span></span><br><span class="line">certfile /mosquitto/config/certs/server.crt  <span class="comment"># Server 的憑證</span></span><br><span class="line">cafile /mosquitto/config/certs/ca.crt        <span class="comment"># CA 的憑證，若不驗證 client 可以不指定 cafile</span></span><br><span class="line"></span><br><span class="line">require_certificate <span class="literal">false</span>                    <span class="comment"># 這行是不驗證 client 端的憑證</span></span><br></pre></td></tr></table></figure>
<p>刪除正在運行的 MQTT Container，並建立一個比原先多綁定 Port 8883 與 8884 的 Container</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo docker <span class="built_in">rm</span> -f mqtt</span><br><span class="line">user@pc:~$ sudo docker run -d --name mqtt -p 1883:1883 -p 9001:9001 -p 8883:8883 -p 8884:8884 \</span><br><span class="line">                        -v /mosquitto:/mosquitto -v /mosquitto/data:/mosquitto/data \</span><br><span class="line">                        -v /mosquitto/log:/mosquitto/log eclipse-mosquitto</span><br></pre></td></tr></table></figure>
<h3 id="測試-MQTTS"><a href="#測試-MQTTS" class="headerlink" title="測試 MQTTS"></a>測試 MQTTS</h3><p>MQTTS 可使用指令來測試</p>
<p>開啟一個新的 Terminal (在此稱 tty1)，使用指令來訂閱主題</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_sub --cafile /mosquitto/config/certs/ca.crt -t joker/Try/MQTT -h localhost \</span><br><span class="line">                        -p 8883 -u joker -P 1234 --insecure</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--cafile</code>：CA 的憑證。</li>
<li><code>--insecure</code>：不要驗證憑證合法性。使用此選項是因為這裡我們使用的是自簽憑證，若驗證憑證合法性一定有很多問題會出現，我們的目的只是想先測試 MQTTS 是否可以正常運作，因此不需驗證憑證合法性。</li>
<li><code>-p</code>：指定要連接的 Port，若沒指定預設為 1883 Port。</li>
</ul>
<p>開啟另一個新的 Terminal (在此稱 tty2)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mosquitto_pub --cafile /mosquitto/config/certs/ca.crt -t joker/Try/MQTT -m <span class="string">&quot;Test Message&quot;</span> -h localhost \ </span><br><span class="line">                        -p 8883 -u joker -P 1234 --insecure</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>這時在 tty1 應該就能看到 <code>Test Message</code> 的訊息，代表 MQTTS 設定完成並且有正常運作！</p>
          </div>
<h3 id="測試-WSS-MQTT"><a href="#測試-WSS-MQTT" class="headerlink" title="測試 WSS MQTT"></a>測試 WSS MQTT</h3><p>WSS 的測試與 WS 測試相同，利用 MQTTBox 來做測試，但是擴充套件的似乎無法處理 SSL 的部分，不管我如何設定都會出現連線錯誤，因此我使用另一台電腦 (Windows 10) 安裝 MQTTBox 本體來測試連線，WSS 連線設定與 WS 不同的一點是多了 <code>SSL/TLS Version</code> 與 <code>SSL/TLS Certificate Type</code> 欄位，只需更動 Type 選擇 <code>CA Signed server certificate</code> 即可</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/MQTT-Mosquitto-Docker-%E6%9E%B6%E8%A8%AD%E8%88%87%E8%A8%AD%E5%AE%9A%E8%A9%B3%E7%B4%B0%E9%81%8E%E7%A8%8B%2Fwss_mqtt.png?alt=media&amp;token=7e6efc43-7fe1-4007-9227-3586fe9d8546" alt="WSS MQTT 連線設定"><span class="image-caption">WSS MQTT 連線設定</span></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/MQTT-Mosquitto-Docker-%E6%9E%B6%E8%A8%AD%E8%88%87%E8%A8%AD%E5%AE%9A%E8%A9%B3%E7%B4%B0%E9%81%8E%E7%A8%8B%2Fwss_mqtt_pub_test.png?alt=media&amp;token=7eef0374-e336-448f-9eac-d2e4c9c75218" alt="WSS MQTT 訂閱與發佈測試"><span class="image-caption">WSS MQTT 訂閱與發佈測試</span></p>
<div class="note info">
            <p>至此， MQTT/MQTTS/WS/WSS 四個通訊協定都已經正常運作，最終選擇所要使用的通訊協定還是要回歸到應用情境，若沒用到的 Port 可以選擇關閉以釋放系統資源。</p>
          </div>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章記錄了如何使用 Docker 輕鬆架設 MQTT Broker (Mosquitto)，並且使用身分驗證、ACL 權限控管，啟動 MQTT/MQTTS/WS/WSS 四個協定。當然，還有更多的進階設定沒有在此篇文章中紀載，但架設伺服器的第一步，就是先將基本設定完善，並確認能夠運行，才能繼續下一步的調教。</p>
]]></content>
      <categories>
        <category>伺服器架設筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>20.04</tag>
        <tag>linux</tag>
        <tag>websocket</tag>
        <tag>password</tag>
        <tag>ssl</tag>
        <tag>mqtt</tag>
        <tag>mosquitto</tag>
        <tag>docker</tag>
        <tag>tcp</tag>
        <tag>acl</tag>
        <tag>image</tag>
        <tag>container</tag>
        <tag>mqttbox</tag>
      </tags>
  </entry>
  <entry>
    <title>[MariaDB] CentOS 安裝最新版 MariaDB</title>
    <url>/2021/06/19/mariadb_centos/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常 CentOS 官方的 repository 不會隨著各個套件更新到最新，因為對於伺服器對外服務來說，穩定版的套件才是是最重要的。但需要使用最新版本的 MariaDB 的話要怎麼辦呢？來看看如何做吧！</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>CentOS 8.2</li>
</ul>
<h2 id="新增-repository"><a href="#新增-repository" class="headerlink" title="新增 repository"></a>新增 repository</h2><p>新增一個檔案 <code>/etc/yum.repos.d/MariadDB.repo</code> 其內容如下。這裡要特別說明一下，若版本是選擇 <code>x.x</code>，則會安裝 <code>x.x</code> 版中最新的那個版本，像現在這個當下，在 <code>10.5</code> 中最新版本是 <code>10.5.5</code>；若想要下載 <code>10.5.4</code> 怎麼辦呢？很簡單！<code>10.5</code> 改為 <code>10.5.4</code> 就好了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = http://yum.mariadb.org/10.5/centos8-amd64</span><br><span class="line">module_hotfixes=1</span><br><span class="line">gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure>
<p>確認 repository 有加入成功，若有看到 MariaDB 就可以開始安裝了喲！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf makecache</span><br><span class="line">CentOS-8 - AppStream</span><br><span class="line">CentOS-8 - Base</span><br><span class="line">CentOS-8 - Extras</span><br><span class="line">MariaDB</span><br><span class="line">Extra Packages <span class="keyword">for</span> Enterprise Linux Modular 8 - x86_64</span><br><span class="line">Extra Packages <span class="keyword">for</span> Enterprise Linux 8 - x86_64</span><br><span class="line">Metadata cache created.</span><br></pre></td></tr></table></figure>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>詳細安裝與設定步驟可以參考 <a href="/2021/06/18/mysql_centos_mysql_8_0_root/">[MySQL] CentOS 8 安裝 MySQL 8.0 與更改 root 密碼</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ sudo dnf install mariadb-server mariadb</span><br></pre></td></tr></table></figure>
<h2 id="檢查版本"><a href="#檢查版本" class="headerlink" title="檢查版本"></a>檢查版本</h2><p>在 <code>Version</code> 欄位可以看到是目前最新的版本 <code>10.5.5</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[user@localhost ~]$ rpm -qi MariaDB-server</span><br><span class="line">Name        : MariaDB-server</span><br><span class="line">Version     : 10.5.5</span><br><span class="line">Release     : 1.el8</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Wed 23 Sep 2020 03:43:14 PM CST</span><br><span class="line">Group       : Applications/Databases</span><br><span class="line">Size        : 132924528</span><br><span class="line">License     : GPLv2</span><br><span class="line">Signature   : DSA/SHA1, Sat 08 Aug 2020 10:10:11 AM CST, Key ID cbcb082a1bb943db</span><br><span class="line">Source RPM  : MariaDB-server-10.5.5-1.el8.src.rpm</span><br><span class="line">Build Date  : Sat 08 Aug 2020 12:27:40 AM CST</span><br><span class="line">Build Host  : rhel8-amd64</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Vendor      : MariaDB Foundation</span><br><span class="line">URL         : http://mariadb.org</span><br><span class="line">Summary     : MariaDB: a very fast and robust SQL database server</span><br><span class="line">Description :</span><br><span class="line">MariaDB: a very fast and robust SQL database server</span><br><span class="line"></span><br><span class="line">It is GPL v2 licensed, <span class="built_in">which</span> means you can use the it free of charge under the</span><br><span class="line">conditions of the GNU General Public License Version 2 (http://www.gnu.org/licenses/).</span><br><span class="line"></span><br><span class="line">MariaDB documentation can be found at https://mariadb.com/kb</span><br><span class="line">MariaDB bug reports should be submitted through https://jira.mariadb.org</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>伺服器架設筆記</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>mariadb</tag>
        <tag>8.2</tag>
        <tag>update</tag>
        <tag>latest</tag>
        <tag>version</tag>
        <tag>repository</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day01] Tableau 輕鬆學 - 前言</title>
    <url>/2021/07/22/day01_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不論是在 IT 抑或是其他產業中，終究會遇到需將手上大量的數據視覺化，並轉為有用的商業智能 (BI, Business Intelligence) 的需求 (例如：產品銷售分析、瀏覽流量分析、GA 後台數據分析等等)。雖然我們 IT 人身懷絕技，簡單的折線圖、長條圖還難不倒我們，但若是氣泡圖、盒鬚圖呢？數據呈現方式百百種，真的要花心力在每一種數據呈現方式都寫出一支對應的程式上嗎？個人認為這個是一個非常耗時且不理智的解決方案，因為我們最終的目標是將數據轉化為企業價值的 Know How，而不是寫出數據視覺化的程式。</p>
<p>Tableau 是一種交互式商業智能數據視覺化軟體，個人因工作上的需求進而接觸到這套軟體，它能讓我輕鬆地將大量數據視覺化、從資料中說故事，還能排程做資料清洗 (ETL, Extract-Transform-Load)。最令我覺得方便的是這整個過程中幾乎不用寫到一行程式，只需透過圖形介面拖曳來完成數據處理工作，就能以各種圖表將數據視覺化。</p>
<p>相信很多人甚至是企業都有這樣的需求，因此藉由這次自我挑戰的機會，創作 <a href="/categories/Tableau-輕鬆學/">Tableau 輕鬆學</a> 系列文章將 Tableau 帶給各位讀者。然而，資料分析還是要看上下文情境的，難以將每種可能的情況都概括進來，但還是希望可以達成自我期許的目標：「提供讀者想要實作某些功能時，有個可以思考的方向，或者可以想到回來參考這些文章」。也因為如此，這系列的文章不會著重於資料背後的故事，而是專注說明每個概念與功能的使用。</p>
<h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><div class="note info">
            <p>閱讀一本書之前，良好的習慣是先讀它的目錄，知道它將帶給我們什麼知識，對整個脈絡於心中有個底之後，閱讀起來會比較踏實。</p>
          </div>
<p><a href="/categories/Tableau-輕鬆學/">Tableau 輕鬆學</a> 為 30 天持續分享的系列文章，透過每天學習一個觀念達到輕鬆學習使用 Tableau 的目標</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Day</th>
<th>Topic</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td><a href="/2021/07/22/day01_tableau/">前言</a></td>
</tr>
<tr>
<td>02</td>
<td><a href="/2021/07/23/day02_tableau/">Tableau 介紹</a></td>
</tr>
<tr>
<td>03</td>
<td><a href="/2021/07/24/day03_tableau/">Tableau 相關職缺</a></td>
</tr>
<tr>
<td>04</td>
<td><a href="/2021/07/25/day04_tableau/">Tableau 三大軟體</a></td>
</tr>
<tr>
<td>05</td>
<td><a href="/2021/07/26/day05_tableau/">Tableau 授權類型</a></td>
</tr>
<tr>
<td>06</td>
<td><a href="/2021/07/27/day06_tableau/">Tableau Desktop 安裝</a></td>
</tr>
<tr>
<td>07</td>
<td><a href="/2021/07/28/day07_tableau/">開始畫面</a></td>
</tr>
<tr>
<td>08</td>
<td><a href="/2021/07/29/day08_tableau/">資料連線種類</a></td>
</tr>
<tr>
<td>09</td>
<td><a href="/2021/07/30/day09_tableau/">Data Source 頁面</a></td>
</tr>
<tr>
<td>10</td>
<td><a href="/2021/07/31/day10_tableau/">Dimension 與 Measure</a></td>
</tr>
<tr>
<td>11</td>
<td><a href="/2021/08/01/day11_tableau/">Workbook/Worksheet/Dashboard/Story</a></td>
</tr>
<tr>
<td>12</td>
<td><a href="/2021/08/02/day12_tableau/">長條圖工作表</a></td>
</tr>
<tr>
<td>13</td>
<td><a href="/2021/08/03/day13_tableau/">Rows 與 Columns</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="/2021/08/04/day14_tableau/">美化工作表外觀</a></td>
</tr>
<tr>
<td>15</td>
<td><a href="/2021/08/05/day15_tableau/">地圖工作表</a></td>
</tr>
<tr>
<td>16</td>
<td><a href="/2021/08/06/day16_tableau/">儀表板</a></td>
</tr>
<tr>
<td>17</td>
<td><a href="/2021/08/07/day17_tableau/">美化儀表板外觀</a></td>
</tr>
<tr>
<td>18</td>
<td><a href="/2021/08/08/day18_tableau/">Relationships 與 Joins</a></td>
</tr>
<tr>
<td>19</td>
<td><a href="/2021/08/09/day19_tableau/">Data Extract</a></td>
</tr>
<tr>
<td>20</td>
<td><a href="/2021/08/10/day20_tableau/">Calculated Field</a></td>
</tr>
<tr>
<td>21</td>
<td><a href="/2021/08/11/day21_tableau/">Parameter</a></td>
</tr>
<tr>
<td>22</td>
<td><a href="/2021/08/12/day22_tableau/">TabPy 介紹</a></td>
</tr>
<tr>
<td>23</td>
<td><a href="/2021/08/13/day23_tableau/">TabPy 安裝與連線</a></td>
</tr>
<tr>
<td>24</td>
<td><a href="/2021/08/14/day24_tableau/">TabPy 使用方法 1</a></td>
</tr>
<tr>
<td>25</td>
<td><a href="/2021/08/15/day25_tableau/">TabPy 使用方法 2</a></td>
</tr>
<tr>
<td>26</td>
<td><a href="/2021/08/16/day26_tableau/">TabPy 開發流程</a></td>
</tr>
<tr>
<td>27</td>
<td><a href="/2021/08/17/day27_tableau/">TabPy 除錯技巧</a></td>
</tr>
<tr>
<td>28</td>
<td><a href="/2021/08/18/day28_tableau/">TabPy 備份與還原</a></td>
</tr>
<tr>
<td>29</td>
<td><a href="/2021/08/19/day29_tableau/">TabPy 啟動排程</a></td>
</tr>
<tr>
<td>30</td>
<td><a href="/2021/08/20/day30_tableau/">總結</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>viz</tag>
        <tag>bi</tag>
        <tag>business</tag>
        <tag>intelligence</tag>
        <tag>etl</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day03] Tableau 輕鬆學 - Tableau 相關職缺</title>
    <url>/2021/07/24/day03_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>對於所待公司正在使用 Tableau 做商業智能開發的讀者來說，學習這套軟體的動機是無庸置疑的，強而有力的學習動機就是公司需要，因此可以毫無懸念的去專研。</p>
<p>但是對於初次接觸或甚至是還在猶豫要不要學的讀者來說，我認為還是有必要先市場調查一下，觀察 Tableau 相關職缺的情況是如何，從人力市場來了解技術的需求度是最真實的，藉以建立讀者學習這套軟體的目標與目的性。畢竟現在技術這麼多，總是會怕花時間學一個無處發揮技術。</p>
<h2 id="人力市場調查"><a href="#人力市場調查" class="headerlink" title="人力市場調查"></a>人力市場調查</h2><p>當前時間為 <code>2021/07/11</code>，個人在某人力銀行網站上，單純搜尋關鍵字 <code>tableau</code>，結果顯示出目前總共有 449 個相關職缺，其中 435 個是全職的人力需求</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay03-Tableau-%E7%9B%B8%E9%97%9C%E8%81%B7%E7%BC%BA%2Ftableau_job_total.png?alt=media&amp;token=71d694db-f16f-404d-bfcb-7201cd717c1a" alt="Tableau 相關職缺總數"><span class="image-caption">Tableau 相關職缺總數</span></p>
<p>從眾多刊登中挑選四家公司的職缺出來看，分別是愛金卡、晶元光電、OB嚴選、微星，當然還有多家公司同樣也刊載 Tableau 的尋人啟事，但這裡特意挑選四個不同領域且規模不小的公司，呼應到個人在前言說的，無論什麼領域的公司，皆會面臨到將零散的原始數據轉換為公司寶貴資產 BI 的課題，而這個過程脫離不了使用 BI 工具來協助</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay03-Tableau-%E7%9B%B8%E9%97%9C%E8%81%B7%E7%BC%BA%2Ftableau_job_four.png?alt=media&amp;token=a29c9a15-f4d5-4e47-b85b-16fb6ff7be3f" alt="四個不同領域但與 Tableau 相關的徵才資訊"><span class="image-caption">四個不同領域但與 Tableau 相關的徵才資訊</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>很顯然，這四家公司皆選擇使用 Tableau 作為 BI 工具，若想應徵這些職缺，那就需要先把 Tableau 學好，因為對這些職位來說，Tableau 只是最基本的要求而已。我想，這應該是一個讓讀者督促自己學習 Tableau 很好的理由。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>job</tag>
        <tag>relate</tag>
        <tag>skill</tag>
        <tag>technology</tag>
        <tag>requirement</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day02] Tableau 輕鬆學 - Tableau 介紹</title>
    <url>/2021/07/23/day02_tableau/</url>
    <content><![CDATA[<h2 id="Tableau-優點"><a href="#Tableau-優點" class="headerlink" title="Tableau 優點"></a>Tableau 優點</h2><p>Tableau 是一種企業級的商業智能 (BI, Business Intelligence) 軟體，提供直覺式的使用者介面，使用者只需使用滑鼠拖曳就能完成數據視覺化的作業程序，且可隨時變換呈現的方式，減少在分析過程中因為技術問題而中斷的可能性。</p>
<p>除了內建功能多樣外，Tableau 透過與 Python、R 兩種語言整合，允許使用者可以自己創造函式，更甚者，可以將機器學習 (ML, Machine Learning) 與人工智慧 (AI, Artificial Intelligence) 整合進來，使 Tableau 無極限。因此在後續的分享內容中，會提到如何讓 Python 與 Tableau 合作來加強我們的數據呈現，提供更多觀點。</p>
<p>官方分享許多的教學影片與使用範例資源，讓我們可以跟著範例動手操作同時學習視覺化的技巧。也提供強大的社群平台，在平台上面可與其他 Tableau 同好進行交流學習，依個人使用的經驗來說，發問後通常很快可以得到有用的回覆。</p>
<h2 id="Tableau-缺點"><a href="#Tableau-缺點" class="headerlink" title="Tableau 缺點"></a>Tableau 缺點</h2><p>然而，再好的軟體也是有缺點的，這裡列出到目前為止，個人使用 Tableau 時認為的 4 個缺點</p>
<ol>
<li>因為 Tableau 是企業級軟體，所以需要購買才可使用，若沒有購買只能擁有 14 天試用的機會。</li>
<li>教學影片以英文為主，若對英文不是太熟悉的人，觀看教學影片可能會比較吃力，不過有些影片會提供英文字幕。此外，教學文章有提供繁體中文的版本，以這點來說還是很不錯。</li>
<li>某些 2D 圖需要一些技巧才能畫出來。例如：Tableau 無法輕鬆地畫出雷達圖，但仍然有網友提供解決方案，美中不足的是該方案沒那麼直覺且彈性也較低。</li>
<li>若要畫 3D 圖會比較困難。但對 BI 軟體來說，2D 的數據呈現應該就已經足夠，3D 圖在科學或工程領域較容易用到。</li>
</ol>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://community.tableau.com/s/question/0D54T00000C5dAZ/how-do-you-create-a-3d-view-of-the-data">How do you create a 3d view of the data</a></li>
</ol>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tableau</tag>
        <tag>bi</tag>
        <tag>introduction</tag>
        <tag>r</tag>
        <tag>limit</tag>
        <tag>disadvantage</tag>
        <tag>advantage</tag>
        <tag>pros</tag>
        <tag>cons</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day04] Tableau 輕鬆學 - Tableau 三大軟體</title>
    <url>/2021/07/25/day04_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tableau 是多個軟體的通稱，我們初學在進行 BI 分析時，最常會用到其中的三種，分別為 Tableau Desktop、Tableau Server 與 Tableau Prep Builder。這三個軟體的功能被切分明確，這裡詳細說明每個軟體所可以做到的事情，避免在不對的軟體中找尋想要的功能。</p>
<h2 id="Tableau-Desktop"><a href="#Tableau-Desktop" class="headerlink" title="Tableau Desktop"></a>Tableau Desktop</h2><p>設計工作表、儀表板、故事等將數據視覺化的工作都會在此軟體中完成，因此這 30 天的 Tableau 使用分享中大部分的時間都會是在這個軟體之中進行操作。</p>
<h2 id="Tableau-Server"><a href="#Tableau-Server" class="headerlink" title="Tableau Server"></a>Tableau Server</h2><p>Tableau Server 是一個 Web Server，當我們在 Tableau Desktop 的相關工作進行完畢之後，可能會想將這些視覺化內容分享給同事或主管。Tableau 對應的解決方案就是讓我們可以透過 Web 的方式來做到這件事情，只需要從 Tableau Desktop 上傳結果至預先架設好的 Tableau Server，透過 Web Browser 連線到對應的工作簿即可查看視圖，在 Tableau Server 上使用者也可以直接與儀錶板互動，專注在自己所關心的內容。</p>
<p>然而，Tableau Server 不支援 Windows 10 作業系統，且個人使用 Tableau 到目前為止，認為 Tableau Server 操作極為容易，只需安裝好之後再將 Tableau Desktop 的工作簿上傳即可，因此不會介紹到如何安裝與使用 Tableau Server，倘若將來有機會碰到，再去摸索也很容易上手。</p>
<h2 id="Tableau-Prep-Builder"><a href="#Tableau-Prep-Builder" class="headerlink" title="Tableau Prep Builder"></a>Tableau Prep Builder</h2><p>根據 Harvard Business Review 指出，數據分析作業時間中，有 80% 的時間都耗費在資料處理上、只有 20％ 時間在做資料分析。Tableau 提供數據清洗 (ETL, Extract-Tranform-Load) 工具 Tableau Prep Builder 來解決這個問題，只需要簡單地拖曳選項卡就能夠完成資料清洗，讓我們可以集中 80% 的寶貴時間與心力放在資料分析上，對資料分析師來說是一個很貼心的解決方案。</p>
<p>Tableau Prep Builder 與 Tableau Desktop 的操作概念可說是極為類似，差別只在於一個是專注於數據呈現，另一個專注於數據清洗，若 Tableau Desktop 使用的觀念建立扎實，再直接套用到 Tableau Prep Builder 也能通。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://www.tableau.com/zh-tw/products/techspecs">Tableau 技術規格</a></p>
</li>
<li><p><a href="https://hbr.org/2018/08/what-data-scientists-really-do-according-to-35-data-scientists">What Data Scientists Really Do, According to 35 Data Scientists</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>public</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
        <tag>prep</tag>
        <tag>builder</tag>
        <tag>online</tag>
        <tag>crm</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day05] Tableau 輕鬆學 - Tableau 授權類型</title>
    <url>/2021/07/26/day05_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安全且有系統地使用一套軟體的前提，是先了解其授權機制與權限範圍，知道自己的角色可以做到什麼事與被限制的功能，亦即所謂的知己知彼，明白自己的處境可以讓我們在開發時省去很多不必要的探索時間。</p>
<h2 id="授權類型"><a href="#授權類型" class="headerlink" title="授權類型"></a>授權類型</h2><p>Tableau 有三種 Role-Based 授權類型，授權範圍由大到小為 Creator、Explorer 與 Viewer</p>
<h3 id="Creator"><a href="#Creator" class="headerlink" title="Creator"></a>Creator</h3><p>允許使用 Tableau Desktop 與 Tableau Prep Builder 來建立資料來源、資料清洗等，並製作圖表來將數具視覺化。簡單來說，若從原始資料到視覺化呈現都需要參與到，便需要 Creator 授權。Creator 是三個授權之中最多權限的角色。</p>
<h3 id="Explorer"><a href="#Explorer" class="headerlink" title="Explorer"></a>Explorer</h3><p>能夠使用其他人已經建立好的資料來源來建立自己的儀表板，或者在他人建立好的視覺化文件上做修改，以符合自己的需求。</p>
<h3 id="Viewer"><a href="#Viewer" class="headerlink" title="Viewer"></a>Viewer</h3><p>能查看其他人上傳到 Tableau Server 且有查看權限的視覺化文件，允許與該文件做互動，例如：使用儀表板提供的篩選器功能。Viewer 是三個授權類型中最少權限的角色，僅能查看被賦予查看權限的文件。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在 <a href="/categories/Tableau-輕鬆學/">Tableau 輕鬆學</a> 系列文章中，是以 Creator 授權角色來做軟體操作使用的分享。在軟體 14 天試用期的期間內，Tableau 會以最大權限角色 Creator 讓我們得以試用各種功能，因此不需要擔心文章中提到的功能會有無法使用的情況。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://help.tableau.com/current/blueprint/zh-tw/bp_license_types.htm">Tableau 授權類型</a></li>
</ol>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>creator</tag>
        <tag>explorer</tag>
        <tag>viewer</tag>
        <tag>license</tag>
        <tag>role</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day06] Tableau 輕鬆學 - Tableau Desktop 安裝</title>
    <url>/2021/07/27/day06_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tableau Desktop 版本更新非常快速，平均一季會推出一個新版本，每個版本之間在介面上會有些微差異，例如：按鈕位置不同。也因為如此，若想跟著分享文章來學習實作，建議安裝相同版本的 Tableau Desktop，避免在學習時由於操作介面些微不同而感到困惑。若想了解每個版本擁有的功能，可以參考 <a href="https://www.tableau.com/zh-tw/products/all-features">Tableau 所有版本資訊</a>。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>這裡選擇使用 <a href="https://www.tableau.com/zh-tw/support/releases/desktop/2020.4.2">Tableau Desktop 2020.4.2</a> 來分享使用操作，沒有特別的原因，單純因為個人平常使用的是這個版本。至官方網站提供的下載點 <a href="https://www.tableau.com/zh-tw/support/releases/desktop/2020.4.2#esdalt">Tableau Desktop 2020.4.2</a> 依照自己的作業系統選擇對應的載點進行下載，大約 <code>0.5 GB</code> 的大小，實際 Tableau Desktop 所需配備可以參考 <a href="https://www.tableau.com/zh-tw/products/techspecs#desktop">Tableau Desktop 技術規格</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay06-Tableau-Desktop-%E5%AE%89%E8%A3%9D%2Ftableau_2020_4_2_download.png?alt=media&amp;token=5416b9dc-06ae-4d74-8f67-2803c5955de7" alt="Tableau Desktop 2020.4.2 下載點"><span class="image-caption">Tableau Desktop 2020.4.2 下載點</span></p>
<p>開啟下載來的檔案進行安裝程序，其中 <code>請勿傳送產品使用情況資料</code> 選項視自己的意願做勾選，其主要是 Tableau 希望能蒐集我們的使用情形相關數據，用來改善 Tableau Desktop 的 UX，一方面可以讓使用者用得更順手，另一方面可讓 Tableau 以直覺化的優點吸引更多用戶，長遠來看是一個雙贏的場面。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay06-Tableau-Desktop-%E5%AE%89%E8%A3%9D%2Ftableau_install.png?alt=media&amp;token=8db7856b-ecf8-447f-b10e-aa30b01563b1" alt="安裝介面"><span class="image-caption">安裝介面</span></p>
<p>勾選好即可進行安裝，安裝不算太慢，個人在配備較差的虛擬機 (VM, Virtual Machine) 中只需要不到5分鐘即安裝完成。當安裝程序完成後會自動跳出一個視窗，要求我們填寫相關訊息，才會幫我們啟動 14 天試用版，表單內應該只有 <code>國家/地區</code> 欄位是選填的 (但偷偷的說，其實每個欄位都可以不用填寫真實資料)。一樣依自己情況做填寫，填寫好送出後就正式開始 14 天的試用期計算囉！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay06-Tableau-Desktop-%E5%AE%89%E8%A3%9D%2Ftableau_free_register.png?alt=media&amp;token=4694ec0d-5f16-4a11-995b-15614c524c23" alt="試用註冊"><span class="image-caption">試用註冊</span></p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://www.tableau.com/zh-tw/products/all-features">Tableau 所有版本資訊</a></p>
</li>
<li><p><a href="https://www.tableau.com/zh-tw/products/techspecs">Tableau 所有技術規格</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>install</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day07] Tableau 輕鬆學 - 開始畫面</title>
    <url>/2021/07/28/day07_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每個軟體的開始畫面，或多或少會有些好用但總是被我們忽略的功能，等我們使用一段時間後才從別人那邊得知，內心一段話隨之浮現：「啊！原來有這麼好用的功能。」為了避免這種憾事，特地介紹 Tableau Desktop 開始畫面中能做到的事情。</p>
<h2 id="開始畫面"><a href="#開始畫面" class="headerlink" title="開始畫面"></a>開始畫面</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay07-%E9%96%8B%E5%A7%8B%E7%95%AB%E9%9D%A2%2Ftableau_begin.png?alt=media&amp;token=7bb3672a-479e-488b-a27c-6d07d3292731" alt="開始畫面"><span class="image-caption">開始畫面</span></p>
<p>開始畫面中有五個窗格，各別說明其功用</p>
<h3 id="1-Connect"><a href="#1-Connect" class="headerlink" title="1. Connect"></a>1. Connect</h3><p>在此窗格中設定資料的連線，不論資料來源是檔案 (To a File) 或是資料伺服器 (To a Server)，只要是與資料連線有關的設定，都在此處操作。</p>
<h3 id="2-Open"><a href="#2-Open" class="headerlink" title="2. Open"></a>2. Open</h3><p>在此窗格中會顯示最近開啟過的 Tableau 工作簿，讓我們可以快速存取檔案，不需要重新尋找。現在為剛安裝完 Tableau Desktop 的狀態，還沒開啟過任何工作簿，所以畫面空白是正常的。</p>
<h3 id="3-Discover"><a href="#3-Discover" class="headerlink" title="3. Discover"></a>3. Discover</h3><p>Tableau 在軟體使用的教育訓練上下了很大的功夫，這個窗格中會放置有主題性的教學資源，讓我們可以不用回到網頁上去搜尋，就可以有完善且有系統的教程可以學習。</p>
<h3 id="4-Sample-Workbooks"><a href="#4-Sample-Workbooks" class="headerlink" title="4. Sample Workbooks"></a>4. Sample Workbooks</h3><p>Tableau 在這個窗格中提供精美的工作簿當範例樣本，例如：Superstore。直接點擊圖示開啟樣本即可瀏覽或修改其中的內容，方便我們以臨摹的方式學習做出屬於自己的儀表板。</p>
<h3 id="5-Icon"><a href="#5-Icon" class="headerlink" title="5. Icon"></a>5. Icon</h3><p>此 Icon 為一個按鈕，讓我們可以在工作表與開始畫面中來回切換。</p>
<h2 id="切換語言"><a href="#切換語言" class="headerlink" title="切換語言"></a>切換語言</h2><p>Tableau 在語言方面的支援度還算不錯，可以將介面改為繁體中文，但個人習慣使用英文介面，一方面是若遇到問題較容易知道該用來查詢的關鍵字，另一方面是使用原文教學搭配實際操作時容易對應。可依個人喜好選擇介面的語言，修改語言介面的操作方式為 <code>Help → Choose Language</code>，再選擇所要的語言並重新啟動 Tableau Desktop，完成變更語言</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay07-%E9%96%8B%E5%A7%8B%E7%95%AB%E9%9D%A2%2Ftableau_language.png?alt=media&amp;token=1ab21e76-6177-4d0c-87f1-0b91b996cb91" alt="切換語言"><span class="image-caption">切換語言</span></p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>language</tag>
        <tag>connect</tag>
        <tag>open</tag>
        <tag>dicover</tag>
        <tag>sample</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day08] Tableau 輕鬆學 - 資料連線種類</title>
    <url>/2021/07/29/day08_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開始畫面中通常會使用到的是 Connect 窗格的功能，因此特別拿出來說明。在 Connect 窗格中我們可以建立與資料來源的連線設定，這裡說是連線，但我們可以把它想成是將資料匯入 Tableau Desktop，有了資料才能繼續後續的工作，例如：建立工作表與儀表板。</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay08-%E8%B3%87%E6%96%99%E9%80%A3%E7%B7%9A%E7%A8%AE%E9%A1%9E%2Ftableau_connect.png?alt=media&amp;token=c8e5c3d8-01d8-4dd6-a93f-4772a16d6e26" alt="連線種類"><span class="image-caption">連線種類</span></p>
<p>Connect 窗格分為四個子區塊</p>
<h3 id="1-Search-for-Data"><a href="#1-Search-for-Data" class="headerlink" title="1. Search for Data"></a>1. Search for Data</h3><p>若在指定的 Tableau Server 上有已經建立好且符合需求的資料來源，可以透過這個功能直接對 Tableau Server 連線，將該資料來源拿來使用。剛開始接觸 Tableau Desktop 的時候會用到此功能的機會比較少，所以可以將此功能列為進階功能，平常使用大多還是以 To a File 與 To a Server 為主。</p>
<h3 id="2-To-a-File"><a href="#2-To-a-File" class="headerlink" title="2. To a File"></a>2. To a File</h3><p>在這裡我們可以讓 Tableau Desktop 直接從文字檔讀取原始資料，文字檔包含多種格式，例如：Excel (<code>*.xls</code>/<code>*.xlsx</code>)、JSON、CSV 等，甚至是 PDF 檔案也可以當資料來源。</p>
<h3 id="3-To-a-Server"><a href="#3-To-a-Server" class="headerlink" title="3. To a Server"></a>3. To a Server</h3><p>在這裡我們可以透過直接與資料伺服器連線以取得原始資料。這裡的資料伺服器有很多種類型，例如：資料庫 (MySQL、SQL Server、PostgreSQL 等)、Google 雲端服務 (Ads、Analytics、BigQuery、Drive 等)，會在這個清單內的資料伺服器應該都算是熱門的服務。</p>
<h3 id="4-Saved-Data-Sources"><a href="#4-Saved-Data-Sources" class="headerlink" title="4. Saved Data Sources"></a>4. Saved Data Sources</h3><p>Tableau 在這個區塊中提供資料集樣板，一方面是可以配合官方的教程做為資料來源，一方面我們也可以拿來做想法測試或者概念 Demo。當手上沒有可用資料時，使用此資料來源來練習也是一種選擇。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>file</tag>
        <tag>data</tag>
        <tag>tableau</tag>
        <tag>connect</tag>
        <tag>source</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day09] Tableau 輕鬆學 - Data Source 頁面</title>
    <url>/2021/07/30/day09_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>若實作中遇到與資料來源有關的設定，會回到 Data Source 頁面來做調整，因此在進入實作階段之前，讓我們腳步緩一緩，先到 Data Source 頁面認識每個區塊的功用。</p>
<h2 id="Data-Source-頁面位置"><a href="#Data-Source-頁面位置" class="headerlink" title="Data Source 頁面位置"></a>Data Source 頁面位置</h2><p>由於我們手上沒有現成的資料，可以先使用 Tableau Desktop 在 Saved Data Sources 區塊提供的資料集 <code>Sample - Superstore</code> 來學習。</p>
<p>首先點擊 <code>Sample - Superstore</code> 開啟資料集，開啟後的 Tableau Desktop 畫面應該會直接跳到工作表 <code>Sheet 1</code>，點擊 Data Source 頁籤回到 Data Source 頁面</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay09-Data-Source-%E9%A0%81%E9%9D%A2%2Fdata_soruce.png?alt=media&amp;token=05240e1f-606d-4ba7-9a09-c257bbf16b89" alt="進入 Data Source 頁面"><span class="image-caption">進入 Data Source 頁面</span></p>
<h2 id="Data-Source-頁面說明"><a href="#Data-Source-頁面說明" class="headerlink" title="Data Source 頁面說明"></a>Data Source 頁面說明</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay09-Data-Source-%E9%A0%81%E9%9D%A2%2Fdata_source_page.png?alt=media&amp;token=d94f6df1-5b02-440a-9483-9fa8ee320180" alt="Data Source 頁面"><span class="image-caption">Data Source 頁面</span></p>
<p>目前只需要先知道五個部分</p>
<h3 id="1-Connections"><a href="#1-Connections" class="headerlink" title="1. Connections"></a>1. Connections</h3><p>這裡會顯示資料來源的連線說明，因為我們是直接開啟 <code>Sample - Superstore</code> 資料集，所以這裡會顯示該名稱，且可以觀察到名稱下方有一行小字 (Microsoft Excel)，代表最初的資料來源型式為 Excel。</p>
<h3 id="2-Sheets"><a href="#2-Sheets" class="headerlink" title="2. Sheets"></a>2. Sheets</h3><p>Tableau 會將 Excel 中的每一個 Sheet 對應到一個資料表物件，這裡有三個資料表物件是因為原本的 Excel 內有三個 sheet，且名稱分別叫做 Orders、People、Returns 。</p>
<h3 id="3-Logical-Layer"><a href="#3-Logical-Layer" class="headerlink" title="3. Logical Layer"></a>3. Logical Layer</h3><p>這裡會以圖形化方式來呈現每一個資料表之間的關係 (Relationship)，只要點擊連接線就可以看到更詳細的條件。例如：點擊上方連結線可以知道 Orders 與 People 兩張表之間的關係是使用雙方欄位 Region 來建立的</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay09-Data-Source-%E9%A0%81%E9%9D%A2%2Ftable_relationship.png?alt=media&amp;token=8f659726-c0a2-419e-85ca-836691de4eb5" alt="表與表之間關係"><span class="image-caption">表與表之間關係</span></p>
<h3 id="4-資料與欄位資訊"><a href="#4-資料與欄位資訊" class="headerlink" title="4. 資料與欄位資訊"></a>4. 資料與欄位資訊</h3><p>在這裡可以預覽每個資料表的內容，包含欄位標題、資料本身，Tableau 對於每個欄位的型態都是智慧感知的，因此我們不需特別指定欄位的型態。但若認為欄位型態感知錯誤，我們還是可以透過手動更改來修正</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay09-Data-Source-%E9%A0%81%E9%9D%A2%2Ftableau_field_type.png?alt=media&amp;token=766417e6-fa81-4c8a-8d0e-793be53fcaee" alt="更改欄位型態"><span class="image-caption">更改欄位型態</span></p>
<h3 id="5-上一步、下一步"><a href="#5-上一步、下一步" class="headerlink" title="5. 上一步、下一步"></a>5. 上一步、下一步</h3><p>這是對使用者來說最重要的功能！當我們在嘗試使用任何功能時總怕會因為無法復原導致做白工，但 Tableau 的上一步這個功能很厲害，無論我們前進了多少，它總能允許我們回到上一步，甚至回到最一開始開啟工作簿的情況，這樣的功能可以讓我們可以無後顧之憂，隨心所欲地進行資料探索。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>connection</tag>
        <tag>data</tag>
        <tag>next</tag>
        <tag>tableau</tag>
        <tag>source</tag>
        <tag>superstore</tag>
        <tag>sheet</tag>
        <tag>logical</tag>
        <tag>layer</tag>
        <tag>previous</tag>
        <tag>step</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day10] Tableau 輕鬆學 - Dimension 與 Measure</title>
    <url>/2021/07/31/day10_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tableau 將所有的資料欄位分成 Dimension (維度) 與 Measure (度量) 兩種角色，在實際設計工作表之前，需要先明白如何區分這兩個概念，在後續的製作中才能靈活地運用資料欄位。</p>
<h2 id="Dimension"><a href="#Dimension" class="headerlink" title="Dimension"></a>Dimension</h2><p>是指資料的屬性，例如：將班級中每一位學生視為一筆資料，每一筆資料都有 <code>性別</code> 這個屬性，其可能的值為 <code>男生</code> 或 <code>女生</code>，而這個 <code>性別</code> 屬性，就會被歸類在 Dimension 角色。</p>
<h2 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h2><p>度量 (白話文就是計算) 資料符合維度的方法，例如：班級中有多少個男同學與多少個女同學，其中計算同學數量的方法，就會被歸類在 Measure 角色。</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><div class="table-container">
<table>
<thead>
<tr>
<th>班級</th>
<th>性別</th>
<th>學生數</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 年 1 班</td>
<td>男生</td>
<td>21</td>
</tr>
<tr>
<td>1 年 1 班</td>
<td>女生</td>
<td>19</td>
</tr>
<tr>
<td>1 年 2 班</td>
<td>男生</td>
<td>17</td>
</tr>
<tr>
<td>1 年 2 班</td>
<td>女生</td>
<td>19</td>
</tr>
</tbody>
</table>
</div>
<p>表格中為 Dimension 的資料欄位有兩個，分別為 <code>班級</code> 與 <code>性別</code>，用這兩個屬性來描述資料；而 <code>學生數</code> 則是歸類到 Measure，是用來計算符合該資料屬性的特定運算式。以 <code>1 年 1 班</code> <code>男生</code> 來說，<code>學生數</code> 的運算方法是計算出符合 <code>班級</code> 為 <code>1 年 1 班</code> 且 <code>性別</code> 為 <code>男生</code> 的學生數量，這裡的結果是 21 個。</p>
<p>上方表格以 SQL 來說可以等效於</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 班級, 性別, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 班級, 性別</span><br></pre></td></tr></table></figure>
<p>其中 <code>班級</code> 與 <code>性別</code> 為做 <code>GROUP BY</code> 的屬性依據，而 <code>COUNT(*)</code> 是用來度量 <code>學生數</code> 的方法。</p>
<h2 id="分辨-Dimension-與-Measure"><a href="#分辨-Dimension-與-Measure" class="headerlink" title="分辨 Dimension 與 Measure"></a>分辨 Dimension 與 Measure</h2><p>Tableau Desktop 會在 Data 窗格顯示所有資料欄位，並將每個資料表的 Dimension 與 Measure 欄位用分隔線分開，分隔線的上方的資料為 Dimension、下方的資料為 Measure，方便使用者辨識</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay10-Dimension-%E8%88%87-Measure%2Fdimension_measure.png?alt=media&amp;token=d88dc768-fbf9-407a-a3f5-00149396d30f" alt="Tableau Desktop 中 Dimension 與 Measure"><span class="image-caption">Tableau Desktop 中 Dimension 與 Measure</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Dimension 與 Measure 的觀念在這邊帶給讀者，其實這兩個觀念與 Google Analytics 之中的 Dimensions 與 Metrics 非常類似。在弄懂原理並且知道如何區別之後，對於操作 Tableau Desktop 將會有一定的幫助。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>tableau</tag>
        <tag>dimension</tag>
        <tag>measure</tag>
        <tag>analytics</tag>
        <tag>metrics</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day11] Tableau 輕鬆學 - Workbook／Worksheet／Dashboard／Story</title>
    <url>/2021/08/01/day11_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>檔案架構是在開發前應該要先了解的事，可以讓我們在對的地方做對的事情，以節省寶貴的時間。主要有四個名詞需要學習：Workbook、Worksheet、Dashboard 與 Story。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay11-Workbook-Worksheet-Dashboard-Story%2Fworkbook_3.png?alt=media&amp;token=9bea076f-5ca3-497f-8990-f4e965d286f3" alt="Workbook 與 Worksheet、Dashboard、Story 的關係"><span class="image-caption">Workbook 與 Worksheet、Dashboard、Story 的關係</span></p>
<h2 id="1-Workbook"><a href="#1-Workbook" class="headerlink" title="1. Workbook"></a>1. Workbook</h2><p>中文為工作簿，指的是 Tableau Desktop 存成副檔名為 twb (Tableau Workbook) 的檔案。</p>
<p>若情況允許，當我們在 Tableau 社群平台上發問時，會將可公開的 twb 檔案當做問題的附件一起上傳，目的是讓其他人可以下載參考，因為查看原始的 twb 檔案有助於其他人快速了解我們所描述的問題點 (描述得夠清楚的話)，也方便直接在該檔案內測試解決方案，不需要浪費太多時間在發問者與回答者之間來回猜測或確認各種可能性，更好心的人會直接回覆一個修改過的 twb 檔案，讓我們能夠直接觀摩學習。</p>
<p>認識 Workbook 之後，剩下三個名詞 Worksheet、Dashboard 與 Story，這三個是在 Workbook 檔案裡面的三種不同物件</p>
<h2 id="2-Worksheet"><a href="#2-Worksheet" class="headerlink" title="2. Worksheet"></a>2. Worksheet</h2><p>中文為工作表，一個工作表只能製作單一圖表，若想要多個不同圖表，只能新增多個工作表來製作。是在 Tableau Desktop 中最常使用的，為工作簿的基本單位。</p>
<h2 id="3-Dashboard"><a href="#3-Dashboard" class="headerlink" title="3. Dashboard"></a>3. Dashboard</h2><p>中文為儀表板，由一至多個工作表組合而成，可讓多個工作表在同一個畫面中一起互動，使呈現方式多樣化。</p>
<h2 id="4-Story"><a href="#4-Story" class="headerlink" title="4. Story"></a>4. Story</h2><p>中文為故事，由一至多個工作表或儀表板組合而成，效果如同投影片一樣，常用來呈現資料背後的故事，方便展示從數據中所觀察到的重要資訊。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>workbook</tag>
        <tag>worksheet</tag>
        <tag>dashboard</tag>
        <tag>story</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day12] Tableau 輕鬆學 - 長條圖工作表</title>
    <url>/2021/08/02/day12_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到目前為止，我們已經積累一定的基礎概念，例如：資料型態、資料角色、檔案架構等等，因此可以提升到從實作中學習的階段。這篇文章會以實作長條圖工作表作為範例說明，從中學習設計圖表的流程與體會簡單的資料探索過程。</p>
<h2 id="銷售額年度趨勢"><a href="#銷售額年度趨勢" class="headerlink" title="銷售額年度趨勢"></a>銷售額年度趨勢</h2><p><code>Sample - Superstore</code> 是一個 Tableau 提供的虛擬商場銷售額相關資料，主要做為練習與示範的資料來源，讓我們不需要額外尋找資料，非常適用於像是現在這種技術分享文。</p>
<p>首先，我們想要知道銷售額隨著年度的增減趨勢，直覺地將 <code>Sales</code> 欄位與 <code>Order Date</code> 欄位分別拖曳到 <code>Rows</code> 與 <code>Columns</code>，Tableau Desktop 會幫我們找一個最適合目前資料的圖表，在這個情況中是以折線圖顯示。當然，我們也可以依自己的需求在 <code>Marks</code> 選項卡中變更顯示圖表，這裡我們將圖表改為 Bar，也就是長條圖</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fsale_order_date_change_chart.png?alt=media&amp;token=5a91c91a-5e2a-45ba-ab08-16f94f430173" alt="銷售額隨著年度的增減趨勢"><span class="image-caption">銷售額隨著年度的增減趨勢</span></p>
<div class="tabs" id="說明"><ul class="nav-tabs"><li class="tab"><a href="#說明-1">YEAR(Order Date)</a></li><li class="tab"><a href="#說明-2">SUM(Sales)</a></li><li class="tab active"><a href="#說明-3">-</a></li></ul><div class="tab-content"><div class="tab-pane" id="說明-1"><p><code>Order Date</code> 欄位被自動加上 <code>YEAR()</code> 函數，主要是因為 Tableau Desktop 對於日期型態的欄位可以幫忙細分為年/季/月/日，若將 <code>YEAR(Order Date)</code> 前方符號 <code>+</code> 點開，能更明白這裡的意思</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fyear_quarter_month.png?alt=media&amp;token=42ed48d0-e385-4351-98d9-f35cafbcea5b" alt="年/季/月"><span class="image-caption">年/季/月</span></p></div><div class="tab-pane" id="說明-2"><p><code>Sales</code> 欄位被自動加上 <code>SUM()</code> 函數，指的是將該年份的銷售額全部加總起來，當然還有提供其他函數 (例如：Average、Median 等)，只需要點擊 <code>SUM(Sales)</code> 右邊箭頭即可修改</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fsum_sales.png?alt=media&amp;token=b85ca74f-9e1c-43dc-8142-d6d23ddea116" alt="修改函數"><span class="image-caption">修改函數</span></p></div><div class="tab-pane active" id="說明-3"></div></div></div>
<h2 id="各項產品銷售額"><a href="#各項產品銷售額" class="headerlink" title="各項產品銷售額"></a>各項產品銷售額</h2><p>現在，我們已經做出年度銷售額長條圖，得知銷售額趨勢為近乎每年遞增，但由於資料粒度過低，無法得到更多的有用資訊，所以我們需要檢視資料粒度更大一點的視圖看是否能找出端倪。將 <code>Category</code> 欄位拖曳到 <code>Columns</code> 中 <code>YEAR(Order Date)</code> 的右邊，再點擊 <code>+</code>，讓資料粒度到 <code>Sub-Category</code> 層級，查看每一年、每一種產品的銷售情形，</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fcategory_sub_category.png?alt=media&amp;token=833cee3e-3211-43c1-9fda-e1e85982ed45" alt="每種產品銷售情形"><span class="image-caption">每種產品銷售情形</span></p>
<h2 id="產品銷售額與利潤"><a href="#產品銷售額與利潤" class="headerlink" title="產品銷售額與利潤"></a>產品銷售額與利潤</h2><p>這樣的報表還是無法提供有用的資訊，因為我們心中知道不是有銷售額就一定會賺錢，還是需要搭配利潤的資訊來觀察。我們可以利用 Tableau Desktop 提供的功能，讓每個資料點根據 <code>Profit</code> 欄位的數值染色，只要將 <code>Profit</code> 欄位拖曳至 <code>Marks</code> 選項卡中的 <code>Color</code> 即可做到這樣的效果</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fprofit_color.png?alt=media&amp;token=5347c7f6-0d9b-4ace-b7b7-c728177a3122" alt="銷售與利潤"><span class="image-caption">銷售與利潤</span></p>
<h2 id="區域產品銷售額與利潤"><a href="#區域產品銷售額與利潤" class="headerlink" title="區域產品銷售額與利潤"></a>區域產品銷售額與利潤</h2><p>圖表現在清楚多了，觀察到雖然 Tables、Bookcases 等有不低的銷售額，但卻是虧錢的 (利潤為負，長條圖呈現偏橘色)。將 <code>Region</code> 欄位拖曳到 <code>Rows</code> 中 <code>SUM(Sales)</code> 的左邊，看看哪些區域賣的 Tables 與 Bookcases 是虧錢的</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fregion_sales.png?alt=media&amp;token=30b16dda-e4ea-4197-9685-69bce4627b27" alt="分區銷售與利潤"><span class="image-caption">分區銷售與利潤</span></p>
<p>發現其實不只是 Tables 與 Bookcases，其實連 Machines 與 Binders 都有地方雖然銷售額高但是虧錢，這是一個新發現！最後將工作表更名為 <code>區域產品銷售額與利潤</code> 並存檔 (<code>.twb</code>)。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>到目前為止，我們沒有寫到一行程式，只需要短短幾分鐘，就能從大量數據中挖掘到這項重要發現，以這個小小的例子來讓讀者體會 Tableau Desktop 將資料視覺化的便利性。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay12-%E9%95%B7%E6%A2%9D%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fday12_tableau.twb?alt=media&token=2c0265e0-e660-49b8-8212-e964dacf4910" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>superstore</tag>
        <tag>worksheet</tag>
        <tag>bar</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day13] Tableau 輕鬆學 - Rows 與 Columns</title>
    <url>/2021/08/03/day13_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道讀者們在實作長條圖工作表的時候，心裡有沒有冒出一些疑惑。「為什麼放在 Rows 的欄位顯示出來是這個方向？」、「為什麼放在 Columns 的欄位又是那樣的方向？」、「怎麼好像跟我所知道 Row 與 Column 的方向不太一樣？」有這些疑問是正常的，這裡特意獨立出一篇文章來釐清 Rows 與 Columns 的概念。</p>
<h2 id="描述問題"><a href="#描述問題" class="headerlink" title="描述問題"></a>描述問題</h2><p>Column 與 Row 中文分別為行與列，我們常說的直行橫列，就是指說在圖表中直的是 Column，而橫的是 Row。但是為什麼在 Tableau Desktop 實作工作表的時候，這兩個方向好像相反過來了？</p>
<p>以下圖來看，明明 <code>Region</code> 與 <code>Sales</code> 欄位是放在 Rows，但卻像藍色框線所框起來的一樣，是直向的；而 <code>Order Date</code>、<code>Category</code> 與 <code>Sub-Category</code> 欄位是放在 Columns，卻是像綠色框線以橫向方式的呈現。跟我們所認知的直行橫列好像有些出入</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay13-Rows-%E8%88%87-Columns%2Frow_column_wrong.png?alt=media&amp;token=0bc4cbef-2603-45e7-82a5-d955c23721c3" alt="問題具象化"><span class="image-caption">問題具象化</span></p>
<h2 id="Rows-與-Columns-概念釐清"><a href="#Rows-與-Columns-概念釐清" class="headerlink" title="Rows 與 Columns 概念釐清"></a>Rows 與 Columns 概念釐清</h2><p>會有這樣的疑惑是很正常的，因為我們被自己直觀的想法所蒙騙了，回想看看在高中學習矩陣的時候，Row 與 Column 是用來指出數據的所在位置。在 Tableau Desktop 中 Rows 與 Columns 的功用也是一樣的，用來描述數據的位置，不同的是這裡可以用多個欄位來描述，因此在字尾會多加 <code>s</code>。</p>
<p>因此我們應該以資料的角度出發來解讀 Rows 與 Columns，以下圖同時被綠色框線與藍色框線框住的資料點來說，可以用兩個條件定位出它的位置</p>
<ol>
<li>Rows 滿足 <code>Region=South</code> 且 <code>SUM(Sales)=27595</code></li>
<li>Columns 滿足 <code>YEAR(Order Date)=2017</code> 且 <code>Category=Technology</code> 且 <code>Sub-Category=Machines</code></li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay13-Rows-%E8%88%87-Columns%2Frow_column_cross.png?alt=media&amp;token=b3750a58-d393-4674-b3c8-8c4505f21f28" alt="正確解讀方式"><span class="image-caption">正確解讀方式</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>若原本對於 Rows 與 Columns 顯示方式有疑惑的讀者，要將觀念弄懂並銘記在心，Rows 與 Columns 是用來描述數據的位置，這裡再次提醒。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>row</tag>
        <tag>column</tag>
        <tag>display</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day14] Tableau 輕鬆學 - 美化工作表外觀</title>
    <url>/2021/08/04/day14_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相對於數據視覺化操作，官方在外觀調整的教學算是較少，或許難下關鍵字也是一個問題。平常在實作的時候，最困擾的卻也總是美化外觀的部分，對於不熟悉的人來說難以找到相對應的設定，這裡會分享幾個剛開始使用 Tableau Desktop 時不容易找到，但個人常常會用到的外觀設定。</p>
<h2 id="字型"><a href="#字型" class="headerlink" title="字型"></a>字型</h2><p>在 Menu 中 <code>Format → Font</code>，可以針對整個工作表 (Sheet) 做字形設定，或者只針對 Rows 或 Columns 的字形各別微調</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Ffont.png?alt=media&amp;token=48bc9dd4-7143-4929-b7f6-5997d831434d" alt="字型設定"><span class="image-caption">字型設定</span></p>
<h3 id="Worksheet"><a href="#Worksheet" class="headerlink" title="Worksheet"></a>Worksheet</h3><p>調整這裡就等同於同時調整 Pane 與 Header。</p>
<h3 id="Pane"><a href="#Pane" class="headerlink" title="Pane"></a>Pane</h3><p>指的是顯示在工作表中的數據文字。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>指的是 Rows 與 Columns 的標題。</p>
<h3 id="Tooltip"><a href="#Tooltip" class="headerlink" title="Tooltip"></a>Tooltip</h3><p>當我們將鼠標移到某個資料點上，會顯示出提示視窗，而這裡指的就是提示視窗中的文字。</p>
<h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><p>工作表本身的標題，標題預設的位置在工作表的最上面。</p>
<p>光用文字難以說得清楚，這裡直接幫忙在工作表中標記出來方便對應，通常我都是調整 Worksheet、Tooltip 與 Title 字型</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Ftitle_header_pan_tooltip.png?alt=media&amp;token=44d04770-cf1f-4ea4-a06c-2ca7f1db34ef" alt="名稱所對應區域"><span class="image-caption">名稱所對應區域</span></p>
<h2 id="陰影"><a href="#陰影" class="headerlink" title="陰影"></a>陰影</h2><p>在 Menu 中 <code>Format → Shading</code>，與字型設定相同，可以針對整個工作表 (Sheet) 設定，或者只針對 Rows 或 Columns 的陰影各別微調</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Fshading.png?alt=media&amp;token=bca584f6-1b59-478b-8c06-c92947bca430" alt="陰影設定"><span class="image-caption">陰影設定</span></p>
<p>這裡的 Pane 與 Header 含意與字形設定是一樣的，只是這裡是在設定背景顏色。要特別介紹的是 Banding，它可以讓顏色交錯顯示，使圖表不至於太單調，直接實際操作會比較容易了解，這裡以 Row Banding 來做示範，與 Column Banding 的概念可以互通</p>
<h3 id="Band-Size-in-Row-Banding"><a href="#Band-Size-in-Row-Banding" class="headerlink" title="Band Size in Row Banding"></a>Band Size in Row Banding</h3><p>當 Band Size 設為 1 (最左邊刻度為 0)，代表每 1 個 Row 被視為 1 個 Band 來上背景色，設為 2 則視每 2 個 Row 為 1 個 Band，效果如下</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Fband_size.png?alt=media&amp;token=e54701a0-400b-4088-913a-c9022ddece20" alt="Band Size 1 (左) vs Band Size 2 (右)"><span class="image-caption">Band Size 1 (左) vs Band Size 2 (右)</span></p>
<h3 id="Level-in-Row-Banding"><a href="#Level-in-Row-Banding" class="headerlink" title="Level in Row Banding"></a>Level in Row Banding</h3><p>Level 可調整的範圍會隨著 Rows 中的欄位數量變動，像是在這個範例中 Rows 有 <code>Region</code> 與 <code>SUM(Sales)</code> 兩個欄位，對應到 Level 就會有兩個刻度。刻度解讀是這樣的：「Header 背景要上色的範圍，是從 Rows 中最右邊的欄位到刻度所指定的欄位。」例如 Rows 中最右邊的欄位為 <code>SUM(Sales)</code> 且刻度在 <code>Region</code> 欄位，因此 <code>Region</code> 與 <code>Sales</code> 兩個欄位的 Header 背景都會被上色</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Flevel.png?alt=media&amp;token=8befdb67-ae70-4f81-aa93-79693fd20eca" alt="Sales Header Only (左) vs Range From Region to Sales Header (右)"><span class="image-caption">Sales Header Only (左) vs Range From Region to Sales Header (右)</span></p>
<h2 id="標題陰影"><a href="#標題陰影" class="headerlink" title="標題陰影"></a>標題陰影</h2><p>工作表標題的陰影設定與一般的陰影設定位置不同，這也是在美化外觀時覺得很困擾的地方，明明都是陰影的設定，卻要在另外一個地方才能設定，而不像字型一樣，一個畫面能設定所有相關的功能。若沒使用過的功能，會不知道是不是要到其他畫面設定，或者是真的無法做到</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Ftitle_shadowing.png?alt=media&amp;token=bdb4bd45-ef5a-46d8-b9b0-d23bd79827b3" alt="標題陰影設定"><span class="image-caption">標題陰影設定</span></p>
<h2 id="圖例"><a href="#圖例" class="headerlink" title="圖例"></a>圖例</h2><p>在 <code>區域產品銷售額與利潤</code> 工作表中我們有一個圖例 <code>SUM(Profit)</code>，由於它本身擁有正值與負值，所以 Tableau Desktop 預設會以 <code>Orange-Blue Diverging</code> 做染色，若偏橘色代表 <code>SUM(Profit)</code> 為負，非常容易辨識。除了接受這個預設，我們可以根據需求調整它的顏色，在 <code>SUM(Profit)</code> 圖例卡中點擊向下箭頭並選擇 <code>Edit Colors...</code>，其中已經有多個顏色組合讓我們挑選，若都不滿意還可以自訂顏色</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Fcolor.png?alt=media&amp;token=c192695e-d66a-489b-b76e-3d55883d7d21" alt="圖例顏色設定"><span class="image-caption">圖例顏色設定</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這裡介紹的是一些常使用但不容易找到的外觀設定功能，同時標註出相對應的位置省去自己摸索的時間。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay14-%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%A4%96%E8%A7%80%2Fday14_tableau.twb?alt=media&token=62aaadc1-2c67-4058-a4ec-d29741a0b51a" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>worksheet</tag>
        <tag>art</tag>
        <tag>prettify</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day16] Tableau 輕鬆學 - 儀表板</title>
    <url>/2021/08/06/day16_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們目前完成了兩個工作表的製作，再來就是要學習如何讓多個工作表可以一起互動，而儀表板的功能就是將多個工作表放在同一個畫面，使工作表能夠交互作用，更容易闡述從資料得到的觀點，因此這裡會分享如何建立儀表板。</p>
<h2 id="新增儀表板"><a href="#新增儀表板" class="headerlink" title="新增儀表板"></a>新增儀表板</h2><p>點擊 <code>New Dashboard</code> 新增一個儀表板</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fnew_dashboard.png?alt=media&amp;token=5d7825f4-f31e-4e81-899f-f2fb0b29e6e3" alt="新增儀表板"><span class="image-caption">新增儀表板</span></p>
<p>第一步先修改儀表板尺寸，通常是設定 <code>Automatic</code> 讓 Tableau Desktop 替我們自動適應可視空間，若有需求也可以自定義儀表板大小</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fautomatic_size.png?alt=media&amp;token=c8b4c7a3-26f0-453d-b9d9-95a0f74d8c72" alt="儀表板自適應大小設定"><span class="image-caption">儀表板自適應大小設定</span></p>
<p>再將工作表拖曳到儀表板中，<code>州年度利潤地圖</code> 與 <code>區域產品銷售額與利潤</code> 分別放置於儀表板的上半部與下半部</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fdashboard_add_worksheet.png?alt=media&amp;token=52aa10bf-d6a5-4f47-ba6d-7d04f7a0d9eb" alt="加入工作表"><span class="image-caption">加入工作表</span></p>
<h2 id="套用篩選器"><a href="#套用篩選器" class="headerlink" title="套用篩選器"></a>套用篩選器</h2><p>當我們調整篩選器 <code>Year of Order Date</code> 的時候，發現只有 <code>州年度利潤地圖</code> 會變動，而 <code>區域產品銷售額與利潤</code> 始終不動，這是因為我們在設計 <code>區域產品銷售額與利潤</code> 工作表的時候沒有套用這個篩選器，因此要指定該工作表使用這個篩選器，才能隨篩選器的值一起變動</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fset_filter.png?alt=media&amp;token=a53588e5-4596-491c-8f01-de9deea91783" alt="套用篩選器"><span class="image-caption">套用篩選器</span></p>
<h2 id="將工作表做為篩選器"><a href="#將工作表做為篩選器" class="headerlink" title="將工作表做為篩選器"></a>將工作表做為篩選器</h2><h3 id="自動設定"><a href="#自動設定" class="headerlink" title="自動設定"></a>自動設定</h3><p>將工作表做為篩選器是儀表板中，讓工作表互動很關鍵的一步，點選要在儀表板中做為篩選器來源的工作表 (此為 <code>州年度利潤地圖</code>)，點擊漏斗的圖案開啟此功能</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fworksheet_as_filter.png?alt=media&amp;token=85aaf6b0-e3d1-42af-acf0-d452d4c07af2" alt="將工作表做為篩選器"><span class="image-caption">將工作表做為篩選器</span></p>
<p>這樣當我們在 <code>州年度利潤地圖</code> 中任意點擊一個州，<code>區域產品銷售額與利潤</code> 就會顯示該州的銷售額與利潤，如此一來就能清楚的顯示每個州的利潤明細</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fclick_state.png?alt=media&amp;token=4601ac00-83d4-43f4-bf7a-0df948ebb9c9" alt="工作表互動"><span class="image-caption">工作表互動</span></p>
<p>最後，將此儀表板命名為 <code>州利潤明細</code>。</p>
<h3 id="手動設定"><a href="#手動設定" class="headerlink" title="手動設定"></a>手動設定</h3><p>有的時候自動設定 <code>將工作表做為篩選器</code> 會因為某些原因導致 Tableau Desktop 誤判要篩選的欄位，導致工作表沒有連繫在一起，進而無法像我們想像中的運作。這時可以透過手動設定達到相同的效果，若想要測試此功能，可以先將 <code>州年度利潤地圖</code> 的漏斗關閉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fmanual_as_filter.png?alt=media&amp;token=4db22365-e4c8-42a9-8918-ae483a9ef65f" alt="手動設定將工作表設為篩選器"><span class="image-caption">手動設定將工作表設為篩選器</span></p>
<p>手動設定的主要概念就是當 Source Sheets (<code>州年度利潤地圖</code>) 被 Select (點擊) 時 State 欄位的值會發生變化，Target Sheets (<code>區域產品銷售額與利潤</code>) 的 State 欄位的值也隨之變化。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay16-%E5%84%80%E8%A1%A8%E6%9D%BF%2Fday16_tableau.twb?alt=media&token=67fe38cf-a999-4731-852d-bb1e390c2089" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>dashboard</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day15] Tableau 輕鬆學 - 地圖工作表</title>
    <url>/2021/08/05/day15_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們已經學會使用長條圖來做資料探索。然而，Tableau Desktop 除了長條圖外，還有其他有趣的圖表可以使用，地圖就是其中一種，這裡分享如何使用地圖圖表來將數據視覺化。</p>
<h2 id="地圖圖表"><a href="#地圖圖表" class="headerlink" title="地圖圖表"></a>地圖圖表</h2><p>我們先前已經製作了一個 <code>區域產品銷售額與利潤</code> 工作表，並加以美化。接下來我們想知道每個州每年的獲利情況，點擊 <code>New Worksheet</code>，開啟一個新的工作表</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fnew_worksheet.png?alt=media&amp;token=0bff1b0b-ae22-4a23-bc12-218ed0df8843" alt="新增工作表"><span class="image-caption">新增工作表</span></p>
<p>雙擊 <code>State</code> 欄位，由於 <code>State</code> 為地理屬性 (欄位名稱前方有一個小地球)，Tableau Desktop 預設會幫我們以地圖的方式顯示出來，這裡的經緯度是由 Tableau Desktop 自動產生的，因此可以準確地將數據標註在地圖上 (每個州對應一個資料點)。但正常來說，若我們經手的資料有顯示在地圖上的需求，通常會要求資料自己本身帶有經緯度資訊</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fmap_init.png?alt=media&amp;token=8e32142f-2aae-4b16-95a3-f5b01e0901b7" alt="每個州對應一個資料點"><span class="image-caption">每個州對應一個資料點</span></p>
<h2 id="州年度利潤地圖"><a href="#州年度利潤地圖" class="headerlink" title="州年度利潤地圖"></a>州年度利潤地圖</h2><p>我們的目標是知道每個州每年的獲利情況，因此以 <code>Profit</code> 作為上色依據，將其拖曳至 <code>Marks</code> 選項卡中的 <code>Color</code>，再把 <code>Profit</code> 與 <code>Profit Ratio</code> 兩個欄位拖曳至 <code>Marks</code> 選項卡中的 <code>Label</code>，<code>Label</code> 會將對應到的值標註於圖表中，讓使用者一眼能看出利潤與利潤率</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fstate_profit.png?alt=media&amp;token=53a82dfa-cbf3-4d22-9d09-892216baee08" alt="利潤與利潤率"><span class="image-caption">利潤與利潤率</span></p>
<p>再對著 <code>Order Date</code> 點擊右鍵選擇 <code>Show Filter</code> 來加上年度篩選器，Tableau Desktop 會自動在 <code>Filters</code> 選項卡中自動加上 <code>YEAR(Order Date)</code> 並且將其顯示在工作表的最右方，預設篩選器形式為複選清單 <code>Multiple Value (list)</code>，這裡我們將其改為單值滑動的方式 <code>Single Value (slider)</code>。完成後，我們就可以透過這個篩選器來選擇想要查看的年度</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Forder_date_filter.png?alt=media&amp;token=d67aa612-cb26-4842-b974-198a04acad85" alt="YEAR(Order Date) 篩選器"><span class="image-caption">YEAR(Order Date) 篩選器</span></p>
<p>我們發現地圖上的利潤率並不是以百分比來顯示，有點不太直覺。這個顯示格式是可以調整的，右鍵點擊 <code>AGG(ProfitRatio)</code> 並選擇 <code>Format</code>，將 <code>Numbers</code> 設定為 <code>Percentage</code> 格式，利潤率就會以百分比顯示，若不想要小數點後的位數，也可以將 <code>Decimal places</code> 設為 0</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fpercentage.png?alt=media&amp;token=fa926274-d62f-4772-b4ac-6270e619351c" alt="百分比格式設定"><span class="image-caption">百分比格式設定</span></p>
<p>最後，將此工作表命名為 <code>州年度利潤地圖</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fstate_year_profit.png?alt=media&amp;token=501fa0dc-1829-4d48-ada9-b60e42a2ff93" alt="州年度利潤地圖"><span class="image-caption">州年度利潤地圖</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>到目前為止，工作簿內含有兩個工作表，分別為 <code>區域產品銷售額與利潤</code> 與 <code>州年度利潤地圖</code>。同樣地，我們也可以幫 <code>州年度利潤地圖</code> 工作表修改樣式，就留給讀者自由發揮。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay15-%E5%9C%B0%E5%9C%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%2Fday15_tableau.twb?alt=media&token=596f8378-0805-4877-b5ef-3d077dd69763" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>map</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day17] Tableau 輕鬆學 - 美化儀表板外觀</title>
    <url>/2021/08/07/day17_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>儀表板同樣也可以進行外觀美化設定，這裡要特別注意的是只能針對儀表板的樣式做設定，而不能針對單一工作表的樣式，若對某個工作表內的樣式不滿意，就應該回到對應的工作表內去修改。</p>
<h2 id="顯示標題"><a href="#顯示標題" class="headerlink" title="顯示標題"></a>顯示標題</h2><p>要顯示儀表板的標題挺簡單的，但個人在第一次製作 Dashboard 的時候找非常久，所以還是介紹一下如何設定。在左下角可以看到 <code>Show dashboard title</code>，勾選後會在最上方顯示儀表板的名稱</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Fdashboard_title.png?alt=media&amp;token=1b2a4a50-a5e0-442f-854c-8571470adef1" alt="儀表板標題"><span class="image-caption">儀表板標題</span></p>
<h2 id="標題樣式"><a href="#標題樣式" class="headerlink" title="標題樣式"></a>標題樣式</h2><p>標題樣式的設定可在標題上點擊右鍵，選擇 <code>Edit Title...</code> 或 <code>Format Title...</code> 來設定</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Fdashboard_title_format.png?alt=media&amp;token=4871eb0c-585c-4f71-a356-8b284be7eea0" alt="儀表板標題樣式設定"><span class="image-caption">儀表板標題樣式設定</span></p>
<ul>
<li>Edit Title：可以設定文字的顏色、粗細與位置 (置左/中/右)。</li>
<li>Format Title：可以設定在 Edit Title 能設定的樣式，還能另外設定背景顏色、框線等。</li>
</ul>
<h2 id="框線"><a href="#框線" class="headerlink" title="框線"></a>框線</h2><p>點擊想要添加框線的物件 (工作表、篩選器、圖像 等)，在 <code>Layout</code> 頁籤的 <code>Border</code> 選項可以設定物件的框線樣式，</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Fborder.png?alt=media&amp;token=8a2ec11d-8045-46cb-9a02-2a60471a8745" alt="工作表物件加上邊框"><span class="image-caption">工作表物件加上邊框</span></p>
<h2 id="物件排版"><a href="#物件排版" class="headerlink" title="物件排版"></a>物件排版</h2><p>所有在儀表板的物件都可以移動它的位置，這裡我們將 <code>Profit</code> 圖例拖曳到 <code>區域產品銷售額與利潤</code> 的正下方，且將 <code>Year of Order Date</code> 篩選器更改為浮動，放置在 <code>州年度利潤地圖</code> 空白處</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Ffloating.png?alt=media&amp;token=e177586f-5cf4-4162-bd02-a0d1efe84247" alt="移動圖例與篩選器"><span class="image-caption">移動圖例與篩選器</span></p>
<p>完成的畫面以視覺感受來說會更加緊密，充分利用每一處角落，讓畫面不會有太多空白</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Ffloated.png?alt=media&amp;token=f9a9bbf2-821f-4699-8a0f-2d3380b64ba3" alt="結果"><span class="image-caption">結果</span></p>
<h2 id="圖像物件"><a href="#圖像物件" class="headerlink" title="圖像物件"></a>圖像物件</h2><p>加上圖像的理由有很多，可以放上 Logo 或者 QR Code 讓檢視者可以額外查看更多的資訊。在儀表板左下角可以看到 <code>Objects</code> 區域，這裡包含所有可手動加入的物件，先選擇 <code>Floating</code> 讓接下來要加上的物件以浮動方式顯示，再將 <code>Image</code> 物件拖曳到理想的位置，會自動跳出 <code>Edit Image Object</code> 視窗設定圖像物件，這裡允許使用實體檔案，也允許輸入對應的 URL 顯示網路上的圖像，依自己的需求來做使用</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Fimage.png?alt=media&amp;token=1f80be47-9d4b-4b99-abc8-f42f38372427" alt="圖像物件"><span class="image-caption">圖像物件</span></p>
<p>設定中還有其中有兩個 Options 可以勾選，這裡以文字與圖像化方式來做說明，最後還是依自己喜好做選擇</p>
<ul>
<li>Fit Image：讓圖像隨著 <code>Image Object</code> 大小變化。</li>
<li>Center Image：讓圖可以置中。</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Ffit_ceneter_image.png?alt=media&amp;token=094a627a-5c66-416c-aaea-4f2952213a00" alt="Fit Image &amp; Center Image"><span class="image-caption">Fit Image &amp; Center Image</span></p>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Ffinish.png?alt=media&amp;token=2b4c5057-00fa-4fd4-bfc8-1b62ea76ae3f" alt="成品"><span class="image-caption">成品</span></p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay17-%E7%BE%8E%E5%8C%96%E5%84%80%E8%A1%A8%E6%9D%BF%E5%A4%96%E8%A7%80%2Fday17_tableau.twb?alt=media&token=22d098b0-cb84-4db3-8ee5-34f1762f62c3" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>dashboard</tag>
        <tag>prettify</tag>
        <tag>style</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day18] Tableau 輕鬆學 - Relationships 與 Joins</title>
    <url>/2021/08/08/day18_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們在實作中學會如何建立工作表與儀表板，並在儀表板中讓多個工作表可以連動，使資料呈現方式多樣化。現在，讓我們停下腳步，回過頭來學習如何將匯入的多個資料表關聯起來，這是資料視覺化流程中最一開始的工作。在 Tableau Desktop 中關連的方式分為 Relationships 與 Joins 兩種，這裡會分享這兩種關聯的差異與建立方式。</p>
<h2 id="Relationships"><a href="#Relationships" class="headerlink" title="Relationships"></a>Relationships</h2><p>Relationship 為表與表之間的關係，當我們將其中一張表拿來做視覺化，另外張表會根據這裡設定的 Relationship 來提供相對應數據。設定 Relationship 時，我們只需提供關係欄位 (可以多個欄位)，Tableau Desktop 會感知關聯類型，不需要我們親自指定。</p>
<div class="note info">
            <p>官方建議使用 Joins 之前，先嘗試使用 Relationships 來建立關聯。</p>
          </div>
<h3 id="建立-Relationships"><a href="#建立-Relationships" class="headerlink" title="建立 Relationships"></a>建立 Relationships</h3><p>我們同樣以 <code>Sample - Superstore</code> 為資料來源，開啟一個全新的 Tableau Desktop 工作簿並回到 Data Source 頁面，將 <code>Logical Layer</code> 中的三個資料表 (Orders、People、Returns) 全部移除，移除的方法很簡單，點擊資料表右鍵並選擇 Remove 即可移除</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay18-Relationships-%E8%88%87-Joins%2Fremove_sheets.png?alt=media&amp;token=e65bed47-8346-418a-99d6-00cfff212a2d" alt="移除 Logical Layer 中的資料表"><span class="image-caption">移除 Logical Layer 中的資料表</span></p>
<p>接下來我們要建立 Relationships，只需將資料表依照 Orders、People、Returns 順序拖曳到 <code>Logical Layer</code> 中，Tableau Desktop 會自動偵測表中的欄位，幫我們對應並以 Relationship 的方式關聯，當然我們也可以自己設定要用來關聯的欄位。完成之後，讀者可能會發現其實就跟剛開啟 <code>Sample - Superstore</code> 的 <code>Logical Layer</code> 長的一樣！沒錯，這裡只是利用這個範例來說明 <code>Relationships</code> 是如何建立起來的</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay18-Relationships-%E8%88%87-Joins%2Fcreate_relationships.png?alt=media&amp;token=aa366f01-ea9d-4184-82a8-2d4f1766b943" alt="建立 Relationships"><span class="image-caption">建立 Relationships</span></p>
<h2 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h2><p>Joins 是我們熟知的 <code>Inner Join</code>、<code>Left Join</code>、<code>Right Join</code> 與 <code>Full Outer Join</code> 的通稱，需要手動指定 Join 形式與 Join 欄位，Joins 會將所有參與 Join 關聯的資料表合併為一張資料表。</p>
<h3 id="建立-Joins"><a href="#建立-Joins" class="headerlink" title="建立 Joins"></a>建立 Joins</h3><p>首先讓 <code>Logical Layer</code> 只剩下 Orders 資料表，並左鍵雙擊 Orders 資料表，Orders 資料表會被展開並佔滿 <code>Logical Layer</code>，再拖曳 People 與 Returns 資料表至 <code>Logical Layer</code> 中的 Orders 資料表內，預設會以 <code>Inner Join</code> 方式來關聯，但我們可以點擊 Venn Diagram 來編輯關聯方式與關聯欄位</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay18-Relationships-%E8%88%87-Joins%2Fjoins.png?alt=media&amp;token=de43204c-7ca1-4481-9a04-edaff9895418" alt="建立 Joins"><span class="image-caption">建立 Joins</span></p>
<h2 id="Logical-Layer-顯示差異"><a href="#Logical-Layer-顯示差異" class="headerlink" title="Logical Layer 顯示差異"></a>Logical Layer 顯示差異</h2><p>最後，觀察 Relationships 與 Joins 在 <code>Logical Layer</code> 中的表示方法，Joins 的資料表在名稱前會有 Venn Diagram，且 3 張資料表 Join 完之後就會視為是一張表；而以 Relationships 對 3 張資料表做關聯，還是會分為獨立的 3 張資料表，只是這 3 張資料表彼此之間有了連接線，等同它們之間的 Relationship</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay18-Relationships-%E8%88%87-Joins%2Frelationship_vs_join.png?alt=media&amp;token=7a6c5dc4-99c5-4701-8a13-9f22fe1f6734" alt="Relationships (左) vs Joins (右)"><span class="image-caption">Relationships (左) vs Joins (右)</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>若 Relationships 與 Joins 都可以滿足關聯要求，會優先選擇 Relationships 來使用。還有一點要提醒的是，一個專案的資料表關聯並非只能 Relationships 與 Joins 擇一使用，Tableau Desktop 是允許這兩種關聯混用的，整體來說彈性非常高。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://help.tableau.com/v2020.4/pro/desktop/en-us/datasource_relationships_learnmorepage.htm">How Relationships Differ from Joins</a></li>
</ol>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>relationship</tag>
        <tag>join</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day19] Tableau 輕鬆學 - Data Extract</title>
    <url>/2021/08/09/day19_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每當我們修改工作表或者儀表板的時候，Tableau Desktop 會立即進行運算以顯示出對應的視圖，這樣的即時顯示對我們資料分析來說是非常加分的。但是，若遇到資料集有百萬甚至上千萬筆資料，每一步修改所造成的運算量是非常可觀的，有可能每修改一個地方就需要等待數分鐘甚至更久的時間才能看到結果，對於時間寶貴的我們來說，這是一個急需被解決的問題。因此，這裡分享如何使用 Data Extract 來緩解這樣的問題。</p>
<h2 id="Data-Extract"><a href="#Data-Extract" class="headerlink" title="Data Extract"></a>Data Extract</h2><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>Data Extract 能讓我們先從原本的資料集 (例如：資料庫) 中擷取資料放到 Tableau 自己的資料檔案 Hyper (<code>.hyper</code>)，Hyper 格式對大型資料集進行了優化，使 Tableau Desktop 可以透過快速資料引擎 (Fast Data Engine) 對存放於 Hyper 檔案中的資料集快速地進行查詢與分析處理，避免與資料集源頭直接連線。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 Data Source 頁面的右上角，會看到 Connection 區域有 <code>Live</code> 與 <code>Extract</code>，<code>Live</code> 指的是與資料源頭連線是即時的，所有的動作都是與資料源頭即時互動；而 <code>Extract</code> 就是我們所說的 Data Extract，會將資料集的資料先存一份到 Hyper 檔案中，之後的所有操作都是與 Hyper 檔案來做互動。這裡選擇 <code>Extract</code> 即可使用 Data Extract 的功能，若還需要進一步設定，可以點擊位於 <code>Extract</code> 右邊的 <code>Edit</code> 來做設定，通常會使用到的是 <code>Extract Filters</code>，讓我們可以在資料源頭就先過濾掉不需要的資料</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay19-Data-Extract%2Fextract_data.png?alt=media&amp;token=f4074766-5802-4db3-a1ae-eee679c4998b" alt="Data Extract 設定"><span class="image-caption">Data Extract 設定</span></p>
<p>當我們離開 Data Source 頁面時 (例如：切換到其他工作表或儀表板)，Tableau Desktop 會請我們選擇要存放 Hyper 檔案的路徑，成功儲存才能使用 Hyper 資料格式所帶來的種種好處</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay19-Data-Extract%2Fsave_hyper.png?alt=media&amp;token=dcc183f1-106d-4acc-9fee-49b10e81aa66" alt="儲存 Hyper 檔案"><span class="image-caption">儲存 Hyper 檔案</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>曾經遇過千萬筆的資料集，實作時是選擇 Live 與資料庫連線，導致每個步驟的修改都要等上一兩分鐘，後來向前輩請教才知道 Data Extract 的好處！分享這個好用的小秘訣給讀者。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>tableau</tag>
        <tag>extract</tag>
        <tag>hyper</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day20] Tableau 輕鬆學 - Calculated Field</title>
    <url>/2021/08/10/day20_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tableau Desktop 讓我們不用寫到一行程式就能進行資料探索，但不代表我們不能撰寫程式。我們可以利用 Tableau Desktop 所提供的函式，使資料探索的面向可以更廣泛，與 Excel 函式的概念有點類似。這裡會分享如何透過 Calculated Field 使用內建函式協助我們做運算。</p>
<h2 id="Calculated-Field"><a href="#Calculated-Field" class="headerlink" title="Calculated Field"></a>Calculated Field</h2><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>Calculated Field 是利用其他欄位資訊計算出來的資料欄位，讓我們可以使用內建的函式對資料集做運算，彌補原資料集缺少的資訊。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>這邊同樣以 <code>Sample - Superstore</code> 為例子，在資料集中沒有 <code>客戶數</code> 資訊，但我們可以自己新增一個 Calculated Field 來計算以取得這項資訊。在 Data 窗格中點擊右上方的向下箭頭，選擇 <code>Create Calculated Field...</code> 會跳出 Calculated Field 的編輯視窗</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Fcreate_calculated_field.png?alt=media&amp;token=816bbf2b-db5d-4331-8379-735569468708" alt="Create Calculated Field (左) &amp; 編輯視窗 (右)"><span class="image-caption">Create Calculated Field (左) &amp; 編輯視窗 (右)</span></p>
<p>在編輯窗視窗的右方會有函式列表，也允許輸入關鍵字進行查詢。這裡因為我們想要計算的是客戶數量，所以嘗試輸入 <code>COUNT</code>，查詢結果顯示有四個相關函式，其中我們只看 <code>COUNT</code> 與 <code>COUNTD</code>，旁邊有一段敘述來描述它們各自的功用，可以看出來它們的差異在 <code>COUNTD</code> 遇到相同的值只會算 1 次，這是我們想要的，因為是要計算有多少不同的客戶</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Fcount.png?alt=media&amp;token=d5188f1b-fdd1-4d75-a882-a70fb1dc52e1" alt="COUNT (左) &amp; COUNTD (右)"><span class="image-caption">COUNT (左) &amp; COUNTD (右)</span></p>
<p>若選擇好要使用哪個函式，直接左鍵雙擊該函式，會自動加到式窗左方的空白處。Tableau Desktop 很貼心的即時檢查我們的函式使用是否有誤，注意到視窗左下角出現 <code>The calculation contains errors</code> 的訊息，是因為我們只有選擇函式，而沒有給函式參數</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Fadd_function.png?alt=media&amp;token=cf83c0a5-58f6-4aea-a023-56bf181b5317" alt="加入函式"><span class="image-caption">加入函式</span></p>
<p>我們猜測同位客戶的名稱應該不常改變，應該使用 <code>Customer Name</code> 來計算客戶數量即可，因此將 <code>Customer Name</code> 欄位拖曳到視窗中的函式內 (直接輸入也可以)，並將此 Calculated Field 命名為 <code>客戶數</code>，看到視窗左下方出現 <code>The calculation is valid.</code>，代表這樣的函式表示法式可以使用的</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Fadd_customer_name.png?alt=media&amp;token=cc7ed810-4daf-4194-b519-9c69244caf78" alt="輸入參數 (左) &amp; 修改名稱 (右)"><span class="image-caption">輸入參數 (左) &amp; 修改名稱 (右)</span></p>
<p>最後點擊 <code>OK</code> 按鈕完成創建 Calculated Field，這時在 Data 窗格中就會看到我們剛建立好的欄位囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Ffinal.png?alt=media&amp;token=0bc5a8c4-6d0d-4f71-934d-f644c3727ba9" alt="客戶數欄位"><span class="image-caption">客戶數欄位</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Calculated Field 是一個常常會用到的功能，能協助我們計算出原始資料沒有提供的資訊，或是透過它來使用 Python 幫我們處理數據，與 Python 的整合在之後的分享中會提到。Calculated Field 明面上只有內建函數可以使用，但實際上我們可以自己創建函式！</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay20-Calculated-Field%2Fday20_tableau.twb?alt=media&token=3cdb0065-ea94-4a90-ab25-db789189358c" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>calculated</tag>
        <tag>field</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day21] Tableau 輕鬆學 - Parameter</title>
    <url>/2021/08/11/day21_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的時候我們會想讓使用者輸入一些參數，根據這些參數來做篩選或運算。到目前為止，我們沒使用到這個功能，但 Tableau Desktop 其實是有提供的，也就是 Parameter。這裡會分享如何搭配篩選器使用 Parameter 讓使用者輸入數值影響篩選的結果。</p>
<h2 id="Parameter"><a href="#Parameter" class="headerlink" title="Parameter"></a>Parameter</h2><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>Parameter 是一種能讓使用者在定義好的範圍內，任意輸入值的一種媒介，允許的資料型態有很多種，包含 <code>Float</code>、<code>Integer</code>、<code>String</code>、<code>Boolean</code>、<code>Date</code> 與 <code>Date &amp; Time</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>這裡直接拿在 <a href="/2021/08/05/day15_tableau/">[Day15] Tableau 輕鬆學 - 地圖工作表</a> 製作完成的工作簿來接續使用。我們想要知道有哪幾個州的訂單數過低，但目前不知道這個過低的表準是甚麼，因此我們可以建立一個參數，讓使用者輸入門檻值，並只顯示訂單數低於該值的州，以動態方式尋找合理的門檻值是一個不錯的辦法。</p>
<p>在 Data 窗格中點擊右上方的向下箭頭，選擇 <code>Create Parameter...</code> 來建立 Parameter，先命名為 <code>訂單數門檻</code>，再指定 Integer 為資料型態，限定數值範圍以 1 為間隔單位且上下限分別為 1000 與 1。建立好後會在 Data 窗格中看到 Parameters 區域中新增了 <code>訂單數門檻</code> 參數</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay21-Parameter%2Fparameter.png?alt=media&amp;token=3fc39a0d-a2e3-4a47-9a19-a897033d3024" alt="建立與設定 Parameter"><span class="image-caption">建立與設定 Parameter</span></p>
<p>接下來我們想要讓訂單數低於 <code>訂單數門檻</code> 的州才要顯示在 <code>州年度利潤地圖</code> 工作表，先將工作簿畫面切換到 <code>州年度利潤地圖</code>，再將 <code>State</code> 欄位拖曳到 <code>Filters</code> 選項卡上，會跳出 <code>Filter [State]</code> 設定視窗，在 <code>Condition</code> 頁面勾選 <code>By formula</code> 後，寫下我們用來篩選的條件運算式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUNTD([Order ID]) &lt;= [訂單數門檻]</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay21-Parameter%2Ffilter.png?alt=media&amp;token=923e25f1-4bdb-4d8b-8442-535d280697f4" alt="篩選器搭配 Parameter"><span class="image-caption">篩選器搭配 Parameter</span></p>
<p>最後，只需要將 Parameter 顯示出來就完成囉！右鍵點擊 <code>訂單數門檻</code> 選擇 <code>Show Parameter</code>，在工作表右方就會顯示 <code>訂單數門檻</code> 的選項卡，地圖中著色區塊會隨著 <code>訂單數門檻</code> 的值變動</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay21-Parameter%2Fshow_parameter.png?alt=media&amp;token=4f7f7dd1-d816-4a71-92fb-e7082c68d41a" alt="顯示 Parameter 操作"><span class="image-caption">顯示 Parameter 操作</span></p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay21-Parameter%2Fday21_tableau.twb?alt=media&token=566f3cfa-0d18-47bf-8d3e-52b633a1fa3c" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>parameter</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day22] Tableau 輕鬆學 - TabPy 介紹</title>
    <url>/2021/08/12/day22_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 是一種直譯式語言，近幾年在資料科學中 (例如：人工智慧、大數據分析 等) 有著耀眼表現，若能將 Python 整合進 Tableau 使用，那將會是如虎添翼。幸好，Tableau 在 2016 年時發佈 TabPy 這個解決方案，TabPy 讓我們可以在 Tableau 工作簿內使用 Python 來對資料做運算與分析，使操作資料的方式更多元。諸多好處使 TabPy 成為使用 Tableau 必學的一個技術，讓我們先認識 TabPy，之後實作才會比較有概念。</p>
<h2 id="TabPy-是甚麼"><a href="#TabPy-是甚麼" class="headerlink" title="TabPy 是甚麼"></a>TabPy 是甚麼</h2><p>TabPy 是 Tableau 開發的一種 Web 應用程式，它以 Web API 的形式讓 Tableau 可以將函式名稱與資料透過 API 傳遞給 TabPy，再經由 TabPy 呼叫對應的函式來處理收到的資料，當 TabPy 得到函式運算結果，便將其回傳給 Tableau 做下一步運算或顯示。可以將 TabPy 想成就是一個位於 Python 與 Tableau 之間的中介角色，為兩方溝通的橋樑。</p>
<h2 id="TabPy-的極限"><a href="#TabPy-的極限" class="headerlink" title="TabPy 的極限"></a>TabPy 的極限</h2><p>任何事物都有它的極限在，TabPy 當然也不例外，要先理解它的限制才能正確地使用它。</p>
<p>Tableau Desktop 內建有四個函式讓我們用來呼叫 TabPy 進而使用 Python 程式，分別為 <code>SCRIPT_BOOL</code>、<code>SCRIPT_INT</code>、<code>SCRIPT_REAL</code> 與 <code>SCRIPT_STR</code>，它們的名稱也代表著它們能夠回傳的資料型態，分別為 <code>Boolean</code>、<code>Integer</code>、<code>Numeric</code> 與 <code>String</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay22-TabPy-%E4%BB%8B%E7%B4%B9%2Fscript_4.png?alt=media&amp;token=0690847f-8c0f-4888-b8fa-60c45466ac9f" alt="4 種 SCRIPT 函式"><span class="image-caption">4 種 SCRIPT 函式</span></p>
<p>也因為它只能回傳這四種型態的資料，所以它無法做到更進階的應用，像是先在 Python 透過套件產製圖表，再回傳到 Tableau 顯示。因此，若想製作 Tableau Desktop 沒有提供的圖表，可能就無法單純透過 TabPy 來達到，TabPy 只提供單純資料的接收與回傳。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>limit</tag>
        <tag>tabpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day23] Tableau 輕鬆學 - TabPy 安裝與連線</title>
    <url>/2021/08/13/day23_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>對 TabPy 有一定程度的認識之後，便能開始學習 TabPy 安裝與使用，這篇文章會分享如何安裝 Python 與 TabPy，最後將 TabPy Server 啟動並測試與 Tableau Desktop 的連線。</p>
<h2 id="Python-安裝"><a href="#Python-安裝" class="headerlink" title="Python 安裝"></a>Python 安裝</h2><p>TabPy 是 Tableau 發佈的 Python 套件，必須要先安裝 Python 才可使用，依個人喜好可以安裝 Anaconda 或者直接安裝 Python，而我個人習慣直接安裝 Python，因此這裡分享的安裝步驟也是採用直接安裝的方法。</p>
<p>首先至官方網站根據作業系統選擇 <a href="https://www.python.org/downloads/release/python-385/">Python 3.8.5</a> 安裝檔，要注意的是若作業系統為 Windows，需要下載 x86-64 的安裝檔才會是 64 位元的 Python。安裝之前要特別勾選 <code>Add Python 3.8 to PATH</code>，再點擊 <code>Install Now</code> 進行安裝，千萬別忽略了，若因為任何原因沒有勾選，麻煩重新安裝 Python，將會節省很多時間</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay23-TabPy-%E5%AE%89%E8%A3%9D%E8%88%87%E9%80%A3%E7%B7%9A%2Fpython_install.png?alt=media&amp;token=5575a4fa-80d9-488f-9997-4fda1af63061" alt="Add Python to PATH"><span class="image-caption">Add Python to PATH</span></p>
<p>安裝完畢後，開啟 <code>cmd.exe</code> 並輸入 <code>python</code>，若出現 <code>Python 3.8.5</code> 字樣，表示 Python 安裝成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue&gt;python</span><br><span class="line">Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:57:54) [MSC v.1924 64 bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="TabPy-安裝"><a href="#TabPy-安裝" class="headerlink" title="TabPy 安裝"></a>TabPy 安裝</h2><p>在安裝 TabPy 之前，先建立 Python 虛擬環境，將 TabPy 環境與一般開發環境區隔開來，避免安裝的套件混合在一起導致難以管理。同樣在 <code>cmd.exe</code> 輸入指令，建立一個名為 <code>Tableau-Python-Server</code> 的虛擬環境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue&gt;python -m venv Tableau-Python-Server</span><br></pre></td></tr></table></figure>
<p>現在，讓我們先進到虛擬環境，若要知道現在所處的虛擬環境名稱，可經由提示字元前圓括弧內的名稱得知</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue&gt;Tableau-Python-Server\Scripts\activate</span><br><span class="line"></span><br><span class="line">(Tableau-Python-Server) C:\Users\wrxue&gt;</span><br></pre></td></tr></table></figure>
<p>pip 是 Python 的套件管理工具，而 TabPy 是 Python 中的一個套件，因此 TabPy 也可以直接使用 pip 來安裝，非常方便。使用 pip 之前的良好習慣是先將 pip 更新，再安裝套件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(Tableau-Python-Server) C:\Users\wrxue&gt;python -m pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">(Tableau-Python-Server) C:\Users\wrxue&gt;pip install tabpy</span><br></pre></td></tr></table></figure>
<p>若仔細觀察 TabPy 安裝的過程，會發現其實同時安裝了非常多的套件，資料處理中常用到的例如 numpy、pandas、sklearn 等都已包含在內，以下是安裝 TabPy 時也一同被安裝的套件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Installing collected packages: pyparsing, pycparser, numpy, colorama, urllib3, tqdm, toml, threadpoolctl, six, scipy, regex, py, pluggy, packaging, joblib, iniconfig, idna, click, charset-normalizer, cffi, certifi, attrs, atomicwrites, zope.interface, twisted-iocpsupport, sortedcontainers, scikit-learn, requests, pytz, python-dateutil, pytest, pyrsistent, nltk, incremental, hyperlink, docopt, cryptography, coverage, constantly, Automat, twisted, tornado, textblob, sklearn, simplejson, pytest-cov, pyopenssl, pandas, mock, jsonschema, hypothesis, genson, future, coveralls, configparser, cloudpickle, tabpy</span><br></pre></td></tr></table></figure>
<p>最後，要啟動 TabPy Server 非常容易，只需輸入 <code>tabpy</code> 即可啟動</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(Tableau-Python-Server) C:\Users\wrxue&gt;tabpy</span><br><span class="line">[INFO] (app.py:app:242): Parsing config file c:\<span class="built_in">users</span>\wrxue\tableau-python-server\lib\site-packages\tabpy\tabpy_server\app\..\common\default.conf</span><br><span class="line">[INFO] (app.py:app:431): Loading state from state file C:\Users\wrxue\Tableau-Python-Server\Lib\site-packages\tabpy\tabpy_server\state.ini</span><br><span class="line">[INFO] (app.py:app:328): Password file is not specified: Authentication is not enabled</span><br><span class="line">[INFO] (app.py:app:343): Call context logging is disabled</span><br><span class="line">[INFO] (app.py:app:124): Initializing TabPy...</span><br><span class="line">[INFO] (callbacks.py:callbacks:43): Initializing TabPy Server...</span><br><span class="line">[INFO] (app.py:app:128): Done initializing TabPy.</span><br><span class="line">[INFO] (app.py:app:82): Setting max request size to 104857600 bytes</span><br><span class="line">[INFO] (callbacks.py:callbacks:64): Initializing models...</span><br><span class="line">[INFO] (app.py:app:105): Web service listening on port 9004</span><br></pre></td></tr></table></figure>
<p>啟動訊息提示我們 TabPy Server 運作在 Port 9004，因此我們在瀏覽器輸入 <a href="http://localhost:9004/">http://localhost:9004/</a> 就能看到 Tableau Python Server 的資訊囉，同時也代表 TabPy 正常運作中</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay23-TabPy-%E5%AE%89%E8%A3%9D%E8%88%87%E9%80%A3%E7%B7%9A%2Ftabpy_info.png?alt=media&amp;token=eaa12722-5822-4220-9b85-76f368755af5" alt="TabPy Server 資訊"><span class="image-caption">TabPy Server 資訊</span></p>
<h2 id="與-Tableau-Desktop-連線"><a href="#與-Tableau-Desktop-連線" class="headerlink" title="與 Tableau Desktop 連線"></a>與 Tableau Desktop 連線</h2><p>Tableau Desktop 要使用 TabPy 之前需要事先設定連線，讓工作簿知道應該找誰執行 Python 程式，TabPy 是允許遠端連線的，因此這裡的連線設定有可能因環境而異。透過 <code>Help → Settings and Performance → Manage Analytics Extension Connection...</code> 開啟連線設定視窗，選擇 <code>TabPy/External API</code> 並填寫 <code>TabPy Server</code> 的連線資訊，最後點擊 <code>Test Connection</code> 按鈕測試連線，若連線正常會出現含有 <code>Successfully connected to the analytics extension.</code> 訊息的提示視窗</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay23-TabPy-%E5%AE%89%E8%A3%9D%E8%88%87%E9%80%A3%E7%B7%9A%2Fconnect_check.png?alt=media&amp;token=f74e77d0-4126-4080-9474-b0148d26878a" alt="連線確認"><span class="image-caption">連線確認</span></p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>install</tag>
        <tag>tableau</tag>
        <tag>connect</tag>
        <tag>tabpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day24] Tableau 輕鬆學 - TabPy 使用方法 1</title>
    <url>/2021/08/14/day24_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>簡單來說，Python 在 Tableau Desktop 中使用方法有兩種，第一種是將 TabPy 當作 Python 直譯器，將 Python 程式碼直接寫在 Tableau Desktop 中，需要運算時再將該程式碼傳送給 TabPy 執行。第二種是預先寫好函式，將其存放於 TabPy Server，Tableau 要呼叫時只需指定函式名稱與傳遞資料即可。這裡會分享如何使用第一種方式，將 Python 整合進 Tableau Desktop 使用。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>以 <code>Sample - Superstore</code> 為資料來源，開啟一個全新的工作簿，我們將會建立四個 Calculated Field 分別使用 <code>SCRIPT_BOOL</code>、<code>SCRIPT_INT</code>、<code>SCRIPT_REAL</code> 與 <code>SCRIPT_STR</code> 四個函式來示範如何在 Tableau Desktop 中使用 Python。</p>
<p>這四個函式的參數格式都相同 <code>(string, expression, ...)</code>，第一個參數為 Python 程式碼，第二個與之後的參數都為所要傳遞的資料。TabPy 預設以 <code>_arg#</code> 變數名稱來存取 Tableau 傳遞來的資料，<code>#</code> 代表從 <code>1</code> 開始的數字，數字依資料所在的參數位置而定。所有傳遞的資料在 TabPy 中都會以 List 的型態存在，因此所有的 <code>_arg#</code> 都為 List 物件</p>
<h3 id="SCRIPT-BOOL"><a href="#SCRIPT-BOOL" class="headerlink" title="SCRIPT_BOOL"></a>SCRIPT_BOOL</h3><p>建立一個名為 <code>銷售額大於10000</code> 的 Calculated Field 且其函式如下，意思是若銷售額 <code>SUM([Sales])</code> 大於 <code>10000</code>，對應的回傳值會是 <code>True</code>，反之為 <code>False</code>。<code>SUM([Sales])</code> 為第 1 個資料參數，因此若想在 Python 程式中存取則是使用 <code>_arg1</code> 變數名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SCRIPT_BOOL(<span class="string">&quot;return [x &gt; 10000 for x in _arg1]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<h3 id="SCRIPT-INT"><a href="#SCRIPT-INT" class="headerlink" title="SCRIPT_INT"></a>SCRIPT_INT</h3><p>建立一個名為 <code>2倍銷售額</code> 的 Calculated Field 且其函式如下，意思是在 Python 中先將資料各別乘以 2 再取整數回傳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SCRIPT_INT(<span class="string">&quot;return [int(x * 2) for x in _arg1]&quot;</span>, SUM(Sales))</span><br></pre></td></tr></table></figure>
<h3 id="SCRIPT-REAL"><a href="#SCRIPT-REAL" class="headerlink" title="SCRIPT_REAL"></a>SCRIPT_REAL</h3><p>建立一個名為 <code>銷售額平方根</code> 的 Calculated Field 且其函式如下，意思是在 Python 中先將 <code>math</code> 套件 import 進來，再將資料各別取根號值回傳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SCRIPT_REAL(<span class="string">&quot;import math</span></span><br><span class="line"><span class="string">return [math.sqrt(x) for x in _arg1]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<h3 id="SCRIPT-STR"><a href="#SCRIPT-STR" class="headerlink" title="SCRIPT_STR"></a>SCRIPT_STR</h3><p>建立一個名為 <code>銷售額說明</code> 的 Calculated Field 且其函式如下，這裡傳入兩種資料分別為銷售額 <code>SUM([Sales])</code> 與州名 <code>ATTR([State])</code>，在 Python 中要存取銷售額是使用 <code>_arg1</code>，而存取州名是使用 <code>_arg2</code> 變數名稱，因為它是第 2 個傳入的資料參數</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SCRIPT_STR(<span class="string">&quot;</span></span><br><span class="line"><span class="string">return [f&#x27;&#123;x[1]&#125; 的銷售額為 &#123;int(x[0])&#125;&#x27; for x in zip(_arg1, _arg2)]</span></span><br><span class="line"><span class="string">&quot;</span>, SUM([Sales]), ATTR([State]))</span><br></pre></td></tr></table></figure>
<h2 id="顯示"><a href="#顯示" class="headerlink" title="顯示"></a>顯示</h2><p>將 <code>State</code>、<code>銷售額大於10000</code>、<code>銷售額說明</code> 拖曳到 Rows，<code>Sales</code>、<code>2倍銷售額</code>、<code>銷售額平方根</code> 拖曳到 Columns，簡單地人工肉眼驗證是否運算正確</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay24-TabPy-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1%2Ftabpy_method_1.png?alt=media&amp;token=51377d29-d86f-46db-bb00-3577c245aab6" alt="TabPy 運算結果視覺化"><span class="image-caption">TabPy 運算結果視覺化</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>透過簡單的例子示範如何將 Python 寫在 Tableau Desktop 之中並獲得回傳值，讓讀者有辦法運用這四個函式創造出自己的計算方法。這種使用方式很直接，因為程式碼是嵌在工作簿內的，但這種作法也有缺點，若其他工作簿也需要使用該程式碼，就必須複製同一份程式碼至不同的工作簿中，最後變得難以管理。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay24-TabPy-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1%2Fday24_tableau.twb?alt=media&token=a30cce4d-48fa-4a83-a902-f5e6855d7c9d" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
        <tag>tabpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day25] Tableau 輕鬆學 - TabPy 使用方法 2</title>
    <url>/2021/08/15/day25_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>直接將所有 Python 程式寫在工作簿內的第一種 TabPy 使用方法我們已經學會了，但這種方法的最大缺點是難以管控程式碼，無法將程式碼提供給多個工作簿共用。這裡要分享的是第二種 TabPy 使用方式，以佈署函式的方式讓我們可以將程式碼集中管理。</p>
<h2 id="佈署函式"><a href="#佈署函式" class="headerlink" title="佈署函式"></a>佈署函式</h2><h3 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h3><p>第二種使用方式就是向 TabPy Server 先註冊 Python 函式來提前佈署，佈署好的函式在 TabPy 中就會被視為一個 Model，Tableau Desktop 只需要指定要用來處理資料的 Model 名稱，即可等待運算結果回傳。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>建立一個名稱為 <code>TabPyTest.py</code> 的 Python 檔案，內容如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tabpy.tabpy_tools.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">client = Client(<span class="string">&#x27;http://localhost:9004/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">data1, data2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">client.deploy(<span class="string">&#x27;foo&#x27;</span>, foo, <span class="string">&#x27;This is the test function.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Client(url)</code>：建立一個 TabPy Client 物件，並指定對 <code>url</code> 連線，TabPy 目前不接受遠端佈署，只能對在 <code>localhost</code> 的 TabPy Server 佈署函式，所以這裡的 <code>url</code> 網域必為 <code>localhost</code>。</li>
<li><code>foo(data1, data2)</code>：自行建立可接受兩個輸入參數的函式，與第一種 TabPy 使用方法不同的是，參數名稱可以自定義，這裡分別命名為 <code>data1</code> 與 <code>data2</code>。</li>
<li><code>client.deploy(model_name, function, model_description)</code>：<code>model_name</code> 為佈署後的 Model 名稱，可以選擇與函式不同的名稱，但建議為有意義並且容易懂的詞彙；<code>function</code> 為要佈署的函式；<code>model_description</code> 為 Model 的補充敘述。</li>
</ul>
<p>執行佈署 (需在有安裝 TabPy 的虛擬環境中執行)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Tableau-Python-Server) C:\Users\wrxue&gt;python TabPyTest.py</span><br></pre></td></tr></table></figure>
<p>若佈署成功，在 <a href="http://localhost:9004/">http://localhost:9004/</a> 的 Deployed Models 區域應該就會看到新增一個名為 <code>foo</code> 的 Model，也就是我們在 <code>TabPyTest.py</code> 內的 <code>foo</code> 函式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;foo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the test function.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626685276</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626685276</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="TabPy-佈署"><a href="#TabPy-佈署" class="headerlink" title="TabPy 佈署"></a>TabPy 佈署</h3><p>理解佈署的概念與流程之後，便能將我們在方法一使用到的 Python 包裝成四個不同的函式來佈署，將 <code>TabPyTest.py</code> 修改為如下內容後執行佈署</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tabpy.tabpy_tools.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">client = Client(<span class="string">&#x27;http://localhost:9004/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testBool</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> [x &gt; <span class="number">10000</span> <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testInt</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">int</span>(x * <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testReal</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">return</span> [math.sqrt(x) <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testStr</span>(<span class="params">data1, data2</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f&#x27;<span class="subst">&#123;x[<span class="number">1</span>]&#125;</span> 的銷售額為 <span class="subst">&#123;<span class="built_in">int</span>(x[<span class="number">0</span>])&#125;</span>&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(data1, data2)]</span><br><span class="line"></span><br><span class="line">client.deploy(<span class="string">&#x27;test_SCRIPT_BOOL&#x27;</span>, testBool, <span class="string">&#x27;Test SCRIPT_BOOL by deployment&#x27;</span>)</span><br><span class="line">client.deploy(<span class="string">&#x27;test_SCRIPT_INT&#x27;</span>, testInt, <span class="string">&#x27;Test SCRIPT_INT by deployment&#x27;</span>)</span><br><span class="line">client.deploy(<span class="string">&#x27;test_SCRIPT_REAL&#x27;</span>, testReal, <span class="string">&#x27;Test SCRIPT_REAL by deployment&#x27;</span>)</span><br><span class="line">client.deploy(<span class="string">&#x27;test_SCRIPT_STR&#x27;</span>, testStr, <span class="string">&#x27;Test SCRIPT_STR by deployment&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>TabPy Server 的 Deployed Models 會跟著新增 4 個 Models，分別為 <code>test_SCRIPT_BOOL</code>、<code>test_SCRIPT_INT</code>、<code>test_SCRIPT_REAL</code> 與 <code>test_SCRIPT_STR</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;test_SCRIPT_BOOL&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test SCRIPT_BOOL by deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686885</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686885</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test_SCRIPT_INT&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test_SCRIPT_REAL&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;test_SCRIPT_STR&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686886</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tableau-Desktop-呼叫"><a href="#Tableau-Desktop-呼叫" class="headerlink" title="Tableau Desktop 呼叫"></a>Tableau Desktop 呼叫</h3><p>修改工作簿中 4 個與 SCRIPT 函式有關的 Calculated Field</p>
<h4 id="銷售額大於10000"><a href="#銷售額大於10000" class="headerlink" title="銷售額大於10000"></a>銷售額大於10000</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_BOOL(<span class="string">&quot;return tabpy.query(&#x27;test_SCRIPT_BOOL&#x27;, _arg1)[&#x27;response&#x27;]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<h4 id="2倍銷售額"><a href="#2倍銷售額" class="headerlink" title="2倍銷售額"></a>2倍銷售額</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_INT(<span class="string">&quot;return tabpy.query(&#x27;test_SCRIPT_INT&#x27;, _arg1)[&#x27;response&#x27;]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<h4 id="銷售額平方根"><a href="#銷售額平方根" class="headerlink" title="銷售額平方根"></a>銷售額平方根</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_REAL(<span class="string">&quot;return tabpy.query(&#x27;test_SCRIPT_REAL&#x27;, _arg1)[&#x27;response&#x27;]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<h4 id="銷售額說明"><a href="#銷售額說明" class="headerlink" title="銷售額說明"></a>銷售額說明</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_STR(<span class="string">&quot;return tabpy.query(&#x27;test_SCRIPT_STR&#x27;, _arg1, _arg2)[&#x27;response&#x27;]&quot;</span></span><br><span class="line">, SUM([Sales]), ATTR([State]))</span><br></pre></td></tr></table></figure>
<p>此時的效果就與 <a href="/2021/08/14/day24_tableau/#顯示">[Day24] Tableau 輕鬆學 - TabPy 使用方法 1</a> 的效果是一樣的，只是使用 Python 的方式不同而已。</p>
<h2 id="覆蓋與移除-Model"><a href="#覆蓋與移除-Model" class="headerlink" title="覆蓋與移除 Model"></a>覆蓋與移除 Model</h2><p>當我們想要直接重新佈署已經存在的 Model，會出現錯誤訊息如下，大意是說已經有相同名稱的 Model 存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RuntimeError: An endpoint with that name (test_SCRIPT_BOOL) already exists. Use <span class="string">&quot;override = True&quot;</span> to force update an existing endpoint.</span><br></pre></td></tr></table></figure>
<p>這時候我們有兩個方法讓佈署能夠成功，一個方法是直接覆蓋掉現有的 Model，另一個方法則是先移除現存的 Model 再行佈署。</p>
<h3 id="覆蓋-Model"><a href="#覆蓋-Model" class="headerlink" title="覆蓋 Model"></a>覆蓋 Model</h3><p>只需在 <code>client.deploy</code> 加上 <code>override</code> 參數，允許它可以覆蓋現有的 Model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client.deploy(<span class="string">&#x27;test_SCRIPT_BOOL&#x27;</span>, testBool, <span class="string">&#x27;Test SCRIPT_BOOL by deployment&#x27;</span>, override=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>覆蓋後，若仔細觀察 Deployed Models 中的 <code>test_SCRIPT_BOOL</code>，會看到它的 <code>version</code> 變為 2，這是因為每次覆蓋會造成版次自動加 1</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;test_SCRIPT_BOOL&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test SCRIPT_BOOL by deployment&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;creation_time&quot;</span><span class="punctuation">:</span> <span class="number">1626686885</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;last_modified_time&quot;</span><span class="punctuation">:</span> <span class="number">1626696002</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;docstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-- no docstring found in query function --&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h3 id="移除-Model"><a href="#移除-Model" class="headerlink" title="移除 Model"></a>移除 Model</h3><p>在 <code>client.deploy</code> 之前先呼叫移除 Model 的函式便能將 Model 名稱空出來，避免 Model 撞名導致無法佈署</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client.remove(<span class="string">&#x27;test_SCRIPT_BOOL&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這裡介紹的 TabPy 使用方法讓我們可以集中管理 Python 程式碼，使工作簿可以共用相同的函式。但這種方法不容易得知有哪些工作簿使用到對應的 Model，無法快速知道若將 Model 進行更新對應需要修改的工作簿有哪些。我個人認為兩種 TabPy 方法可以並行採用，若程式碼不會被重複使用，可以考慮直接寫在工作簿內，而會被重複使用的程式碼還是以佈署的方式為主，維護上會比較方便。</p>
<h2 id="工作簿原始檔案"><a href="#工作簿原始檔案" class="headerlink" title="工作簿原始檔案"></a>工作簿原始檔案</h2><!-- markdownlint-disable MD034 -->
<a class="btn" href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay25-TabPy-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2%2Fday25_tableau.twb?alt=media&token=a9f2dd85-a57e-420f-8131-0f9b0468d56f" title="完成的工作簿">
            <i class="fa fa-download fa-lg"></i>Workbook
          </a>
<!-- markdownlint-restore MD034 -->
<p>在實作中遇到困難是難免的，這裡提供原始檔作為參考，若仍然無法解決歡迎至下方討論區留言。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
        <tag>tabpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day26] Tableau 輕鬆學 - TabPy 開發流程</title>
    <url>/2021/08/16/day26_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>熟悉 TabPy 的運作與使用方法之後，下一步便是開發屬於自己的 Model。若直接使用 TabPy 與 Tableau Desktop 來開發，很快會發現這樣的開發流程將會是一個問題，因為資料是直接從 Tableau Desktop 來的，導致我們無法像平常開發 Python 一樣，修改程式後馬上運行查看結果，造成諸多不便。因此這裡要分享個人平時開發 TabPy Model 的流程，提供給讀者參考。</p>
<h2 id="匯出-csv-資料集"><a href="#匯出-csv-資料集" class="headerlink" title="匯出 csv 資料集"></a>匯出 csv 資料集</h2><p>首先，需要解決資料源的問題，因為我們開發的時候不太可能一邊寫 Python 一邊操作 Tableau Desktop 來查看運算結果，除非程式邏輯很簡單，否則將會耗費大量時間在來回操作上。這裡提供一個替代方案，先從 Tableau Desktop 先將資料匯出成 csv 檔，再使用 Python 讀檔案做為資料源。</p>
<p>在 <code>Data</code> Menu 中選擇資料集 (此例為 <code>Sample - Superstore</code>) 並點選 <code>View Data...</code>，先切換至要匯出的資料表頁籤 (此例為 <code>Orders</code>)，再點擊 <code>Export All</code> 按鈕匯出 csv 格式的資料集檔案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay26-TabPy-%E9%96%8B%E7%99%BC%E6%B5%81%E7%A8%8B%2Fexport_data.png?alt=media&amp;token=f999af2a-cbfe-4535-8fbe-24c21fa03136" alt="資料匯出 csv"><span class="image-caption">資料匯出 csv</span></p>
<h2 id="使用-csv-資料集"><a href="#使用-csv-資料集" class="headerlink" title="使用 csv 資料集"></a>使用 csv 資料集</h2><p>在 Python 中我們可以使用 <code>pandas</code> 套件來讀取 csv 文字檔，為了迎合 TabPy 的資料型態，需將會使用到的資料欄位轉換為 List 型態。再建立我們要佈署的函式，並將資料輸入測試運算結果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># read csv file</span></span><br><span class="line">df = pd.read_csv(<span class="string">r&#x27;C:\Users\wrxue\Downloads\Sample - Superstore_Orders.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert Sales and State Series to list</span></span><br><span class="line">sales = df[<span class="string">&#x27;Sales&#x27;</span>].tolist()</span><br><span class="line">state = df[<span class="string">&#x27;State&#x27;</span>].tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create your own function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testStr</span>(<span class="params">data1, data2</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">f&#x27;<span class="subst">&#123;x[<span class="number">1</span>]&#125;</span> 的銷售額為 <span class="subst">&#123;<span class="built_in">int</span>(x[<span class="number">0</span>])&#125;</span>&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(data1, data2)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># test testStr function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(testStr(sales, state)))</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>再次提醒，所有輸入函式的參數都應為 List 型態，最符合 TabPy 的使用情境</p>
          </div>
<p>執行並觀察輸出，若為預期中的結果，即可參考 <a href="/2021/08/15/day25_tableau/">[Day25] Tableau 輕鬆學 - TabPy 使用方法 2</a> 進行佈署函式流程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">District of Columbia 的銷售額為 <span class="number">40</span></span><br><span class="line">Massachusetts 的銷售額為 <span class="number">40</span></span><br><span class="line">Rhode Island 的銷售額為 <span class="number">592</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">California 的銷售額為 <span class="number">3023</span></span><br><span class="line">Arizona 的銷售額為 <span class="number">599</span></span><br><span class="line">Colorado 的銷售額為 <span class="number">2549</span></span><br></pre></td></tr></table></figure>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這樣的開發流程是依照個人的開發經驗分享給各位讀者的，但不代表說一定要這樣做，若有更簡便的方法歡迎至下方討論區留言分享，讓我們能一起學習與進步。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>develop</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
        <tag>tabpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day27] Tableau 輕鬆學 - TabPy 除錯技巧</title>
    <url>/2021/08/17/day27_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信走到這裡，讀者應該有辦法依需求在 Tableau Desktop 中活用 TabPy。但還有一個部分有可能造成開發困難，就是不知道如何查看錯誤訊息的詳細資訊或者確認 Tableau Desktop 傳來的資料格式，也就無法根據這些資訊來修正程式碼或 TabPy 的使用方式，進而導致在除錯遇到困難。因此這篇文章會分享使用 TabPy 應該要知道的除錯技巧。</p>
<h2 id="詳細錯誤訊息"><a href="#詳細錯誤訊息" class="headerlink" title="詳細錯誤訊息"></a>詳細錯誤訊息</h2><p>若在 Tableau Desktop 使用 TabPy 的過程中，遇到類似下圖的錯誤訊息是很正常的事，我們要學習的是如何知道問題詳細資訊，並且將問題排除</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay27-TabPy-%E9%99%A4%E9%8C%AF%E6%8A%80%E5%B7%A7%2Ferror.png?alt=media&amp;token=939cb7f6-e05e-4350-8e22-65e7e331abf0" alt="錯誤訊息"><span class="image-caption">錯誤訊息</span></p>
<p>當我們看到錯誤訊息視窗的時候，可以切換至啟動 TabPy Server 的 <code>cmd.exe</code> 中查看 Log，Log 中記錄所有通訊的過程，當然也包含錯誤訊息。這裡僅擷取關鍵資訊來展示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[INFO] : <span class="keyword">function</span> to evaluate=def _user_script(tabpy, _arg1):</span><br><span class="line"> <span class="built_in">return</span> [x &gt; 10000 <span class="keyword">for</span> x <span class="keyword">in</span> arg1]</span><br><span class="line"></span><br><span class="line">[ERROR] : Responding with status=500, message=<span class="string">&quot;Error processing script&quot;</span>, info=<span class="string">&quot;NameError : name &#x27;arg1&#x27; is not defined&quot;</span></span><br><span class="line">[ERROR] : 500 POST /evaluate (::1) 3.99ms</span><br></pre></td></tr></table></figure>
<p>這幾行 Log 告訴我們一個資訊，TabPy 要執行下方的程式，卻發現未定義的變數名稱 (<code>name &#39;arg1&#39; is not defined</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_user_script</span>(<span class="params">tabpy, _arg1</span>):</span><br><span class="line">    <span class="keyword">return</span> [x &gt; <span class="number">10000</span> <span class="keyword">for</span> x <span class="keyword">in</span> arg1]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_user_script(tabpy, _arg1)</code>：第一個參數 <code>tabpy</code> 不是我們所關心的，因此可以從第二個參數開始看。這裡的參數 <code>_arg1</code> 是不是很眼熟？就是在 <a href="/2021/08/14/day24_tableau/">[Day24] Tableau 輕鬆學 - TabPy 使用方法 1</a> 提到的，TabPy 預設會以 <code>_arg#</code> 變數名稱來存取資料，就是因為這裡的 <code>_user_script</code> 函式所定義，而我們在 Tableau Desktop 所寫的 Python 程式會變成 <code>_user_script</code> 的本體。</li>
</ul>
<p>到這裡，應該知道為什麼會出現錯誤訊息 <code>name &#39;arg1&#39; is not defined</code> 了吧，因為在 <code>_user_script</code> 中資料的變數名稱為 <code>_arg1</code> 而不是 <code>arg1</code>。</p>
<h2 id="傳輸資料查看"><a href="#傳輸資料查看" class="headerlink" title="傳輸資料查看"></a>傳輸資料查看</h2><p>有的時候，我們會懷疑是不是因為 Tableau Desktop 傳輸到 TabPy 的資料格式與我們想像中的不同，進而造成錯誤的發生。因此，如何查看傳輸至 TabPy 的資料也是需要學習的技術，才能更確定問題發生的原因。</p>
<p>將 <code>銷售額大於10000</code> 運算函式修改為</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_BOOL(<span class="string">&quot;print(&#x27;Hello TabPy&#x27;)</span></span><br><span class="line"><span class="string">return [x &gt; 10000 for x in _arg1]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<p>同樣觀察 TabPy Server 的 Log，會發現單獨一行的 <code>Hello TabPy</code>，這是因為 <code>print(&#39;Hello TabPy&#39;)</code> 這行的運行結果。也就是說，所有的 <code>print</code> 訊息都會被輸出到 Log 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[INFO] : <span class="keyword">function</span> to evaluate=def _user_script(tabpy, _arg1):</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;Hello TabPy&#x27;</span>)</span><br><span class="line"> <span class="built_in">return</span> [x &gt; 10000 <span class="keyword">for</span> x <span class="keyword">in</span> _arg1]</span><br><span class="line"></span><br><span class="line">Hello TabPy</span><br></pre></td></tr></table></figure>
<p>利用這樣的運作流程，我們可以將資料 <code>print</code> 在 Log 來查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SCRIPT_BOOL(<span class="string">&quot;print(_arg1[:10])</span></span><br><span class="line"><span class="string">return [x &gt; 10000 for x in _arg1]&quot;</span>, SUM([Sales]))</span><br></pre></td></tr></table></figure>
<p>觀察 Log 後發現，其實 Tableau Desktop 不是我們想像中的一次傳遞所有銷售額資料，而是一次只傳送一筆資料來運算，且有幾筆就會傳幾次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] : <span class="keyword">function</span> to evaluate=def _user_script(tabpy, _arg1):</span><br><span class="line"> <span class="built_in">print</span>(_arg1[:10])</span><br><span class="line"> <span class="built_in">return</span> [x &gt; 10000 <span class="keyword">for</span> x <span class="keyword">in</span> _arg1]</span><br><span class="line"></span><br><span class="line">[1270.53]</span><br><span class="line">[INFO] : <span class="keyword">function</span> to evaluate=def _user_script(tabpy, _arg1):</span><br><span class="line"> <span class="built_in">print</span>(_arg1[:10])</span><br><span class="line"> <span class="built_in">return</span> [x &gt; 10000 <span class="keyword">for</span> x <span class="keyword">in</span> _arg1]</span><br><span class="line"></span><br><span class="line">[1603.1360000000002]</span><br></pre></td></tr></table></figure>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>知道如何 Debug 是程式開發的必經之路，使用 <code>print</code> 來 Debug 是最萬用也是最容易的，這之中最關鍵的是需要知道 <code>print</code> 輸出的位置，蒐集的資訊夠多之後便能有目標性的修正 Bug，最後順利在 Tableau Desktop 使用屬於自己的 Model。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>develop</tag>
        <tag>tableau</tag>
        <tag>desktop</tag>
        <tag>tabpy</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day28] Tableau 輕鬆學 - TabPy 備份與還原</title>
    <url>/2021/08/18/day28_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在勒索病毒盛行的年代，為資訊系統做好備份是最基本的工作，有效的備份除了可以抵擋病毒的攻擊，同時可以降低伺服器主機因意外毀損而導致無法快速重建系統的風險。同樣地，TabPy 的 Model 也是可以備份起來，當有需要的時候可以直接還原，省去重新佈署的程序。至於應該要將甚麼檔案做備份，便是這裡想要分享的主題。</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>當我們將 Python 函式佈署至 TabPy Server 的時候，TabPy 會執行兩個步驟</p>
<ol>
<li>更新 Models 資料庫：這樣在 <a href="http://localhost:9004">http://localhost:9004</a> 的 Deployed Models 中才會看到新增的 Model 資訊。</li>
<li>將新增的 Model 透過 cloudpickle 套件以 2 進制檔案儲存下來：啟動 TabPy Server 的過程中會讀取這些檔案並轉換為可呼叫的 Model，這也是我們重啟 TabPy 不需要重新佈署的原因。</li>
</ol>
<p>Models 相關的資料都是以檔案型式儲存下來，使我們備份工作簡單許多。但個人認為美中不足的是，我們無法從這些檔案中取得原始程式碼，這意味著我們用來佈署的程式碼同樣也需要備份起來。</p>
<h2 id="備份"><a href="#備份" class="headerlink" title="備份"></a>備份</h2><p>我們已經知道當佈署一個 Model 的時候會影響到兩個檔案，因此只需要備份這兩個檔案即可。</p>
<h3 id="state-ini"><a href="#state-ini" class="headerlink" title="state.ini"></a>state.ini</h3><p><code>state.ini</code> 就是 Models 的資料庫，用來記錄 Models 的相關資訊。TabPy Server 啟動時會先讀取此檔案，再去尋找對應的 cloudpickle 檔案轉為可呼叫 Model</p>
<p>此檔案位於虛擬環境目錄下的 <code>\Lib\site-packages\tabpy\tabpy_server</code> 目錄</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\Lib\site-packages\tabpy\tabpy_server\state.ini</span><br></pre></td></tr></table></figure>
<h3 id="pickle-archive"><a href="#pickle-archive" class="headerlink" title="pickle_archive"></a>pickle_archive</h3><p><code>pickle_archive</code> 為 TabPy 透過 cloudpickle 套件將 Model 儲存的檔案。路徑格式如下，以 Model 名稱與版次來切分不同的 <code>pickle_archive</code> 檔案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\query_objects\&#123;model_name&#125;\&#123;model_version&#125;\pickle_archive</span><br></pre></td></tr></table></figure>
<ul>
<li><code>model_name</code>：Model 的名稱。</li>
<li><code>model_version</code>：Model 的版次。</li>
</ul>
<p>例如：<code>test_SCRIPT_BOOL</code> 第 <code>1</code> 版的 <code>pickle_archive</code> 所在路徑應為</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\query_objects\test_SCRIPT_BOOL\1\pickle_archive</span><br></pre></td></tr></table></figure>
<p>這樣一來，所有 Models 的 <code>pickle_archive</code> 檔案都會儲存於 <code>query_objects</code> 目錄下，因此我們直接備份這整個目錄即可，此目錄也同樣位於 <code>\Lib\site-packages\tabpy\tabpy_server</code> 目錄。</p>
<div class="note info">
            <p>簡而言之，我們只需要備份一個檔案 (<code>state.ini</code>) 與一個目錄 (<code>query_objects</code>)。</p>
          </div>
<h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>若我們的虛擬環境名稱為 <code>Tableau-Python-Server</code>，且虛擬環境目錄位於 <code>C:\Users\wrxue\</code>，則只需備份以下兩個項目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue\Tableau-Python-Server\Lib\site-packages\tabpy\tabpy_server\state.ini</span><br><span class="line">C:\Users\wrxue\Tableau-Python-Server\Lib\site-packages\tabpy\tabpy_server\query_objects</span><br></pre></td></tr></table></figure>
<h2 id="還原"><a href="#還原" class="headerlink" title="還原"></a>還原</h2><p>若要將備份還原，遵守一個原則「東西哪裡拿來就哪裡放回去」，將備份中的兩個項目放回 <code>\Lib\site-packages\tabpy\tabpy_server</code> 即可，非常容易。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>備份不是一件難事，困難的是要知道應該備份甚麼東西，這裡將個人為 TabPy 備份的經驗分享給讀者，讓讀者可以少走冤枉路。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
        <tag>tabpy</tag>
        <tag>backup</tag>
        <tag>cloudpickle</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day29] Tableau 輕鬆學 - TabPy 啟動排程</title>
    <url>/2021/08/19/day29_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常我們會希望伺服器主機開機後，就立即上線服務客戶，這項要求對 TabPy Server 也不例外，除非有特殊情況，否則應該不會想要每次都以手動的方式來啟動。這裡會分享如何使用排程讓伺服器開機的同時自動運行 TabPy Server，省去伺服器管理人員的麻煩。</p>
<h2 id="撰寫啟動腳本"><a href="#撰寫啟動腳本" class="headerlink" title="撰寫啟動腳本"></a>撰寫啟動腳本</h2><p>腳本的撰寫需要看 TabPy Server 運行的作業系統，若在 Windows 上運行就撰寫 <code>bat</code> 檔案，而 Linux 則是 <code>sh</code> 檔案，語法可能有些微不同，但概念都是一樣的。</p>
<p>建立一個 <code>StartUpTabPy.bat</code> 檔案，內容如下 (路徑因環境而異，需視情況修改)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\wrxue\Tableau-Python-Server\Scripts\activate &amp;&amp; tabpy</span><br></pre></td></tr></table></figure>
<ul>
<li><code>activate</code>：運行 activate 執行檔以進入安裝 TabPy Server 的虛擬環境。這裡給的是 activate 執行檔的絕對路徑而不是相對路徑，可以避免一些不必要的錯誤。</li>
<li><code>tabpy</code>：也就是我們平常在虛擬環境啟動 TabPy Server 的指令。</li>
</ul>
<p>整個意思就是：先進入虛擬環境再啟動 TabPy Server。</p>
<h2 id="排程設定"><a href="#排程設定" class="headerlink" title="排程設定"></a>排程設定</h2><p>啟動腳本完成之後，我們要設定排程讓伺服器主機開機時自動執行該腳本，如此一來就能達到自動運行 TabPy Server 的效果。</p>
<p>開啟工作排程器 (Task Scheduler)，點選 <code>Action Menu → Create Task...</code> 新增一個排程工作，填寫 <code>Name</code> 與勾選 <code>Security options</code></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay29-TabPy-%E5%95%9F%E5%8B%95%E6%8E%92%E7%A8%8B%2Fcreate_task.png?alt=media&amp;token=c07f82eb-07be-4ac3-9830-9cc3fcf1d2a7" alt="新增工作排程"><span class="image-caption">新增工作排程</span></p>
<p>於 <code>Tiggers</code> 頁籤中新增一個觸發時機，並選擇開機時 (<code>At startup</code>)，再於 <code>Actions</code> 頁籤新增我們寫好的腳本檔案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay29-TabPy-%E5%95%9F%E5%8B%95%E6%8E%92%E7%A8%8B%2Fsetting.png?alt=media&amp;token=cafefb81-3064-4af9-81fe-66367ee606bf" alt="Triggers &amp; Actions"><span class="image-caption">Triggers &amp; Actions</span></p>
<h2 id="關閉-TabPy"><a href="#關閉-TabPy" class="headerlink" title="關閉 TabPy"></a>關閉 TabPy</h2><p>使用排程開啟的 TabPy Server 會再背景中運行，若我們想關閉或重啟 TabPy Server，就需要到工作管理員中強制關閉。於工作管理員的 <code>Details</code> 頁籤中右鍵點擊 <code>tabpy.exe</code>，選擇 <code>End task</code> 強制關閉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tableau%E8%BC%95%E9%AC%86%E5%AD%B8%2FDay29-TabPy-%E5%95%9F%E5%8B%95%E6%8E%92%E7%A8%8B%2Fend_task.png?alt=media&amp;token=0ff32be9-f814-49c7-8876-99df07f399c8" alt="關閉 TabPy Server"><span class="image-caption">關閉 TabPy Server</span></p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>tableau</tag>
        <tag>tabpy</tag>
        <tag>startup</tag>
        <tag>scheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>[Day30] Tableau 輕鬆學 - 總結</title>
    <url>/2021/08/20/day30_tableau/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/categories/Tableau-輕鬆學/">Tableau 輕鬆學</a> 系列文章也已經到了尾聲，從帶著讀者從頭認識 Tableau 並且調查人力市場需求以鼓勵讀者學習，到深入使用 Tableau Desktop 製作屬於讀者的工作表與儀表板並學會如何美化外觀、分享個人認為必需學會的基本觀念 (例如：Dimension/Measure、Rows/Columns 與 Relationships/Joins 的概念與區別)、遇到龐大資料量時 Data Extract 的用法，最後花較長的篇幅介紹 Tableau Python Server 的安裝與使用，乃至於備份還原與啟動排程。</p>
<p>這些分享的內容都是依照個人使用 Tableau 所積累的經驗與知識，若仔細閱讀完整個系列的文章，會發現其實沒有太著墨於對資料的探索，反而是說明各種觀念與功能，並提醒讀者甚麼情況下可以考慮採取甚麼樣的行動，因為個人認為先懂工具運作概念與功能，讀者較有機會使用 Tableau 獨自從資料中找出屬於自己或企業 Know How。</p>
<p>這系列內容的編排為個人在網路上學習時，一直在尋找的文章，但遺憾的是並沒有看到類似這種系列文章，詳細講述各種觀念與操作應注意事項。因此，想要為 Tableau 使用教學做一些貢獻，期望正在學習 Tableau 或已經會使用但不熟觀念的讀者，可以參考這些文章汲取到對自己有用的知識。當理解文章所帶來的觀念之後，不代表學習 Tableau 的過程已經結束，反而要視之為起點，這些文章只是一個入門磚，幫助沒有使用過 Tableau 的讀者有個管道可以快速了解。</p>
]]></content>
      <categories>
        <category>Tableau 輕鬆學</category>
      </categories>
      <tags>
        <tag>tableau</tag>
      </tags>
  </entry>
  <entry>
    <title>[PyExecJS] Python 呼叫並執行 JavaScript 函式</title>
    <url>/2021/09/25/python_javascript/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>若能在 Python 調用 JavaScript 函式，將能讓爬蟲的能力更強大，因為有些函式在目標網站上已經用 JavaScript 寫好，我們只需要將其 js 檔案下載並透過 Python 執行，便能得到一樣的結果。這篇文章記錄如何使用 <a href="https://pypi.org/project/PyExecJS/">PyExecJS</a> 套件來完成這件事。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Python 3.9.6</li>
<li>PyExecJS 1.5.1</li>
</ul>
<h2 id="安裝-PyExecJS"><a href="#安裝-PyExecJS" class="headerlink" title="安裝 PyExecJS"></a>安裝 PyExecJS</h2><p>養成習慣，在安裝套件之前，務必先將 pip 做更新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<p>安裝 PyExecJS 套件本人</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install PyExecJS</span><br></pre></td></tr></table></figure>
<h2 id="PyExecJS-使用"><a href="#PyExecJS-使用" class="headerlink" title="PyExecJS 使用"></a>PyExecJS 使用</h2><h3 id="環境建立"><a href="#環境建立" class="headerlink" title="環境建立"></a>環境建立</h3><p>在同一個目錄中建立兩個檔案，分別為 <code>main.py</code> 與 <code>main.js</code>，我們將會在 <code>main.py</code> 寫程式使用 <a href="https://pypi.org/project/PyExecJS/">PyExecJS</a> 套件去呼叫在 <code>main.js</code> 中的 JavaScript 函式。</p>
<h3 id="無參數且直接呼叫函式"><a href="#無參數且直接呼叫函式" class="headerlink" title="無參數且直接呼叫函式"></a>無參數且直接呼叫函式</h3><p><code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">whoAmI</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;main.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取 js 檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./main.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"><span class="comment"># 編譯 js 原始碼</span></span><br><span class="line">jsContext = execjs.<span class="built_in">compile</span>(content)</span><br><span class="line"><span class="comment"># 呼叫 js 函式，第一個參數為 js 函式名稱，</span></span><br><span class="line"><span class="comment"># 若有參數要輸入，則依序跟在後面</span></span><br><span class="line">result = jsContext.call(<span class="string">&#x27;whoAmI&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># main.js</span></span><br></pre></td></tr></table></figure>
<h3 id="整數作為參數呼叫函式"><a href="#整數作為參數呼叫函式" class="headerlink" title="整數作為參數呼叫函式"></a>整數作為參數呼叫函式</h3><p><code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取 js 檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./main.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"><span class="comment"># 編譯 js 原始碼</span></span><br><span class="line">jsContext = execjs.<span class="built_in">compile</span>(content)</span><br><span class="line"><span class="comment"># 呼叫 js 函式，第一個參數為 js 函式名稱，</span></span><br><span class="line"><span class="comment"># 若有參數要輸入，則依序跟在後面</span></span><br><span class="line">result = jsContext.call(<span class="string">&#x27;add&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h3 id="物件作為參數呼叫函式"><a href="#物件作為參數呼叫函式" class="headerlink" title="物件作為參數呼叫函式"></a>物件作為參數呼叫函式</h3><p><code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objAdd</span>(<span class="params">variables</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> variables.<span class="property">x</span> + variables.<span class="property">y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取 js 檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./main.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"><span class="comment"># 編譯 js 原始碼</span></span><br><span class="line">jsContext = execjs.<span class="built_in">compile</span>(content)</span><br><span class="line"><span class="comment"># 建立一個 dict 物件</span></span><br><span class="line"><span class="built_in">vars</span> = &#123;</span><br><span class="line">    <span class="string">&quot;x&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;y&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 呼叫 js 函式，第一個參數為 js 函式名稱，</span></span><br><span class="line"><span class="comment"># 若有參數要輸入，則依序跟在後面</span></span><br><span class="line">result = jsContext.call(<span class="string">&#x27;objAdd&#x27;</span>, <span class="built_in">vars</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<h3 id="呼叫回傳值為物件的函式"><a href="#呼叫回傳值為物件的函式" class="headerlink" title="呼叫回傳值為物件的函式"></a>呼叫回傳值為物件的函式</h3><p><code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPersonInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取 js 檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./main.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line"><span class="comment"># 編譯 js 原始碼</span></span><br><span class="line">jsContext = execjs.<span class="built_in">compile</span>(content)</span><br><span class="line"><span class="comment"># 呼叫 js 函式，第一個參數為 js 函式名稱，</span></span><br><span class="line"><span class="comment"># 若有參數要輸入，則依序跟在後面</span></span><br><span class="line">result = jsContext.call(<span class="string">&#x27;getPersonInfo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 17&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>invoke</tag>
        <tag>js</tag>
        <tag>python</tag>
        <tag>javascript</tag>
        <tag>crawl</tag>
        <tag>function</tag>
        <tag>parameter</tag>
        <tag>spider</tag>
        <tag>pyexecjs</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] 爬蟲修改 User-Agent 標頭</title>
    <url>/2021/06/15/python_user_agent/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬蟲是一個很方便的工具，可以自動化且大量分析網頁，將別人的網頁當作自己資料庫，但也因為如此，有些網頁會偵測連線來源是否為爬蟲工具，若是的話會阻擋 (404)，或者有些會顯示出與正常使用瀏覽器瀏覽時不一樣的內容。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>python 3.8.5</li>
</ul>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><code>Python</code> 爬蟲第一步大多數是使用 <code>requests</code> 這個套件，它內建的請求標頭 <code>User-Agent</code> 為 <code>python-requests/2.24.0</code>，也許版本號會不同，但一看就知道是爬蟲而不是真的使用者的連線請求，所以應用程式可根據這個線索來拒絕服務。但「道高一尺，魔高一丈」不是沒有道理的，只要我們改了 <code>User-Agent</code>，就能繞過根據這個標頭欄位過濾請求的網站</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://abcde.example.com&quot;</span></span><br><span class="line">response = requests.get(url, headers = headers)</span><br></pre></td></tr></table></figure>
<p>這時，所有的請求標頭 <code>User-Agent</code> 都將顯示為 <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36</code>。</p>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>header</tag>
        <tag>user</tag>
        <tag>python</tag>
        <tag>agent</tag>
        <tag>crawl</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] 使用 Selenium 爬蟲下載當前頁面驗證碼圖片</title>
    <url>/2021/07/04/python_selenium_captcha/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正常的登入機制中有一個環節是顯示一張驗證碼圖片，請使用者輸入圖片中的驗證碼，來達到阻擋機器人 (爬蟲) 登入的效果。但這並不能阻止以爬蟲為樂的我們，我們可以在需要輸入驗證碼的時候，將驗證碼截圖並顯示在跳出對話框，請使用者手動輸入驗證碼。成功登入後，剩下的工作就可交由爬蟲繼續執行。</p>
<p>然而，對驗證碼圖片的連結發出一個資源請求，正常來說會回傳不同於前一次的驗證碼圖片，因此我們不能只抓 img 標籤中的 src 然後重新發出請求來下載該圖片。而是應直接下載當前頁面所顯示的圖片，這篇文章紀錄如何使用 Selenium 在不重新發出請求的情形下，下載當前 img 標籤內的圖片。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Python 3.8.5</li>
<li>matplotlib 3.4.2</li>
<li>selenium 3.140.0</li>
</ul>
<h2 id="原因說明"><a href="#原因說明" class="headerlink" title="原因說明"></a>原因說明</h2><p>直接舉實例來觀察，隨意以 <a href="https://ipost.post.gov.tw/pst/home.html">網路郵局</a> 介面中的 <a href="https://ipost.post.gov.tw/pst/jcaptcha?uuid=b03add49-5532-4efc-a601-1d662fe4ab56">驗證碼連結</a> 為例，同樣的連結重新整理後，會吐不一樣的圖片出來</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Python-%E4%BD%BF%E7%94%A8-Selenium-%E6%8A%93%E7%95%B6%E5%89%8D%E9%A0%81%E9%9D%A2%E9%A9%97%E8%AD%89%E7%A2%BC%E5%9C%96%E7%89%87%2Fdifferent_captcha.png?alt=media&amp;token=6137c314-3ce4-473c-9f72-56fb61f5ca22" alt="一樣連結產百樣碼"><span class="image-caption">一樣連結產百樣碼</span></p>
<p>若使用 <code>urllib</code> 或 <code>requests</code> 等套件去下載圖片，顯示給使用者輸入，這時取得的驗證碼圖片，一定不是正確的。要解決這個問題，直接從頁面抓當前的圖片是最佳解。</p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>想要解決這個問題還需要使用到 Javascript (js) 來協助。</p>
<p>先透過 js 在 Selenium 中取得 img 的內容，並以 Base64 格式回傳圖片內容到 Python 中，有了這個 Base64 圖片，甚麼都好辦，例如存檔、顯示在 tkinter 視窗或更多其他種應用。</p>
<div class="note info">
            <p>若想要知道還能如何利用透過 Selenium 取得的驗證碼圖片，歡迎參考實際範例 <a href="/2021/10/29/selenium_tkinter_login/">[爬蟲] Selenium+Tkinter 製作具有驗證碼的網站登錄器</a> !</p>
          </div>
<h3 id="取得圖片-Base64-格式"><a href="#取得圖片-Base64-格式" class="headerlink" title="取得圖片 Base64 格式"></a>取得圖片 Base64 格式</h3><p>使用 js 進行 DOM 操作，每一個步驟詳細說明盡在註解中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創建一個 canvas 元素</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="comment">// 取得 canvas 元素中的 2d 上下文</span></span><br><span class="line"><span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="comment">// 取得驗證碼的 img 標籤，要根據真實情況來變動，</span></span><br><span class="line"><span class="comment">// 每個網頁驗證碼的 css 選擇器應該很高機率不會相同</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div.codes_img img&#x27;</span>);</span><br><span class="line"><span class="comment">// canvas 高度與寬度設定為與驗證碼 img 相同</span></span><br><span class="line">canvas.<span class="property">height</span> = img.<span class="property">naturalHeight</span>;</span><br><span class="line">canvas.<span class="property">width</span> = img.<span class="property">naturalWidth</span>;</span><br><span class="line"><span class="comment">// 在 canvas 2d 上下文中的座標 (0, 0) 處，畫上 img 的內容</span></span><br><span class="line">context.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 轉換此圖片為 Base64 格式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(canvas.<span class="title function_">toDataURL</span>());</span><br></pre></td></tr></table></figure>
<p>得到的資料會像下面這樣的形式呈現，半形逗號之前為圖片的資訊，例如格式為 <code>image/png</code> 且以 base64 編碼，半形逗號後面的則是編碼後的資料 (data)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI4AAAAw...(ignored)</span><br></pre></td></tr></table></figure>
<h3 id="回傳-Base64-圖片"><a href="#回傳-Base64-圖片" class="headerlink" title="回傳 Base64 圖片"></a>回傳 Base64 圖片</h3><p>我們已經會使用 js 來取得 Base64 格式的圖片了，接下來就是要將它回傳到 Python 之中，Selenium 提供一個函數 <code>execute_async_script</code> 讓我們可以在當前頁面運行 js 腳本，並將結果回傳到 Python 中</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://ipost.post.gov.tw/pst/home.html&quot;</span></span><br><span class="line"></span><br><span class="line">driverPath = <span class="string">r&#x27;chromedriver.exe&#x27;</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=driverPath)</span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># callback function 會將 canvas.toDataURL() 回傳回來給 captchaBase64</span></span><br><span class="line">captchaBase64 = browser.execute_async_script(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    var canvas = document.createElement(&#x27;canvas&#x27;);</span></span><br><span class="line"><span class="string">    var context = canvas.getContext(&#x27;2d&#x27;);</span></span><br><span class="line"><span class="string">    var img = document.querySelector(&#x27;div.codes_img img&#x27;);</span></span><br><span class="line"><span class="string">    canvas.height = img.naturalHeight;</span></span><br><span class="line"><span class="string">    canvas.width = img.naturalWidth;</span></span><br><span class="line"><span class="string">    context.drawImage(img, 0, 0);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    callback = arguments[arguments.length - 1];</span></span><br><span class="line"><span class="string">    callback(canvas.toDataURL());</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>callback</code>：函式的最後一個參數 (<code>arguments[arguments.length - 1]</code>) 為 JavaScript Callback 函式，將要回傳的資料作為參數呼叫此函式，便能將資料回傳到 Python 之中。</li>
</ul>
<p>若想查看是否真的是驗證碼的圖，可以使用 <code>matplotlib</code> 套件來顯示，</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先將 data Url 前綴 (data:image/png;base64) 去除，再將 base64 資料轉為 bytes</span></span><br><span class="line">i = base64.b64decode(captchaBase64.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 因為 mpimg 讀取的是檔案，但我們不想存檔案於本地端，</span></span><br><span class="line"><span class="comment"># 所以在記憶體中創建一個內容為 i 的 bytes 檔案，</span></span><br><span class="line">i = io.BytesIO(i)</span><br><span class="line"><span class="comment"># 將 i 這個檔案以 PNG 的形式讀出，若不指定 format，imread 預設會以副檔名解析圖片，</span></span><br><span class="line"><span class="comment"># 若無法從副檔名得知，則直接以 PNG 嘗試解析。</span></span><br><span class="line"><span class="comment"># 這邊的情況是沒有副檔名，且有可能讀者遇到非 PNG 的圖片，</span></span><br><span class="line"><span class="comment"># 因此特別展示可以使用 format 來指定圖片形式</span></span><br><span class="line">i = mpimg.imread(i, <span class="built_in">format</span>=<span class="string">&#x27;PNG&#x27;</span>)</span><br><span class="line"><span class="comment"># 顯示驗證碼</span></span><br><span class="line">plt.imshow(i)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Python-%E4%BD%BF%E7%94%A8-Selenium-%E6%8A%93%E7%95%B6%E5%89%8D%E9%A0%81%E9%9D%A2%E9%A9%97%E8%AD%89%E7%A2%BC%E5%9C%96%E7%89%87%2Fcaptcha_inpython.png?alt=media&amp;token=ad16a02b-e9e4-474c-94b8-ddfd75efb213" alt="取得與網頁一樣的驗證碼圖片"><span class="image-caption">取得與網頁一樣的驗證碼圖片</span></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>爬蟲爬的是 html 文件，因此 js、css 多少都要會，這個例子關鍵在於 js 的使用，用以取得 img 標籤 Base64 格式圖片，這是單純 Python 無法達到的功能。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/62511789/javascript-how-to-get-image-as-bytes-from-a-page-without-redownloading">Javascript: how to get image as bytes from a page (without redownloading)</a></p>
</li>
<li><p><a href="https://www.e-learn.cn/content/wangluowenzhang/374155">Understanding execute async script in Selenium</a></p>
</li>
<li><p><a href="ttps://blog.csdn.net/ngsb153/article/details/99674382">Python+Selenium 如何使用execute_async_script的callback</a></p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017609424203904">StringIO和BytesIO</a></p>
</li>
<li><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imread.html">matplotlib.pyplot.imread</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>python</tag>
        <tag>crawl</tag>
        <tag>requests</tag>
        <tag>selenium</tag>
        <tag>img</tag>
        <tag>download</tag>
        <tag>base64</tag>
        <tag>captcha</tag>
        <tag>matplotlib</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] 爬蟲遇到 &#39;cp950&#39; codec can&#39;t encode ?</title>
    <url>/2021/06/12/python_cp950_codec_cant_encode/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬蟲時，想將資料輸出到 <code>txt</code> 檔案遇到 <code>cp950</code> 等錯誤資訊，是甚麼原因？該怎麼辦？讓我來告訴你。</p>
<h2 id="問題原因"><a href="#問題原因" class="headerlink" title="問題原因"></a>問題原因</h2><p>遇到過類似下面的錯誤訊息嗎？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: <span class="string">&#x27;cp950&#x27;</span> codec can<span class="number">&#x27;</span>t encode character <span class="string">&#x27;\u67b1&#x27;</span> in position <span class="number">20</span>: illegal multibyte sequence</span><br></pre></td></tr></table></figure>
<p>這主要原因為某個字元不是 code page 950 (<code>cp950</code>) 內有的字，而無法編碼寫進檔案裡面。</p>
<p><code>Python</code> 處理字串預設是 <code>Unicode</code> 編碼，而在存檔案時，<code>Python</code> 會檢查命令提示字元的編碼頁 (此為 <code>cp950</code>) 做為檔案輸出的預設編碼頁，因此會需要將 <code>Unicode</code> 字串皆轉為 <code>cp950</code>，若此時有字不在 <code>cp950</code> 內的話，就會出現此錯誤訊息。</p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>修改 <code>Python</code> 程式，在 <code>open</code> 檔案時多一個輸入參數，讓讀寫檔案的編碼方式為 <code>UTF-8</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;text.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>crawl</tag>
        <tag>cp950</tag>
        <tag>txt</tag>
        <tag>output</tag>
        <tag>unicodeencodeerror</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] 爬蟲遇到 email protected 的原因與解決方法</title>
    <url>/2021/06/12/python_email_protected/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬蟲盛行的年代，防爬蟲的技術也隨之而起，其中一種技術是將電子郵件編碼，藉由網頁載入 <code>js</code> 後還原回正常的電子郵件格式。但是這種防禦手法效用可以說是微乎其微，甚至還要多花時間去解碼，可以說是得不償失。</p>
<p>沒有效用的原因有很多，主要是因為這不是加密解密問題，單純只是編碼與解碼，所以非常容易破解。再者，可以使用 <code>selenium</code> 等網頁載入好再進行爬蟲的動作。</p>
<p>雖然如此，現在遇到這項技術還是要研究一下其原理，為了以後遇到其他問題時可以有不一樣的思路。</p>
<h2 id="問題解析"><a href="#問題解析" class="headerlink" title="問題解析"></a>問題解析</h2><p>在爬蟲時遇到電子郵件的地方有可能會顯示被加密的狀態，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;__cf_email__&quot;</span> <span class="attr">data-cfemail</span>=<span class="string">&quot;f2f0ded3dcd1dad7c6c6f2&quot;</span>&gt;</span>[email<span class="symbol">&amp;#160;</span>protected]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>真正的電子郵件被編碼變成 <code>data-cfemail</code> 屬性的數值，這長長一串都是 16 進位的表示，且分為兩個部分</p>
<ol>
<li>密鑰：前兩碼為密鑰的 16 進位表示法。</li>
<li>信箱本體：除了密鑰，都為信箱本體，每兩個字元分為一組。</li>
</ol>
<p>採取最簡單的異或 (<code>xor</code>) 編碼方法，也就是密鑰與信箱本體依序的去做 <code>xor</code>運算，所得結果即為編碼後的結果。</p>
<script type="math/tex; mode=display">key \oplus e\textnormal{-}mail = data\textnormal{-}cfemail</script><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>知道規則後，接下來只要解碼就可以了。若要解碼，對編碼後的數值多 <code>xor</code> 一次，就能得到原本的信箱字串</p>
<script type="math/tex; mode=display">data\textnormal{-}cfemail \oplus key = (key \oplus e\textnormal{-}mail) \oplus key = e\textnormal{-}mail</script><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">codedMail = <span class="string">&#x27;4D08202C242108232E222924232A0d39283E39632E222063393A&#x27;</span></span><br><span class="line">key = <span class="built_in">int</span>(codedMail[:<span class="number">2</span>], <span class="number">16</span>) <span class="comment"># 前兩字元為 16 進位的密鑰</span></span><br><span class="line">codedMail = codedMail[<span class="number">2</span>:] <span class="comment"># 刪除前兩字元</span></span><br><span class="line">EMail = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(codedMail) != <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">int</span>(codedMail[:<span class="number">2</span>], <span class="number">16</span>) <span class="comment"># 每兩碼當一個 16 進位的數字</span></span><br><span class="line">    EMail += <span class="built_in">chr</span>(key ^ temp) <span class="comment"># 做 xor 運算後為正確的 ascii 碼，再轉為字元</span></span><br><span class="line">    codedMail = codedMail[<span class="number">2</span>:] <span class="comment"># 繼續刪除前兩碼</span></span><br><span class="line"><span class="built_in">print</span>(EMail)</span><br><span class="line"><span class="comment"># EmailEncoding@test.com.tw</span></span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/36912486">破解爬虫过程中遇到的网页加密Email地址</a></li>
</ol>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>email</tag>
        <tag>python</tag>
        <tag>crawl</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title>[爬蟲] Selenium+Tkinter 製作具有驗證碼的網站登錄器</title>
    <url>/2021/10/29/selenium_tkinter_login/</url>
    <content><![CDATA[<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/%E7%88%AC%E8%9F%B2-Selenium-Tkinter-%E8%A3%BD%E4%BD%9C%E5%85%B7%E6%9C%89%E9%A9%97%E8%AD%89%E7%A2%BC%E7%9A%84%E7%B6%B2%E7%AB%99%E7%99%BB%E9%8C%84%E5%99%A8%2Floginer.png?alt=media&amp;token=24ed8154-7efc-400b-aaf9-529def61ecd4" alt="成品"><span class="image-caption">成品</span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬取帶有驗證碼登入的網頁時，通常會讓 Selenium 在登入頁面短暫的停留幾秒，讓自己可以手動輸入驗證碼，壞處是在時間上會讓人緊張。而此文章採用另一種方式，使用 Tkinter 模擬登入視窗，讓使用者可以直接在視窗中輸入帳號、密碼與驗證碼，接著交由程式繼續執行登入後的爬蟲動作。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Python 3.9.6</li>
<li>Pillow 8.4.0</li>
<li>selenium 4.0.0</li>
</ul>
<h2 id="取得驗證碼圖片資訊"><a href="#取得驗證碼圖片資訊" class="headerlink" title="取得驗證碼圖片資訊"></a>取得驗證碼圖片資訊</h2><p>這裡同樣以 <a href="https://ipost.post.gov.tw/pst/home.html">網路郵局</a> 網頁做為練習，<a href="/2021/07/04/python_selenium_captcha/">[Python] 使用 Selenium 爬蟲下載當前頁面驗證碼圖片</a> 一文中已清楚的講解取得驗證碼圖片的原理與實作，若還不清楚的讀者們，歡迎隨時複習。</p>
<p>與參考文獻不一樣的地方在於除了得到驗證碼圖片，這裡還想要得到圖片的尺寸 (長、寬)，之後在 Tkinter 視窗應用中較容易控制圖片的顯示，因此讓 <code>execute_async_script</code> 回傳的是一個物件，包含 <code>base64</code>、<code>height</code> 與 <code>width</code> 三個屬性</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://ipost.post.gov.tw/pst/home.html&quot;</span></span><br><span class="line"></span><br><span class="line">driverPath = <span class="string">r&#x27;chromedriver.exe&#x27;</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=driverPath)</span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line">captcha = browser.execute_async_script(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    var canvas = document.createElement(&#x27;canvas&#x27;);</span></span><br><span class="line"><span class="string">    var context = canvas.getContext(&#x27;2d&#x27;);</span></span><br><span class="line"><span class="string">    var img = document.querySelector(&#x27;div.codes_img img&#x27;);</span></span><br><span class="line"><span class="string">    canvas.height = img.naturalHeight;</span></span><br><span class="line"><span class="string">    canvas.width = img.naturalWidth;</span></span><br><span class="line"><span class="string">    context.drawImage(img, 0, 0);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    callback = arguments[arguments.length - 1];</span></span><br><span class="line"><span class="string">    callback(&#123; &#x27;base64&#x27;: canvas.toDataURL(), &#x27;height&#x27;: img.naturalHeight, &#x27;width&#x27;: img.naturalWidth&#125;);</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>captcha</code> 的資料格式如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;base64&#x27;</span>: <span class="string">&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI4AAAA...(ignored)&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;height&#x27;</span>: <span class="number">48</span>, </span><br><span class="line">    <span class="string">&#x27;width&#x27;</span>: <span class="number">142</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tkinter-登入器製作"><a href="#Tkinter-登入器製作" class="headerlink" title="Tkinter 登入器製作"></a>Tkinter 登入器製作</h2><p><code>captcha</code> 物件取得之後可以開始製作登入器，以下透過註解形式講解各功用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> base64, io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageTk, Image </span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Tkinter 主程式</span></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># UI 字形</span></span><br><span class="line">font = (<span class="string">&quot;Comic Sans MS&quot;</span>, <span class="number">30</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登入器的 Layout 如下 </span></span><br><span class="line"><span class="comment">#         column=0    column=1</span></span><br><span class="line"><span class="comment">#       ┌────────────────────────────┐</span></span><br><span class="line"><span class="comment"># row=0 | Account     &#123;accountEntry&#125; |   </span></span><br><span class="line"><span class="comment"># row=1 | User ID     &#123;userIdEntry&#125;  |</span></span><br><span class="line"><span class="comment"># row=2 | Passowrd    &#123;passwordEntry&#125;|</span></span><br><span class="line"><span class="comment"># row=3 | &#123;canvas&#125;    &#123;captchaEntry&#125; |</span></span><br><span class="line"><span class="comment"># row=4 |       &#123;VERITY&#125;             |</span></span><br><span class="line"><span class="comment">#       └────────────────────────────┘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (0, 0) 的位置建立一個會顯示 &#x27;Account&#x27; 的文字區塊</span></span><br><span class="line">tk.Label(root, text=<span class="string">&#x27;Account&#x27;</span>, font=font).grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 在 (0, 1) 的位置建立一個輸入 帳號 的欄位</span></span><br><span class="line">accountEntry = tk.Entry(root, width=<span class="number">15</span>, font=font)</span><br><span class="line">accountEntry.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (1, 0) 的位置建立一個會顯示 &#x27;User ID&#x27; 的文字區塊</span></span><br><span class="line">tk.Label(root, text=<span class="string">&#x27;User ID&#x27;</span>, font=font).grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 在 (1, 1) 的位置建立一個輸入 使用者代碼 的欄位</span></span><br><span class="line">userIdEntry = tk.Entry(root, width=<span class="number">15</span>, font=font)</span><br><span class="line">userIdEntry.grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (2, 0) 的位置建立一個會顯示 &#x27;Password&#x27; 的文字區塊</span></span><br><span class="line">tk.Label(root, text=<span class="string">&#x27;Password&#x27;</span>, font=font).grid(row=<span class="number">2</span>, column=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 在 (2, 1) 的位置建立一個輸入 密碼 的欄位</span></span><br><span class="line">passwordEntry = tk.Entry(root, width=<span class="number">15</span>, font=font)</span><br><span class="line">passwordEntry.grid(row=<span class="number">2</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (3, 0) 的位置建立一個會顯示驗證碼圖片的區塊</span></span><br><span class="line">canvas = tk.Canvas(root, width=captcha[<span class="string">&#x27;width&#x27;</span>], height=captcha[<span class="string">&#x27;height&#x27;</span>] * <span class="number">1.5</span>)      </span><br><span class="line">canvas.grid(row=<span class="number">3</span>, column=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 先將 data Url 前綴 (data:image/png;base64) 去除，再將 base64 資料轉為 bytes</span></span><br><span class="line">i = base64.b64decode(captcha[<span class="string">&#x27;base64&#x27;</span>].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 因為 mpimg 讀取的是檔案，但我們不想存檔案於本地端，</span></span><br><span class="line"><span class="comment"># 所以在記憶體中創建一個內容為 i 的 bytes 檔案，</span></span><br><span class="line">i = io.BytesIO(i)</span><br><span class="line"><span class="comment"># 使用 PIL 將檔案轉為 tk.Canvas 可以接收的格式</span></span><br><span class="line">img = ImageTk.PhotoImage(Image.<span class="built_in">open</span>(i)) </span><br><span class="line"><span class="comment"># 將圖片插入 canvas</span></span><br><span class="line">canvas.create_image(<span class="number">2</span>, <span class="number">15</span>, anchor=tk.NW, image=img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (3, 1) 的位置建立一個輸入 驗證碼 的欄位</span></span><br><span class="line">captchaEntry = tk.Entry(root, width=<span class="number">15</span>, font=font)</span><br><span class="line">captchaEntry.grid(row=<span class="number">3</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="comment"># 將 accountEntry 的文字輸入到登入頁面的 帳號 欄位</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;userActNo&quot;]&#x27;</span>).send_keys(accountEntry.get())</span><br><span class="line">    <span class="comment"># 將 userIdEntry 的文字輸入到登入頁面的 使用者代號 欄位</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;userID_2&quot;]/input&#x27;</span>).send_keys(userIdEntry.get())</span><br><span class="line">    <span class="comment"># 將 passwordEntry 的文字輸入到登入頁面的 密碼 欄位</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;userPWD_2&quot;]/input&#x27;</span>).send_keys(passwordEntry.get())</span><br><span class="line">    <span class="comment"># 將 captchaEntry 的文字輸入到登入頁面的 驗證碼 欄位</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;tab2&quot;]//input[@placeholder=&quot;共四碼&quot;]&#x27;</span>).send_keys(captchaEntry.get())</span><br><span class="line">    <span class="comment"># 按下登入按鈕</span></span><br><span class="line">    browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;tab2&quot;]//a[text()=&quot;登入&quot;]&#x27;</span>).click()</span><br><span class="line">    <span class="comment"># 關閉 Tkinter 主程式</span></span><br><span class="line">    root.destroy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (4, [0:2]) 的位置建立一個確認的按鈕，</span></span><br><span class="line"><span class="comment"># 按鈕按下後會執行 login() 函式</span></span><br><span class="line">verifyButton = tk.Button(root, text=<span class="string">&quot;VERIFY&quot;</span>, font=font, command=login)</span><br><span class="line">verifyButton.grid(row=<span class="number">4</span>, column=<span class="number">0</span>, columnspan=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 置頂 Tkinter 視窗</span></span><br><span class="line">root.attributes(<span class="string">&#x27;-topmost&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 啟動 Tkinter 主程式</span></span><br><span class="line">root.mainloop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 後續的程式碼為成功登入後，爬蟲要做的事情</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h2 id="隱藏-Chrome-瀏覽器"><a href="#隱藏-Chrome-瀏覽器" class="headerlink" title="隱藏 Chrome 瀏覽器"></a>隱藏 Chrome 瀏覽器</h2><p>當我們將登入器完成，Chrome 瀏覽器的顯示可視為非必要的，若想選擇讓它在執行爬蟲時隱藏起來，將開頭的程式碼改為如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options   <span class="comment"># 增加此行</span></span><br><span class="line">chrome_options = Options()                              <span class="comment"># 增加此行</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)               <span class="comment"># 增加此行</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://ipost.post.gov.tw/pst/home.html&quot;</span></span><br><span class="line"></span><br><span class="line">driverPath = <span class="string">r&#x27;chromedriver.exe&#x27;</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=driverPath, chrome_options=chrome_options)   <span class="comment"># 修改此行</span></span><br><span class="line">browser.get(url)</span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ol>
<li><p><a href="/2021/07/04/python_selenium_captcha/">[Python] 使用 Selenium 爬蟲下載當前頁面驗證碼圖片</a></p>
</li>
<li><p><a href="https://www.activestate.com/resources/quick-reads/how-to-add-images-in-tkinter/">How To Add Images In Tkinter</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/8691655/how-to-put-a-tkinter-window-on-top-of-the-others#answer-45064895">How to put a tkinter window on top of the others?</a></p>
</li>
<li><p><a href="http://python-learnnotebook.blogspot.com/2018/10/chrome-headless.html">如何使用 Chrome headless 無頭騎士模式教學</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>爬蟲筆記</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
        <tag>login</tag>
        <tag>crawl</tag>
        <tag>spider</tag>
        <tag>selenium</tag>
        <tag>captcha</tag>
        <tag>popup</tag>
        <tag>chrome</tag>
        <tag>headless</tag>
        <tag>pillow</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tool] IT 的好幫手 - 帳密顯示器</title>
    <url>/2021/06/15/tool_it_ap_displayer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 IT 產業中大概率會碰到管理很多伺服器的情況，要如何有組織的記錄這些帳號，是一個很重要的技能，記的好可以增加管理效率。個人有試過使用 Word、Excel，但每次要搜尋某帳號時都會花一段時間，且密碼都為明碼，若有人在旁觀看會非常不自在，且檔案位置難以管理，若是存雲端，則怕有資安疑慮。因此開發這個專案，讓帳號密碼顯示更為方便又兼顧安全性。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-IT-%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B-%E5%B8%B3%E5%AF%86%E9%A1%AF%E7%A4%BA%E5%99%A8%2Fapdisplayer2.0.0-border.png?alt=media&amp;token=3190406d-e769-4552-b45c-99f8259bf184" alt="AP Displayer"><span class="image-caption">AP Displayer</span></p>
<h2 id="取得工具"><a href="#取得工具" class="headerlink" title="取得工具"></a>取得工具</h2><div class="note info">
            <p><a href="https://github.com/weirenxue/ap-displayer/releases">帳密顯示器</a></p>
          </div>
<p>進入上方選擇所需檔案進行下載，這裡提供免安裝檔 <a href="https://github.com/weirenxue/ap-displayer/releases/download/v2.0-alpha.0/AP.Displayer.2.0.0.exe">AP.Displayer.2.0.0.exe</a> 與安裝檔 <a href="https://github.com/weirenxue/ap-displayer/releases/download/v2.0-alpha.0/AP.Displayer.Setup.2.0.0.exe">AP.Displayer.Setup.2.0.0.exe</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-IT-%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B-%E5%B8%B3%E5%AF%86%E9%A1%AF%E7%A4%BA%E5%99%A8%2Finstaller_v2.0-alpha.0.png?alt=media&amp;token=f64e84df-8806-42f0-902b-ffb64eb4928f" alt="下載"><span class="image-caption">下載</span></p>
<h2 id="為什麼要使用此專案？"><a href="#為什麼要使用此專案？" class="headerlink" title="為什麼要使用此專案？"></a>為什麼要使用此專案？</h2><p>我們可以將帳密表存在於 Excel (<code>*.xlsx</code>) 中，在透過此專案所開發之應用程式顯示，根據自己的喜好篩選資訊、遮罩資訊、隱藏資訊。  </p>
<h2 id="此專案所帶來的好處？"><a href="#此專案所帶來的好處？" class="headerlink" title="此專案所帶來的好處？"></a>此專案所帶來的好處？</h2><ol>
<li><strong>可以處理受加密的 xlsx 檔案 (當然需輸入正確密碼)</strong>，這樣若 Excel 加密過就不用擔心外流。✨👍😎</li>
<li>得益於使用 Excel 當作 DB，<strong>不會有任何可能性將帳密存於別人的資料庫內</strong>，非常安全。👏</li>
<li><strong>根據自己的喜好隱藏密碼或其他機敏資訊欄位</strong>，他人在旁邊偷看時也只能看到帳號而不知密碼，比直接開啟 Excel 好多了！👏</li>
<li><strong>直接點擊按鈕執行登入動作</strong>，省去剪剪貼貼的步驟，不同協定有不同效果。例如<ol>
<li>協定為 <code>rdp</code>：將<strong>自動開啟遠端軟體 (mstsc)</strong>，輸入目標 URI 並帶著帳密登入，免去剪剪貼貼輸入 IP/AP 的繁雜程序。👏</li>
<li>協定為 <code>http</code>/<code>https</code>：網頁登入形式太多，因此不協助登入，將會<strong>使用系統預設瀏覽器開啟該網址 (URI)</strong>。另外可用滑鼠右鍵🖱️點擊應用程式中的表格，即可直接複製帳號與密碼，省去框選/複製的時間，直接於網頁登入欄位貼上資訊。👏</li>
<li>其他協定：目前尚未實作，歡迎一起將此專案做的更完善。</li>
</ol>
</li>
<li><strong>使用下拉式選單</strong> 或者 <strong>關鍵字</strong> 篩選出想要的資訊<ol>
<li>下拉式選單：<strong>由使用者自己選定</strong>甚麼欄位要用來做為下拉式選單篩選，非常自由。👏</li>
<li>關鍵字：單筆資料中，只要有一個欄位包含關鍵字的就會被篩選出來，可用半形逗號 (,) 來輸入多個關鍵字！👏</li>
</ol>
</li>
<li><strong>右鍵點擊表格，即可複製表格中的資訊</strong>，省去框選並複製的時間 (自己框選還有可能選錯、多選到空白鍵，有這個功能真是太好了 😭)。👏</li>
<li>此專案只會呈現資訊，並不能修改內容，<strong>不用怕修改到原始檔案</strong>。👏</li>
<li>備份 Excel 檔即可。👏</li>
</ol>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><ol>
<li>下載 <a href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-IT-%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B-%E5%B8%B3%E5%AF%86%E9%A1%AF%E7%A4%BA%E5%99%A8%2Ftemplate.xlsx?alt=media&amp;token=7d97e0da-ac7b-40a9-b4b8-af8a80390ce5">template.xlsx</a> 檔案並開啟，會看到有兩個工作表📄📄，分別為 <code>metadata</code>、<code>ap</code>。<ul>
<li><code>metadata</code> 工作表<br>  已經有定義好的一排標頭 (順序請勿更動)，根據定義增加紀錄即可。此工作表用來定義應用程式中顯示資料的相關設定。<ol>
<li><code>apHeader</code>：在 <code>ap</code> 工作表中的欄位名稱。✔️</li>
<li><code>displayHeader</code>：要顯示在應用程式的欄位名稱。✔️</li>
<li><code>hide</code>：是否預設隱藏此欄位，可另於應用程式中設定隱藏或顯示，空值代表不隱藏。✔️</li>
<li><code>mask</code>：是否預設遮罩此欄位，被遮罩的內容會以 <code>*</code> 符號表示，空值代表不遮罩。✔️</li>
<li><code>filterPriority</code>：下拉式選單的欄位優先順序，優先權越高填寫越高的數值，若為非數值，會以 <code>-9999</code> 作為其優先權；若為空值表示不作為篩選欄位。✔️</li>
</ol>
</li>
<li><code>ap</code> 工作表<br>  根據在 <code>metadata</code> 工作表設定的欄位，於此處添加相對應欄位。有 4 個欄位必須要有 (也必須存在於 <code>metadata</code> 工作表 ‼️)，如此一來對應的動作按鈕才能運作，分別為<ol>
<li><code>protocol</code>：該系統對應的協定，目前 rdp/http/https 有對應的動作。</li>
<li><code>uri</code>：該系統對應的 uri。</li>
<li><code>account</code>：帳號。</li>
<li><code>password</code>：密碼。</li>
</ol>
</li>
</ul>
</li>
<li>視需求加密 Excel 檔案。🔒</li>
<li>開啟 AP Displayer，選擇檔案 (<code>*.xlsx</code>) 並輸入密碼 (若有的話，無密碼則為空即可)。🔑</li>
<li>將會列出 Excel 內的帳密資訊！💯</li>
</ol>
<h2 id="歡迎-fork"><a href="#歡迎-fork" class="headerlink" title="歡迎 fork"></a>歡迎 fork</h2><p>歡迎社群的力量一起增強這個工具的功能！</p>
]]></content>
      <categories>
        <category>自行開發工具使用教學</category>
      </categories>
      <tags>
        <tag>electron</tag>
        <tag>js</tag>
        <tag>password</tag>
        <tag>react</tag>
        <tag>account</tag>
        <tag>tool</tag>
        <tag>it</tag>
        <tag>displayer</tag>
        <tag>word</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tool] 傳輸測試必備 - 垃圾檔案製造機</title>
    <url>/2021/10/31/tool_dummy_file/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大量的虛擬檔案 (Dummy file) 在傳輸測試中起到了至關重要的作用。需先有一定的檔案量，才有可能測試出較無偏差的結果，<code>dfgen</code> 這個工具允許使用者先行指定單一檔案大小的範圍，再指定總檔案容量大小，最後生成對應的 Dummy file。</p>
<h2 id="原始碼與執行檔連結"><a href="#原始碼與執行檔連結" class="headerlink" title="原始碼與執行檔連結"></a>原始碼與執行檔連結</h2><!-- markdownlint-disable MD034 -->
<ol>
<li><a class="btn" href="https://github.com/weirenxue/dummy-file-generator" title="Source code of Dummy file generator">
            <i class="fab fa-github"></i>Source code
          </a>
</li>
<li><a class="btn" href="https://github.com/weirenxue/dummy-file-generator/releases/tag/v1.0.0" title="Exe of Dummy file generator">
            <i class="fab fa-github"></i>dfgen.exe
          </a>
</li>
</ol>
<!-- markdownlint-restore MD034 -->
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>執行檔目前只針對 Windows 10 做打包，若非 Windows 10 但熟悉 Python 的讀者可以將 Source Code Clone 到本地端執行。</p>
<p>透過 <code>-h</code> 指令查看參數說明</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">.\dfgen.exe <span class="literal">-h</span></span><br><span class="line">usage: dfgen.exe [-<span class="type">h</span>] [-<span class="type">t</span> <span class="type">TARGET_SIZE</span>] [--<span class="type">min</span>-<span class="type">size</span> <span class="type">MIN_SIZE</span>] [--<span class="type">max</span>-<span class="type">size</span> <span class="type">MAX_SIZE</span>] [-<span class="type">c</span>] destination</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  destination           <span class="built_in">Where</span> are the dummy files stored to.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  <span class="literal">-h</span>, <span class="literal">--help</span>            show this help message and <span class="keyword">exit</span></span><br><span class="line">  <span class="literal">-t</span> TARGET_SIZE, <span class="literal">--target-size</span> TARGET_SIZE</span><br><span class="line">                        The total size of target. ([<span class="type">B</span>|<span class="type">KB</span>|<span class="type">MB</span>|<span class="type">GB</span>|<span class="type">TB</span>] default unit is Byte)</span><br><span class="line">  <span class="literal">--min-size</span> MIN_SIZE   The minimim size of a dummy file. ([<span class="type">B</span>|<span class="type">KB</span>|<span class="type">MB</span>|<span class="type">GB</span>|<span class="type">TB</span>] default unit is Byte)</span><br><span class="line">  <span class="literal">--max-size</span> MAX_SIZE   The maximum size of a dummy file. ([<span class="type">B</span>|<span class="type">KB</span>|<span class="type">MB</span>|<span class="type">GB</span>|<span class="type">TB</span>] default unit is Byte)</span><br><span class="line">  <span class="literal">-c</span>, <span class="literal">--clear-first</span>     Whether to <span class="built_in">clear</span> the files <span class="keyword">in</span> the destination directory first. (Default is false)</span><br></pre></td></tr></table></figure>
<h2 id="使用範例"><a href="#使用範例" class="headerlink" title="使用範例"></a>使用範例</h2><ol>
<li><p>在指定的目錄 <code>E:\dummy\</code> 產製 Dummy file，並且指定總容量為 <code>1GB</code>、單一檔案容量最小為 <code>1B</code> 而最大為 <code>5MB</code></p>
 <figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">.\dfgen.exe <span class="literal">--target-size</span> <span class="number">1</span>GB <span class="literal">--min-size</span> <span class="number">1</span>B <span class="literal">--max-size</span> <span class="number">5</span>MB E:\dummy\</span><br></pre></td></tr></table></figure>
<ul>
<li>執行之前，需先確認目錄 <code>E:\dummy\</code> 存在，且為空目錄。</li>
</ul>
</li>
<li><p>產製 Dummy file 在不為空的目錄</p>
 <figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">.\dfgen.exe <span class="literal">--target-size</span> <span class="number">1</span>GB <span class="literal">--min-size</span> <span class="number">1</span>B <span class="literal">--max-size</span> <span class="number">5</span>MB E:\dummy\ <span class="literal">-c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>當 <code>-c</code> 被設定，將會在產製 Dummy file 前，先清空指定的目錄。<strong>必須小心執行這個操作，因為清空的檔案無法復原！</strong></li>
</ul>
</li>
<li><p>如果 <code>--min-size</code> 大於 <code>--max-size</code>，會自動將兩個值對調，下方指令的執行結果與前一個範例結果相同</p>
 <figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">.\dfgen.exe <span class="literal">--target-size</span> <span class="number">1</span>GB <span class="literal">--min-size</span> <span class="number">5</span>MB <span class="literal">--max-size</span> <span class="number">1</span>B E:\dummy\ <span class="literal">-c</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>自行開發工具使用教學</category>
      </categories>
      <tags>
        <tag>file</tag>
        <tag>python</tag>
        <tag>tool</tag>
        <tag>dummy</tag>
        <tag>transmission</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tool] 提高效率必用 - 多字串取代器</title>
    <url>/2021/07/09/tool_multi_str_replace/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不論是在上學做作業、上班做報告時，都一定有碰過字串取代的功能。只取代一個文字可能還好，但有沒有體會過要取代 5 個字彙甚至更多的那種無力感呢？我就有這種深刻的體會，因為在寫程式時也會需要用到這個功能，這裡就以我最常遇到的情況當一個範例，教各位如何使用這個工具，提升自己的工作效率！</p>
<h2 id="工具連結"><a href="#工具連結" class="headerlink" title="工具連結"></a>工具連結</h2><div class="note info">
            <p><a href="/multi-str-replace/">多字串取代器</a></p>
          </div>
<h2 id="介面說明"><a href="#介面說明" class="headerlink" title="介面說明"></a>介面說明</h2><p>多字串取代器是一個網頁型態的工具，只需要有瀏覽器 (Chrome、Firefox 等) 就可以使用，不用另外下載與安裝，提高便攜性。介面中有兩個頁籤</p>
<h3 id="替換文字設定"><a href="#替換文字設定" class="headerlink" title="替換文字設定"></a>替換文字設定</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%BF%85%E7%94%A8-%E5%A4%9A%E5%AD%97%E4%B8%B2%E5%8F%96%E4%BB%A3%E5%99%A8%2Freplace_setting.png?alt=media&amp;token=8571e19a-5afa-4ea5-a63e-d193f0744146" alt="替換文字設定"><span class="image-caption">替換文字設定</span></p>
<p>這個頁面可以讓我們親自設定想要取代的字彙 (Find What) 與被取代的字彙 (Replace With)。</p>
<p>視使用情況，要取代的字彙量有可能多也有可能少，因此設計 <code>新增欄位</code>/<code>移除欄位</code> 按鈕讓使用者可以隨意新增或刪除要取代的字彙，不限定數量上限。</p>
<p>若設定完後，認為這些設定將來有可能還會用到，這裡也提供匯出的功能，下次直接將這次匯出的檔案匯入，就可以馬上使用上次設定好的字串對應，是一種很貼心的設計，讓使用者不用每次都輸入這麼多字彙，同時也避免人為輸入可能產生的錯誤。</p>
<p>當然，因為匯出的是一個檔案，因此可以分享給親朋好友、同事，讓對方使用此工具批量替換文字，使文章的用字遣詞達到一致性。</p>
<div class="note info">
            <p>被取代的文字背後運作是使用 Regex 字串比對來完成的，允許使用者輸入 Regex 形式，效率更上一層樓！</p>
          </div>
<h3 id="取代文字操作"><a href="#取代文字操作" class="headerlink" title="取代文字操作"></a>取代文字操作</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%BF%85%E7%94%A8-%E5%A4%9A%E5%AD%97%E4%B8%B2%E5%8F%96%E4%BB%A3%E5%99%A8%2Freplace_opt.png?alt=media&amp;token=f0a481ef-0a1e-459f-aa0d-7ec12a015fc5" alt="取代文字操作"><span class="image-caption">取代文字操作</span></p>
<p>這個頁面的功能簡潔易瞭，首先將文章貼入文字框內，再點擊 <code>取代</code> 按鈕，框內中的文字會將「替換文字設定」頁籤所設定好的字彙替換掉。若想要複製文字框內的所有文字，點擊 <code>複製</code> 按鈕，若想要清除則直接點擊 <code>清除</code> 按鈕，讓使用者不需要手動全選 (<code>Ctrl + A</code>)，再複製 (<code>Ctrl + C</code>) /清除 (<code>backspace</code>)。</p>
<h2 id="使用範例"><a href="#使用範例" class="headerlink" title="使用範例"></a>使用範例</h2><h3 id="問題說明"><a href="#問題說明" class="headerlink" title="問題說明"></a>問題說明</h3><p>相信在寫 <code>SQL</code> 搭配其它後端語言 (<code>C#</code>、<code>JAVA</code>、<code>GO</code> 等，這裡以 <code>C#</code> 為例子) 的時候，第一步一定是在 DBMS 上確認 SQL 邏輯是否正確，第二步就會遭遇到問題，當我們要將 <code>SQL</code> 轉為字串放到後端語言中，需要先將 <code>SQL</code> 前後加上引號，若 <code>SQL</code> 只有簡短的一行不會造成太大困擾，若 <code>SQL</code> 有幾十行，手動加上引號會要工程師的命 (但可能只有我不想手動做這件事也說不定 😄)，不僅僅是浪費時間，同時也可能因為在手動加入引號的過程中，發生細微的錯誤而沒注意到。</p>
<p>舉例來說，若 <code>SQL</code> 原文如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">name</span><br><span class="line">,birthday</span><br><span class="line">,sex</span><br><span class="line">,age</span><br><span class="line">,family</span><br><span class="line">,height</span><br><span class="line">,weight</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">member</span></span><br></pre></td></tr></table></figure>
<!-- markdownlint-disable MD038 -->
<p>要將其放到 <code>C#</code> 程式中，必須每一行前面加上 <code>&quot;</code> 與後面加上 <code>&quot; +</code>，這是一件非常繁瑣的事情，且是每個 <code>SQL</code> 都必需經過這個步驟，想想都覺得累</p>
<!-- markdownlint-restore MD038 -->
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> SQL = </span><br><span class="line">            <span class="string">&quot; SELECT &quot;</span> +</span><br><span class="line">            <span class="string">&quot; name &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,birthday &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,sex &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,age &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,family &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,height &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ,weight &quot;</span> +</span><br><span class="line">            <span class="string">&quot; FROM member &quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="利用工具解決問題"><a href="#利用工具解決問題" class="headerlink" title="利用工具解決問題"></a>利用工具解決問題</h3><p>現在就利用多字串取代器協助我們完成這件繁瑣的事情吧！</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%BF%85%E7%94%A8-%E5%A4%9A%E5%AD%97%E4%B8%B2%E5%8F%96%E4%BB%A3%E5%99%A8%2Freplace_example.png?alt=media&amp;token=b607a0c9-4eff-4d9a-b02d-ccc3f7554319" alt="多字串取代器使用範例"><span class="image-caption">多字串取代器使用範例</span></p>
<ol>
<li>更改標題名稱：直接點擊表格標題區域即可修改，修改為自己看得懂的標題，當匯出的時候也會以此標題為匯出的檔名。</li>
<li>設定對應的字串<ol>
<li><code>\s*$</code>：將每一行結尾的所有空白鍵都替換為空字串，也就是去除結尾空白的意思。</li>
<li><code>^\s*</code>：將每一行開頭的所有空白鍵都替換為空字串，也就是去除開頭空白的意思。 <!-- markdownlint-disable MD038 --></li>
<li><code>$</code>：將每一行的結尾都加上 <code>&quot; +</code></li>
<li><code>^</code>：將每一行的結尾都加上 <code>&quot;</code> <!-- markdownlint-restore MD038 --></li>
</ol>
</li>
<li>將要取代的文字在文字框貼上。</li>
<li>取代：順序為從上往下的將第 2 步驟設定的取代字彙取代掉。</li>
<li>最後的取代結果。</li>
</ol>
<p>是不是很簡單！這裡提供匯出的檔案 <a href="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Tool-%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%BF%85%E7%94%A8-%E5%A4%9A%E5%AD%97%E4%B8%B2%E5%8F%96%E4%BB%A3%E5%99%A8%2FSQL%20to%20C%23_20210709_150338.json?alt=media&amp;token=dfccbf7e-f7ff-4721-bec6-2b63e35bd1ed">SQL to C#.json</a> 供大家下載來嘗試使用，實際操作更快上手，只需點擊匯入按鈕將此檔案上傳即可使用。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>隨著自己遇到的問題越來越多，陸陸續續做出一些小工具試圖解決這些問題，多字串取代器是其中一個小工具，解決了不論是開發或是文書上總會遇到的煩惱，因此在這裡分享給大家一起使用。</p>
<div class="note info">
            <p>若有任何疑問、建議或問題回報，歡迎於下方討論區留言。</p>
          </div>
]]></content>
      <categories>
        <category>自行開發工具使用教學</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>multiple</tag>
        <tag>string</tag>
        <tag>replace</tag>
        <tag>once</tag>
        <tag>lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tool] 滲透利器 - SQL Injection 合成語句即時顯示器</title>
    <url>/2021/06/15/tool_sql_injection/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Injection 攻擊名列 OWASP TOP 10 中的 Top 1！SQL Injection 也是一種 Injection 形式，身為工程師去了解 SQL Injection 原理是必要的。SQL Injection 合成出新的語句，對於初學者而言難以憑空想像，通常需要使用程式來查看，若每測試一個語句就要寫幾行程式，太麻煩了！這裡開發出網頁版的時實 SQL 合成，適合拿來在課堂上教學使用，更適合在滲透測試時可以用來猜測、利用與驗證。</p>
<h2 id="工具連結"><a href="#工具連結" class="headerlink" title="工具連結"></a>工具連結</h2><div class="note info">
            <p><a href="/injection-in-time/">SQL 注入合成器</a></p>
          </div>
<h2 id="安裝說明"><a href="#安裝說明" class="headerlink" title="安裝說明"></a>安裝說明</h2><p>這個工具是以 <code>javascript</code> 開發的，目的是讓使用者只需有瀏覽器，即可隨時使用，不用額外安裝軟體！</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>將 SQL 語句貼至 <code>GUESS SQL HERE</code>，注入之前的預覽會在 <code>PREVIEW</code> 區域。</li>
<li>填寫要注入的參數名稱於 <code>Parameter Name</code>。</li>
<li>填寫對應要注入的值於 <code>Value</code>。</li>
<li>注入後的 SQL 語句會顯示在 <code>AFTER INJECTION</code> 區域。</li>
<li>可由 <code>PREVIEW</code> 與 <code>AFTER INJECTION</code> 對比查看，體會一下 SQL Injection 的威力！</li>
</ol>
<h2 id="補充小常識"><a href="#補充小常識" class="headerlink" title="補充小常識"></a>補充小常識</h2><p>要預防被注入、安全的執行 SQL，必定要用 <code>Parameterized Query + Prepared Statement</code>，缺一不可。</p>
]]></content>
      <categories>
        <category>自行開發工具使用教學</category>
      </categories>
      <tags>
        <tag>time</tag>
        <tag>tool</tag>
        <tag>sql</tag>
        <tag>injection</tag>
        <tag>real</tag>
        <tag>synthesis</tag>
        <tag>tutorial</tag>
        <tag>penetrate</tag>
        <tag>pentest</tag>
      </tags>
  </entry>
  <entry>
    <title>[RDP] Windows 10 新增使用者並賦予遠端桌面權限</title>
    <url>/2021/06/13/rdp_windows_10/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在同一台電腦 Windows 上，若想要擁有自己個人桌面，就需要不與他人共用的一個使用者帳號；若想要遠端連線，則需要賦予使用者帳號遠端桌面的權限。</p>
<h2 id="新增帳號"><a href="#新增帳號" class="headerlink" title="新增帳號"></a>新增帳號</h2><p>組合鍵 <code>Windows + I</code> 開啟 Windows 的設定視窗。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-Windows-10-%E6%96%B0%E5%A2%9E%E4%BD%BF%E7%94%A8%E8%80%85%E4%B8%A6%E8%B3%A6%E4%BA%88%E9%81%A0%E7%AB%AF%E6%A1%8C%E9%9D%A2%E6%AC%8A%E9%99%90%2Fnew_account.png?alt=media&amp;token=7de524c5-ffa3-4354-85b8-d9bceabc340a" alt="新增其他使用者帳號"><span class="image-caption">新增其他使用者帳號</span></p>
<p>若使用者沒有 Microsoft 帳戶或不想用 Microsoft 帳戶登入，可以在此式窗選擇「我沒有這位人員的登入資訊」→「新增沒有 Microsoft 帳戶的使用者」，填寫在地端的帳號、密碼與三個安全性問題。</p>
<p>填寫完之後會在「家人與其他使用者」的「其他使用者」欄位看到新增的帳戶。</p>
<h2 id="設定遠端桌面權限"><a href="#設定遠端桌面權限" class="headerlink" title="設定遠端桌面權限"></a>設定遠端桌面權限</h2><p>將設定畫面點回到「首頁」，並點選「系統」→「遠端桌面」→「啟用遠端桌面」→「選取可以從遠端存取此電腦的使用者」→「新增」，輸入使用者帳號後按兩次確定即可增加權限</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-Windows-10-%E6%96%B0%E5%A2%9E%E4%BD%BF%E7%94%A8%E8%80%85%E4%B8%A6%E8%B3%A6%E4%BA%88%E9%81%A0%E7%AB%AF%E6%A1%8C%E9%9D%A2%E6%AC%8A%E9%99%90%2Fadd_remote_privilege.png?alt=media&amp;token=e523d5c2-14ee-4afe-9931-b465b268c6cd" alt="賦予使用者遠端桌面權限"><span class="image-caption">賦予使用者遠端桌面權限</span></p>
<p>使用者便可以遠端登入，並擁有自己的桌面與環境！</p>
]]></content>
      <categories>
        <category>遠端桌面使用筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>remote</tag>
        <tag>user</tag>
        <tag>privilege</tag>
        <tag>account</tag>
        <tag>rdp</tag>
      </tags>
  </entry>
  <entry>
    <title>[RDP] Windows 10 設定遠端多人多工</title>
    <url>/2021/06/13/rdp_windows_10_multi/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在許多實驗室內擁有被稱作 Super 的高配備電腦，希望能藉由提高運算速度，進而使產能增加。大多數人熟悉的作業系統是 Windows，為了配合使用者，Super 也是採用 Windows 的作業系統。</p>
<p>Windows 10 是一種單人多工作業系統，單一時間只能單人使用，導致資源大多都在閒置狀態，太浪費其強大運算能力。然而在 Windows 10 遠端多人多工並非官方開放的功能，因此在此紀錄如何將 Windows 10 改為可遠端多人多工系統，讓 Super 的效能有機會被發揮的淋漓盡致。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Windows 10</li>
</ul>
<h2 id="下載軟體"><a href="#下載軟體" class="headerlink" title="下載軟體"></a>下載軟體</h2><p>下載 <a href="https://github.com/stascorp/rdpwrap/releases">RDPWrap-v1.6.2.zip</a> 並解壓縮，裡面有</p>
<ul>
<li>update.bat</li>
<li>uninstall.bat</li>
<li>RDPWInst.exe</li>
<li>RDPConf.exe</li>
<li>RDPCheck.exe</li>
<li>install.bat</li>
</ul>
<h2 id="安裝軟體"><a href="#安裝軟體" class="headerlink" title="安裝軟體"></a>安裝軟體</h2><p>以系統管理員身分執行 <code>install.bat</code>，需出現 <code>Successfully installed.</code> 才算安裝完成。下方為安裝訊息，有標註出三個地方需要記起來，分別是 <code>termsrv.dll</code> 的版本、<code>RDP Wrapper</code> 的路徑還有 <code>rdpwrap.ini</code> 的路徑</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">RDP Wrapper Library v1.6.2</span><br><span class="line">Installer v2.5</span><br><span class="line">Copyright (C) Stas&#x27;M Corp. 2017</span><br><span class="line"></span><br><span class="line">[*] Notice to user:</span><br><span class="line">  - By using all or any portion of this software, you are agreeing</span><br><span class="line">  to be bound by all the terms and conditions of the license agreement.</span><br><span class="line">  - To read the license agreement, run the installer with -l parameter.</span><br><span class="line">  - If you do not agree to any terms of the license agreement,</span><br><span class="line">  do not use the software.</span><br><span class="line">[*] Installing...</span><br><span class="line">[*] Terminal Services version: 10.0.18362.657        # 這是自己電腦系統中 termsrv.dll 的版本，補丁要靠這個去找</span><br><span class="line">[-] This version of Terminal Services is not supported.</span><br><span class="line">Try running &quot;update.bat&quot; or &quot;RDPWInst -w&quot; to download latest INI file.</span><br><span class="line">If it doesn&#x27;t help, send your termsrv.dll to project developer for support.</span><br><span class="line">[+] TermService found (pid 1228).</span><br><span class="line">[*] No shared services found.</span><br><span class="line">[*] Extracting files...</span><br><span class="line">[+] Folder created: C:\Program Files\RDP Wrapper\    # 這是 RDP Wrapper 目錄路徑</span><br><span class="line">[*] Downloading latest INI file...</span><br><span class="line">[+] Latest INI file -&gt; C:\Program Files\RDP Wrapper\rdpwrap.ini     # 這是 rdpwrap.ini 檔案路徑</span><br><span class="line">[+] Extracted rdpw64 -&gt; C:\Program Files\RDP Wrapper\rdpwrap.dll</span><br><span class="line">[*] Configuring service library...</span><br><span class="line">[*] Checking dependencies...</span><br><span class="line">[*] Checking CertPropSvc...</span><br><span class="line">[*] Checking SessionEnv...</span><br><span class="line">[*] Terminating service...</span><br><span class="line">[*] Starting TermService...</span><br><span class="line">[-] StartService error (code 1056).</span><br><span class="line">[*] Configuring registry...</span><br><span class="line">[*] Configuring firewall...</span><br><span class="line">確定。</span><br><span class="line"></span><br><span class="line">[+] Successfully installed.</span><br><span class="line">______________________________________________________________</span><br><span class="line"></span><br><span class="line">You can check RDP functionality with RDPCheck program.</span><br><span class="line">Also you can configure advanced settings with RDPConf program.</span><br></pre></td></tr></table></figure>
<p>根據安裝訊息中出現的 <code>termsrv.dll</code> 版本去找相關補丁，此例為 <code>10.0.18362.657</code>，找到 <a href="https://github.com/asmtron/rdpwrap/blob/master/bin/autoupdate.bat">autoupdate.bat</a>，並在執行補丁之前，先以系統管理員身分執行 <code>命令提示字元</code>，關閉遠端伺服器</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;net stop termservice</span><br><span class="line">下面的服務關係到 Remote Desktop Services 服務。</span><br><span class="line">停止 Remote Desktop Services 服務也會停止這些服務。</span><br><span class="line"></span><br><span class="line">   Remote Desktop Services UserMode Port Redirector</span><br><span class="line">   Agilent License Service</span><br><span class="line"></span><br><span class="line">要繼續執行這項操作嗎? (Y/N) [N]: y</span><br><span class="line">Remote Desktop Services UserMode Port Redirector 服務正在停止..</span><br><span class="line">Remote Desktop Services UserMode Port Redirector 服務已經成功停止。</span><br><span class="line"></span><br><span class="line">Agilent License Service 服務正在停止.</span><br><span class="line">Agilent License Service 服務已經成功停止。</span><br><span class="line"></span><br><span class="line">Remote Desktop Services 服務正在停止.</span><br><span class="line">Remote Desktop Services 服務已經成功停止。</span><br></pre></td></tr></table></figure>
<p>將原先壓縮檔內的 <code>RDPWInst.exe</code> 與後來下載的補丁 <code>autoupdate.bat</code> 移至 <code>RDP Wrapper</code> 目錄 <code>C:\Program Files\RDP Wrapper\</code> 後，再以系統管理員身分執行 <code>autoupdate.bat</code>，會開始自動更新 <code>rdpwrap.ini</code>，等它跑完就大功告成。</p>
<p>同樣以系統管理員身分執行 <code>命令提示字元</code>，開啟遠端伺服器</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;net start termservice</span><br><span class="line">Remote Desktop Services 服務正在啟動 .</span><br><span class="line">Remote Desktop Services 服務已經啟動成功。</span><br></pre></td></tr></table></figure>
<p>開啟 <code>RDPConf.exe</code> 確認都是綠字，有跑出紅字代表有地方沒設定好，需要再繼續調整。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-Windows-10-%E8%A8%AD%E5%AE%9A%E9%81%A0%E7%AB%AF%E5%A4%9A%E4%BA%BA%E5%A4%9A%E5%B7%A5%2Frdp_green_light.PNG?alt=media&amp;token=ea93e6c4-d3f1-4323-9415-e69515be3710" alt="全是綠字的畫面"><span class="image-caption">全是綠字的畫面</span></p>
<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>新增使用者，並使其有遠端桌面權限(參考：<a href="/2021/06/13/rdp_windows_10/">[RDP] Windows 10 新增使用者並賦予遠端桌面權限</a>)。</p>
<p>開啟 <code>RDPCheck.exe</code> 登入新的使用者帳號，若能登入到桌面，代表遠端多人多工設定成功。在其它電腦若想遠端進此電腦，可以使用 Windows 內建的 <code>mstsc.exe</code> 遠端桌面連線軟體，輸入此電腦 IP、帳號密碼即可進入遠端。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-Windows-10-%E8%A8%AD%E5%AE%9A%E9%81%A0%E7%AB%AF%E5%A4%9A%E4%BA%BA%E5%A4%9A%E5%B7%A5%2Frdp_final.PNG?alt=media&amp;token=16aa1a5d-7474-47e3-9d02-7d56d33dfc16" alt="成功畫面示意"><span class="image-caption">成功畫面示意</span></p>
<h2 id="建議"><a href="#建議" class="headerlink" title="建議"></a>建議</h2><p>這個方法並非官方所釋出的，因此在 Windows 更新後有可能遠端多人多工會失效，失效時需要重新進行一次本篇的整個步驟直到設定完成。</p>
<p>因此建議若經允許，可以停止 Super 的自動更新功能，當該電腦比較空閒之時，手動更新並重新設定遠端多人多工，比較不會在緊急時刻遇到 Windows 偷偷自動更新，無法遠端多人多工的窘境。</p>
]]></content>
      <categories>
        <category>遠端桌面使用筆記</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>remote</tag>
        <tag>rdp</tag>
        <tag>win10</tag>
        <tag>mstsc</tag>
        <tag>多人</tag>
        <tag>多工</tag>
        <tag>mutiplex</tag>
        <tag>wrapper</tag>
      </tags>
  </entry>
  <entry>
    <title>[RDP] 在 Ubuntu 18.04 使用 xrdp 遠端多人多工</title>
    <url>/2021/06/17/remote_ubuntu_xrdp/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>xrdp (X Remote Desktop Protocal) 是 Linux 系統上的遠端桌面伺服器，能夠讓透過遠端連線的使用者有 GUI 能夠使用。但在 Ubuntu 18.04 似乎沒辦法簡單的安裝，找了許多資料，終於找到可行的辦法。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="安裝-xrdp"><a href="#安裝-xrdp" class="headerlink" title="安裝 xrdp"></a>安裝 xrdp</h2><p>由於在 Ubuntu18.04 中 xrdp 會需要某些不相容的軟體包 (參考：<a href="https://c-nergy.be/blog/?p=13455">Better Fix xRDP issue on Ubuntu 18.04.2</a>)，因此要先安裝修正檔</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo add-apt-repository ppa:martinx/xrdp-hwe-18.04</span><br><span class="line">user@pc:~$ sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>再行安裝 xrdp</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo apt-get install xrdp xorg</span><br></pre></td></tr></table></figure>
<p>需將 xrdp 加入 ssl-cert 群組，然後重新啟動。這步很重要，無法連線很可能是這步驟沒做到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ sudo adduser xrdp ssl-cert</span><br><span class="line">user@pc:~$ sudo reboot</span><br></pre></td></tr></table></figure>
<h2 id="遠端連線"><a href="#遠端連線" class="headerlink" title="遠端連線"></a>遠端連線</h2><p>在 Windows 開啟內建 mstsc (遠端桌面連線)，輸入 server 的 IP、username 與 password，這些就是自己在 server 上的使用者帳密。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/Remote-%E5%9C%A8-Ubuntu-18-04-%E4%BD%BF%E7%94%A8-xrdp-%E9%81%A0%E7%AB%AF%E5%A4%9A%E4%BA%BA%E5%A4%9A%E5%B7%A5%2Fxrdp.png?alt=media&amp;token=b9905535-0f5c-42eb-ba33-c20510d2e71f" alt="遠端畫面"><span class="image-caption">遠端畫面</span></p>
]]></content>
      <categories>
        <category>遠端桌面使用筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>linux</tag>
        <tag>windows</tag>
        <tag>remote</tag>
        <tag>18.04</tag>
        <tag>rdp</tag>
        <tag>mstsc</tag>
        <tag>多人</tag>
        <tag>多工</tag>
        <tag>xrdp</tag>
      </tags>
  </entry>
  <entry>
    <title>[RDP] xrdp 遠端 menu 不見時登出的方法</title>
    <url>/2021/06/17/rdp_xrdp_menu/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在一台電腦上開啟 xrdp 伺服器，讓大家可以各自用自己的帳號登入，且互不相干擾。但使用過程中遇到一些突發性圖形介面的問題，需要重新登入才能正常運作。</p>
<p>然而，這個問題就是 menu 會不見，因此不能使用 GUI 的方式登出，所以查相關文獻並紀錄能夠不透過 GUI 從 Terminal 中輸入登出的指令。</p>
<h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul>
<li>Ubuntu 18.04 LTS</li>
</ul>
<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>問題示意圖如下，menu 不見，Reset Panel 也無法起作用，只能重新登入得到健全的畫面</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-xrdp-%E9%81%A0%E7%AB%AF-menu-%E4%B8%8D%E8%A6%8B%E6%99%82%E7%99%BB%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%2Fxrdp_no_menu_icon.png?alt=media&amp;token=e2f6bf02-28ec-4546-a83c-dc819abdc50c" alt="消失的 menu"><span class="image-caption">消失的 menu</span></p>
<h2 id="登出方法"><a href="#登出方法" class="headerlink" title="登出方法"></a>登出方法</h2><p>登出方法有兩種</p>
<h3 id="快捷鍵"><a href="#快捷鍵" class="headerlink" title="快捷鍵"></a>快捷鍵</h3><p>第一種是設定快速鍵，設定好之後，可以直接按快捷鍵登出，不需要指令，適合不擅長記指令的人使用，但需要在問題 (menu 不見) 發生前先設定好，才能使用</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/gh-pages-88339.appspot.com/o/RDP-xrdp-%E9%81%A0%E7%AB%AF-menu-%E4%B8%8D%E8%A6%8B%E6%99%82%E7%99%BB%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%2Fxrdp_setting_shortcut.png?alt=media&amp;token=9efdd681-5e07-42fe-846d-c3b41ab801dc" alt="設定快捷鍵"><span class="image-caption">設定快捷鍵</span></p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>要先知道當前的 Desktop Environment (DE) 是甚麼，可依照自己的 DE 查詢相關的登出指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ <span class="built_in">env</span> | grep _DESKTOP_SESSION | <span class="built_in">cut</span> -d <span class="string">&quot;_&quot;</span> -f 1</span><br><span class="line">MATE  <span class="comment"># 這裡依個人環境有所不同</span></span><br></pre></td></tr></table></figure>
<p>組合鍵 <code>Ctrl + Alt + T</code> 開啟 Terminal，這裡因為是用 mate DE，其登出指令如下。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user@pc:~$ mate-session-save --<span class="built_in">logout</span>  <span class="comment"># 若是 gnome 的話則為 gnome-session-quit</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>遠端桌面使用筆記</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
        <tag>menu</tag>
        <tag>rdp</tag>
        <tag>xrdp</tag>
        <tag>gnome</tag>
        <tag>logout</tag>
        <tag>mate</tag>
        <tag>disappear</tag>
      </tags>
  </entry>
</search>
